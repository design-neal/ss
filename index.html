<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="StockAI">
    <meta name="theme-color" content="#3b82f6">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon.svg">
    <title>StockAI - 주식 종목 분석</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        *{margin:0;padding:0;box-sizing:border-box;}
        :root{
            --bg:#0a0e14;--bg2:#111620;--bg3:#181e28;--bg4:#1f2733;
            --border:rgba(255,255,255,0.06);--text:#f1f5f9;--text2:#94a3b8;--text3:#4b5563;
            --blue:#3b82f6;--green:#22c55e;--red:#ef4444;--yellow:#eab308;--purple:#a78bfa;--cyan:#22d3ee;
            --r:20px;--r2:14px;--r3:10px;
        }
        [data-theme="light"]{
            --bg:#f5f7fa;--bg2:#ffffff;--bg3:#f0f2f5;--bg4:#e4e7ec;
            --border:rgba(0,0,0,0.08);--text:#1a1a2e;--text2:#4a5568;--text3:#a0aec0;
        }
        html{scroll-behavior:smooth;overflow-x:hidden;max-width:100vw;}
        body{font-family:'Pretendard',-apple-system,BlinkMacSystemFont,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;-webkit-font-smoothing:antialiased;overflow-x:hidden;max-width:100vw;}

        /* ===== APP SHELL ===== */
        .app-wrapper{display:flex;min-height:100vh;transition:padding-left .28s cubic-bezier(.4,0,.2,1);overflow-x:hidden;max-width:100vw;}
        .app{flex:1;min-width:0;width:100%;max-width:1200px;margin:0 auto;min-height:100vh;background:var(--bg);position:relative;overflow-x:hidden;}
        @media(min-width:768px){.app{display:grid;grid-template-columns:1fr;}}

        /* ===== SIDE NAV ===== */
        .side-nav{position:fixed;top:0;right:0;width:280px;height:100vh;background:var(--bg2);border-left:1px solid var(--border);z-index:200;display:flex;flex-direction:column;transform:translateX(100%);transition:transform .28s cubic-bezier(.4,0,.2,1);overflow:hidden;padding-top:env(safe-area-inset-top);}
        .side-nav.open{transform:translateX(0);}
        .side-nav-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);z-index:199;opacity:0;pointer-events:none;transition:opacity .28s ease;}
        .side-nav-backdrop.show{opacity:1;pointer-events:auto;}
        .side-nav-header{display:flex;align-items:center;justify-content:space-between;padding:20px 20px 16px;border-bottom:1px solid var(--border);}
        .side-nav-title{font-size:17px;font-weight:800;letter-spacing:-.5px;}
        .side-nav-close{width:32px;height:32px;display:flex;align-items:center;justify-content:center;border:none;background:var(--bg3);color:var(--text2);border-radius:8px;cursor:pointer;font-size:18px;font-family:inherit;transition:all .15s;}
        .side-nav-close:hover{background:var(--bg4);color:var(--text);}
        .side-nav-body{flex:1;overflow-y:auto;padding:12px 0;}
        .side-nav-section{padding:0 16px;margin-bottom:20px;}
        .side-nav-section-title{font-size:11px;font-weight:700;color:var(--text3);text-transform:uppercase;letter-spacing:.8px;padding:8px 4px;display:flex;align-items:center;gap:6px;}
        .side-nav-menu{display:flex;flex-direction:column;gap:2px;}
        .side-nav-item{display:flex;align-items:center;gap:12px;padding:12px 14px;border-radius:var(--r3);cursor:pointer;transition:all .15s;border:none;background:transparent;color:var(--text);font-size:14px;font-weight:600;font-family:inherit;width:100%;text-align:left;}
        .side-nav-item:hover{background:var(--bg3);}
        .side-nav-item.active{background:rgba(59,130,246,.1);color:var(--blue);}
        .side-nav-item-icon{width:20px;text-align:center;font-size:16px;flex-shrink:0;}
        .side-nav-item-text{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .side-nav-item-sub{font-size:11px;color:var(--text3);font-weight:500;flex-shrink:0;}
        .side-nav-divider{height:1px;background:var(--border);margin:8px 16px;}

        /* Fav list */
        .fav-empty{padding:20px 14px;text-align:center;color:var(--text3);font-size:13px;line-height:1.7;}
        .fav-item{display:flex;align-items:center;gap:10px;padding:10px 14px;border-radius:var(--r3);cursor:pointer;transition:all .15s;}
        .fav-item:hover{background:var(--bg3);}
        .fav-item-info{flex:1;min-width:0;}
        .fav-item-name{font-size:13px;font-weight:700;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .fav-item-code{font-size:11px;color:var(--text3);font-weight:500;}
        .fav-item-remove{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border:none;background:transparent;color:var(--text3);cursor:pointer;font-size:14px;border-radius:6px;flex-shrink:0;opacity:0;transition:all .15s;font-family:inherit;}
        .fav-item:hover .fav-item-remove{opacity:1;}
        .fav-item-remove:hover{color:var(--red);background:rgba(239,68,68,.1);}
        .fav-item-market{font-size:10px;font-weight:700;padding:2px 6px;border-radius:4px;flex-shrink:0;}
        .fav-item-market.kr{background:rgba(59,130,246,.12);color:var(--blue);}
        .fav-item-market.us{background:rgba(167,139,250,.12);color:var(--purple);}

        /* Hamburger button in header */
        .hamburger-btn{width:36px;height:36px;display:flex;align-items:center;justify-content:center;border:none;background:var(--bg3);color:var(--text2);border-radius:8px;cursor:pointer;font-size:18px;flex-shrink:0;transition:all .15s;font-family:inherit;}
        .hamburger-btn:hover{background:var(--bg4);color:var(--text);}

        /* Favorite star button on stock hero */
        .fav-star-btn{display:inline-flex;align-items:center;gap:6px;padding:6px 14px;border:1px solid var(--border);background:var(--bg3);color:var(--text3);border-radius:20px;cursor:pointer;font-size:12px;font-weight:600;font-family:inherit;transition:all .2s;margin-left:10px;vertical-align:middle;}
        .fav-star-btn:hover{border-color:var(--yellow);color:var(--yellow);background:rgba(234,179,8,.06);}
        .fav-star-btn.favorited{border-color:var(--yellow);color:var(--yellow);background:rgba(234,179,8,.1);}
        .fav-star-btn .star{font-size:15px;line-height:1;}

        @media(min-width:1024px){
            .side-nav.open ~ .app-wrapper{padding-right:280px;}
            .side-nav-backdrop{display:none !important;}
            .side-nav{width:280px;}
        }
        @media(max-width:1023px){
            .side-nav{width:300px;}
        }

        /* ===== HEADER - 토스증권 스타일 ===== */
        .header{position:sticky;top:0;z-index:100;background:color-mix(in srgb, var(--bg) 92%, transparent);backdrop-filter:blur(24px);-webkit-backdrop-filter:blur(24px);padding:16px 20px 12px;padding-top:calc(16px + env(safe-area-inset-top));}
        .header-top{display:flex;align-items:center;gap:12px;margin-bottom:14px;}
        .logo{font-size:20px;font-weight:800;letter-spacing:-0.8px;flex-shrink:0;}
        .logo span{color:var(--blue);font-weight:800;}
        .search-wrap{flex:1;display:flex;align-items:center;gap:8px;}
        .market-toggle{display:flex;background:var(--bg3);border-radius:var(--r3);padding:2px;flex-shrink:0;}
        .market-btn{padding:6px 14px;border:none;background:transparent;color:var(--text3);cursor:pointer;font-size:13px;font-weight:700;border-radius:8px;font-family:inherit;transition:all .2s;}
        .market-btn.active{background:var(--blue);color:#fff;}
        .search-box{flex:1;display:flex;align-items:center;background:var(--bg3);border-radius:var(--r3);padding:0 12px;border:1.5px solid transparent;transition:all .2s;}
        .search-box:focus-within{border-color:var(--blue);background:var(--bg4);}
        .search-box input{flex:1;background:transparent;border:none;color:var(--text);padding:10px 8px;font-size:14px;outline:none;font-family:inherit;min-width:0;}
        .search-box input::placeholder{color:var(--text3);}
        .search-btn{padding:10px 18px;border:none;background:var(--blue);color:#fff;border-radius:var(--r3);cursor:pointer;font-size:14px;font-weight:700;font-family:inherit;transition:all .15s;flex-shrink:0;}
        .search-btn:hover{background:#2563eb;transform:translateY(-1px);}
        .search-btn:active{transform:translateY(0);}


        /* ===== WELCOME SCREEN ===== */
        .welcome-screen{padding:0 0 80px;}
        .welcome-top{text-align:center;padding:80px 24px 48px;}
        .welcome-screen h2{font-size:28px;font-weight:800;margin-bottom:8px;letter-spacing:-1px;line-height:1.3;}
        .welcome-screen p{color:var(--text3);font-size:15px;margin-bottom:40px;}
        .example-chips{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;}
        .example-chip{background:var(--bg3);border:1px solid var(--border);padding:12px 22px;border-radius:28px;cursor:pointer;color:var(--text2);font-size:14px;font-weight:500;font-family:inherit;transition:all .2s;}
        .example-chip:hover{border-color:var(--blue);color:var(--blue);background:rgba(59,130,246,0.08);transform:translateY(-2px);}

        /* ===== TOP 100 SECTION ===== */
        .top100-section{max-width:1200px;margin:0 auto;padding:0 16px;}
        .top100-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;flex-wrap:wrap;gap:8px;}
        .top100-title{font-size:18px;font-weight:800;letter-spacing:-.5px;display:flex;align-items:center;gap:8px;}
        .top100-title .badge{font-size:11px;font-weight:700;background:var(--blue);color:#fff;padding:3px 10px;border-radius:12px;}
        .top100-updated{font-size:11px;color:var(--text3);font-weight:500;}
        .top100-filters{display:flex;gap:6px;margin-bottom:12px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;padding:2px 0;}
        .top100-filters::-webkit-scrollbar{display:none;}
        .top100-filter{padding:7px 16px;border:1px solid var(--border);background:transparent;color:var(--text3);border-radius:20px;cursor:pointer;font-size:12px;font-weight:600;font-family:inherit;transition:all .15s;white-space:nowrap;}
        .top100-filter.active{border-color:var(--blue);color:var(--blue);background:rgba(59,130,246,.08);}
        .top100-filter:hover:not(.active){border-color:var(--text3);color:var(--text2);}
        .top100-grid{display:flex;flex-direction:column;gap:2px;}
        .top100-row{display:grid;grid-template-columns:36px 1fr 100px 90px 70px;align-items:center;padding:10px 14px;background:var(--bg2);border-radius:var(--r3);cursor:pointer;transition:all .12s;gap:8px;}
        .top100-row:hover{background:var(--bg3);transform:translateX(2px);}
        .top100-row-head{background:transparent;padding:6px 14px;cursor:default;font-size:11px;font-weight:700;color:var(--text3);letter-spacing:.3px;}
        .top100-row-head:hover{background:transparent;transform:none;}
        .top100-rank{font-size:13px;font-weight:800;color:var(--text3);text-align:center;}
        .top100-rank.top3{color:var(--yellow);font-size:14px;}
        .top100-info{display:flex;flex-direction:column;gap:1px;min-width:0;}
        .top100-symbol{font-size:14px;font-weight:800;letter-spacing:-.3px;}
        .top100-name{font-size:11px;color:var(--text3);font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .top100-price{font-size:14px;font-weight:700;text-align:right;font-variant-numeric:tabular-nums;}
        .top100-change{font-size:13px;font-weight:700;text-align:right;font-variant-numeric:tabular-nums;}
        .top100-change.up{color:var(--green);}
        .top100-change.down{color:var(--red);}
        .top100-change.flat{color:var(--text3);}
        .top100-vol{font-size:11px;color:var(--text3);font-weight:600;text-align:right;}
        .top100-loading{text-align:center;padding:60px 0;color:var(--text3);font-size:14px;}
        /* Skeleton */
        @keyframes shimmer{0%{background-position:-400px 0}100%{background-position:400px 0}}
        .skel-row{display:grid;grid-template-columns:36px 1fr 100px 90px 70px;align-items:center;padding:10px 14px;gap:8px;}
        .skel-block{height:14px;border-radius:6px;background:linear-gradient(90deg,var(--bg3) 25%,var(--bg4) 50%,var(--bg3) 75%);background-size:800px 100%;animation:shimmer 1.2s infinite linear;}
        .skel-rank{width:20px;height:20px;border-radius:50%;}
        .skel-info{display:flex;flex-direction:column;gap:4px;}
        .skel-sym{width:60px;height:15px;}
        .skel-name{width:110px;height:11px;}
        .skel-price{width:70px;height:14px;margin-left:auto;}
        .skel-chg{width:55px;height:14px;margin-left:auto;}
        .skel-vol{width:45px;height:12px;margin-left:auto;}
        @media(max-width:640px){.skel-row{grid-template-columns:30px 1fr 80px 72px;padding:8px 10px;}.skel-vol{display:none;}}
        @media(min-width:900px){.skel-row{grid-template-columns:40px 1fr 120px 100px 90px;padding:11px 18px;}}
        @media(max-width:640px){
            .welcome-top{padding:60px 20px 36px;}
            .top100-section{padding:0 12px;}
            .top100-row{grid-template-columns:30px 1fr 80px 72px;padding:8px 10px;}
            .top100-vol{display:none;}
            .top100-row-head{grid-template-columns:30px 1fr 80px 72px;}
            .top100-symbol{font-size:13px;}
            .top100-price{font-size:13px;}
            .top100-change{font-size:12px;}
        }
        @media(min-width:900px){
            .top100-section{max-width:1200px;}
            .top100-row{grid-template-columns:40px 1fr 120px 100px 90px;padding:11px 18px;}
        }

        /* ===== MAIN CONTENT ===== */
        .main-content{padding:0 0 100px;}

        /* ===== STOCK HERO - 토스 대형 가격 표시 ===== */
        .stock-hero{padding:28px 24px 20px;display:none;}
        .stock-hero.show{display:block;}
        .stock-name{font-size:22px;font-weight:800;letter-spacing:-0.5px;}
        .stock-code{color:var(--text3);font-size:13px;margin-top:2px;font-weight:500;}
        .stock-price{font-size:42px;font-weight:800;margin-top:12px;letter-spacing:-2px;font-variant-numeric:tabular-nums;line-height:1.1;}
        .stock-change{font-size:16px;font-weight:700;margin-top:6px;font-variant-numeric:tabular-nums;}
        .stock-change.up{color:var(--red);}
        .stock-change.down{color:var(--blue);}
        .stock-change.flat{color:var(--text3);}

        /* ===== MARKET SESSION (프리/애프터) ===== */
        .market-session-info{display:none;margin-top:14px;}
        .market-session-info.show{display:flex;gap:10px;flex-wrap:wrap;}
        .session-badge{display:flex;align-items:center;gap:8px;background:var(--bg3);border-radius:var(--r3);padding:10px 14px;flex:1;min-width:min(180px,42vw);}
        .session-dot{width:7px;height:7px;border-radius:50%;flex-shrink:0;animation:pulse-dot 2s infinite;}
        .session-dot.pre{background:#a78bfa;}
        .session-dot.post{background:#f59e0b;}
        .session-dot.regular{background:var(--green);}
        .session-dot.closed{background:var(--text3);animation:none;}
        @keyframes pulse-dot{0%,100%{opacity:1;}50%{opacity:.4;}}
        .session-label{font-size:11px;font-weight:700;color:var(--text3);letter-spacing:.3px;white-space:nowrap;}
        .session-price{font-size:15px;font-weight:800;font-variant-numeric:tabular-nums;letter-spacing:-.5px;}
        .session-change{font-size:12px;font-weight:600;margin-left:auto;font-variant-numeric:tabular-nums;white-space:nowrap;}
        .session-change.up{color:var(--red);}
        .session-change.down{color:var(--blue);}
        .session-change.flat{color:var(--text3);}
        .session-time{font-size:10px;color:var(--text3);margin-top:2px;}

        /* ===== TAB NAVIGATION - 토스 스타일 ===== */
        .tab-nav{display:none;position:sticky;top:0;z-index:90;background:color-mix(in srgb, var(--bg) 95%, transparent);backdrop-filter:blur(20px);border-bottom:1px solid var(--border);padding:0 24px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;}
        .tab-nav::-webkit-scrollbar{display:none;}
        .tab-nav.show{display:flex;}
        .tab-item{padding:14px 4px;margin-right:24px;font-size:15px;font-weight:700;color:var(--text3);cursor:pointer;border-bottom:2.5px solid transparent;transition:all .2s;font-family:inherit;background:none;border-top:none;border-left:none;border-right:none;white-space:nowrap;flex-shrink:0;}
        .tab-item.active{color:var(--text);border-bottom-color:var(--text);}
        .tab-item:hover:not(.active){color:var(--text2);}

        /* ===== TAB CONTENT ===== */
        .tab-content{display:none;padding:0 0 8px;}
        .tab-content.active{display:block;}

        /* ===== CARDS ===== */
        .card{background:var(--bg2);border-radius:var(--r);padding:24px;margin:4px 24px;}
        .card-title{font-size:16px;font-weight:800;margin-bottom:18px;display:flex;align-items:center;gap:8px;letter-spacing:-0.3px;}
        .card-title .dot{width:8px;height:8px;border-radius:50%;display:inline-block;}

        /* ===== CHART (Lightweight Charts) ===== */
        .tv-chart-card{border-radius:var(--r2);border:1px solid var(--border);position:relative;display:flex;flex-direction:column;}
        .tv-chart-wrap{position:relative;width:100%;height:580px;border-radius:0 0 8px 8px;overflow:hidden;}
        .tv-fullscreen-btn{position:absolute;top:10px;right:10px;z-index:15;width:36px;height:36px;display:flex;align-items:center;justify-content:center;border:1px solid var(--border);background:rgba(17,22,32,.85);backdrop-filter:blur(8px);color:var(--text2);border-radius:8px;cursor:pointer;transition:all .15s;}
        .tv-fullscreen-btn:hover{background:var(--bg4);color:var(--text);}
        .tv-chart-card.fullscreen{position:fixed;inset:0;z-index:9999;border-radius:0;border:none;margin:0;max-width:none;}
        .tv-chart-card.fullscreen .tv-chart-wrap{flex:1;height:auto!important;border-radius:0;}
        /* Chart Toolbar */
        .chart-toolbar{display:flex;align-items:center;gap:6px;padding:10px 14px;background:var(--bg2);border-radius:8px 8px 0 0;border-bottom:1px solid var(--border);flex-wrap:wrap;}
        .chart-toolbar-group{display:flex;gap:3px;align-items:center;}
        .chart-toolbar-divider{width:1px;height:20px;background:var(--border);margin:0 6px;}
        .chart-tb-btn{padding:5px 12px;border:1px solid var(--border);background:transparent;color:var(--text3);border-radius:6px;cursor:pointer;font-size:12px;font-weight:600;font-family:inherit;transition:all .12s;white-space:nowrap;}
        .chart-tb-btn:hover{border-color:var(--text3);color:var(--text2);}
        .chart-tb-btn.active{border-color:var(--blue);color:var(--blue);background:rgba(59,130,246,.08);}
        .chart-tb-label{font-size:11px;color:var(--text3);font-weight:700;margin-right:4px;white-space:nowrap;}
        /* Drawing Tools */
        .draw-toolbar{display:flex;align-items:center;gap:4px;padding:6px 14px;background:var(--bg2);border-bottom:1px solid var(--border);flex-wrap:wrap;}
        .draw-tb-btn{width:32px;height:32px;display:flex;align-items:center;justify-content:center;border:1px solid transparent;background:transparent;color:var(--text3);border-radius:6px;cursor:pointer;transition:all .12s;flex-shrink:0;}
        .draw-tb-btn:hover{background:var(--bg3);color:var(--text2);}
        .draw-tb-btn.active{border-color:var(--purple);color:var(--purple);background:rgba(167,139,250,.1);}
        .draw-tb-btn svg{pointer-events:none;}
        .draw-color-btn{width:20px;height:20px;border-radius:50%;border:2px solid transparent;cursor:pointer;transition:all .12s;flex-shrink:0;}
        .draw-color-btn:hover{transform:scale(1.15);}
        .draw-color-btn.active{border-color:#fff;box-shadow:0 0 0 2px var(--bg2),0 0 0 3px currentColor;}
        .draw-width-btn{padding:4px 10px;border:1px solid var(--border);background:transparent;color:var(--text3);border-radius:5px;cursor:pointer;font-size:11px;font-weight:700;font-family:inherit;transition:all .12s;}
        .draw-width-btn.active{border-color:var(--purple);color:var(--purple);background:rgba(167,139,250,.08);}
        .draw-tb-divider{width:1px;height:22px;background:var(--border);margin:0 4px;}
        .draw-tb-label{font-size:10px;color:var(--text3);font-weight:700;margin-right:2px;}
        .draw-canvas{position:absolute;inset:0;z-index:10;pointer-events:none;}
        .draw-canvas.active{pointer-events:auto;cursor:crosshair;}
        .draw-count-badge{font-size:10px;font-weight:700;min-width:16px;height:16px;display:inline-flex;align-items:center;justify-content:center;border-radius:8px;background:var(--bg4);color:var(--text3);padding:0 4px;margin-left:2px;}
        .sub-chart-container{height:150px;width:100%;padding:0 8px;}
        .chart-full-col{display:flex;flex-direction:column;}

        /* ===== AI INDICATOR ===== */
        .ai-ind{margin:4px 16px;}
        .ai-ind-header{display:flex;align-items:center;gap:10px;margin-bottom:12px;}
        .ai-ind-header .card-title{margin-bottom:0;flex-shrink:0;}
        .ai-ind-prompt-row{display:flex;gap:8px;align-items:center;flex:1;min-width:0;}
        .ai-ind-input{flex:1;min-width:0;padding:8px 14px;border:1px solid var(--border);background:var(--bg3);color:var(--text);border-radius:8px;font-size:13px;font-family:inherit;outline:none;transition:border-color .15s;}
        .ai-ind-input:focus{border-color:var(--blue);}
        .ai-ind-input::placeholder{color:var(--text3);}
        .ai-ind-send{padding:8px 16px;border:none;background:var(--purple);color:#fff;border-radius:8px;cursor:pointer;font-size:13px;font-weight:700;font-family:inherit;transition:all .15s;white-space:nowrap;flex-shrink:0;}
        .ai-ind-send:hover{opacity:.85;}
        .ai-ind-send:disabled{opacity:.5;cursor:not-allowed;}
        .ai-ind-tabs{display:flex;gap:0;border-bottom:1px solid var(--border);margin-bottom:12px;}
        .ai-ind-tab{padding:10px 18px;border:none;background:transparent;color:var(--text3);font-size:13px;font-weight:700;font-family:inherit;cursor:pointer;border-bottom:2.5px solid transparent;transition:all .15s;}
        .ai-ind-tab.active{color:var(--purple);border-bottom-color:var(--purple);}
        .ai-ind-tab:hover:not(.active){color:var(--text2);}
        .ai-ind-tab-badge{display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;padding:0 5px;border-radius:9px;background:var(--bg4);color:var(--text3);font-size:10px;font-weight:700;margin-left:6px;}
        .ai-ind-tab.active .ai-ind-tab-badge{background:rgba(167,139,250,.15);color:var(--purple);}
        .ai-ind-panel{display:none;}
        .ai-ind-panel.active{display:block;}
        .ai-line-list{display:flex;flex-direction:column;gap:4px;}
        .ai-line-empty{text-align:center;padding:24px 0;color:var(--text3);font-size:13px;line-height:1.7;}
        .ai-line-item{display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--bg3);border-radius:var(--r3);transition:background .12s;}
        .ai-line-item:hover{background:var(--bg4);}
        .ai-line-color{width:14px;height:14px;border-radius:4px;flex-shrink:0;border:1px solid rgba(255,255,255,.1);}
        .ai-line-info{flex:1;min-width:0;}
        .ai-line-name{font-size:13px;font-weight:700;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .ai-line-sub{font-size:11px;color:var(--text3);margin-top:1px;}
        .ai-line-toggle{width:36px;height:20px;border-radius:10px;border:none;cursor:pointer;position:relative;transition:background .15s;flex-shrink:0;}
        .ai-line-toggle.on{background:var(--purple);}
        .ai-line-toggle.off{background:var(--bg4);}
        .ai-line-toggle::after{content:'';position:absolute;top:2px;width:16px;height:16px;border-radius:50%;background:#fff;transition:left .15s;}
        .ai-line-toggle.on::after{left:18px;}
        .ai-line-toggle.off::after{left:2px;}
        .ai-line-remove{width:28px;height:28px;display:flex;align-items:center;justify-content:center;border:none;background:transparent;color:var(--text3);cursor:pointer;border-radius:6px;font-size:16px;flex-shrink:0;transition:all .12s;font-family:inherit;}
        .ai-line-remove:hover{color:var(--red);background:rgba(239,68,68,.1);}
        .ai-line-clear-btn{margin-top:8px;padding:8px 16px;border:1px solid var(--border);background:transparent;color:var(--text3);border-radius:8px;cursor:pointer;font-size:12px;font-weight:600;font-family:inherit;transition:all .12s;width:100%;}
        .ai-line-clear-btn:hover{border-color:var(--red);color:var(--red);background:rgba(239,68,68,.05);}
        .ai-ind-chart{height:220px;width:100%;padding:0 8px;margin-top:8px;}
        .ai-ind-status{font-size:12px;color:var(--text3);padding:8px 0;display:flex;align-items:center;gap:6px;}
        .ai-ind-status .spinner{width:14px;height:14px;border:2px solid var(--border);border-top-color:var(--purple);border-radius:50%;animation:spin .6s linear infinite;}
        @keyframes spin{to{transform:rotate(360deg)}}
        .ai-ind-key-row{display:flex;gap:8px;align-items:center;margin-bottom:10px;}
        .ai-ind-key-input{flex:1;padding:7px 12px;border:1px solid var(--border);background:var(--bg3);color:var(--text);border-radius:8px;font-size:12px;font-family:monospace;outline:none;}
        .ai-ind-key-input:focus{border-color:var(--purple);}
        .ai-ind-key-btn{padding:7px 14px;border:none;background:var(--bg4);color:var(--text2);border-radius:8px;cursor:pointer;font-size:12px;font-weight:600;font-family:inherit;}
        .ai-ind-key-btn:hover{color:var(--text);}
        .ai-ind-examples{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px;}
        .ai-ind-example{padding:5px 12px;border:1px solid var(--border);background:var(--bg3);color:var(--text2);border-radius:20px;cursor:pointer;font-size:11px;font-weight:600;font-family:inherit;transition:all .12s;}
        .ai-ind-example:hover{border-color:var(--purple);color:var(--purple);background:rgba(167,139,250,.08);}
        .sub-chart-grid{display:grid;grid-template-columns:1fr;gap:0;}
        .sub-chart-grid .card{margin:4px 16px;}

        /* ===== INDICATOR GRID ===== */
        .indicator-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;}
        .indicator-item{background:var(--bg3);border-radius:var(--r3);padding:14px;transition:background .15s;}
        .indicator-item:hover{background:var(--bg4);}
        .indicator-label{font-size:11px;color:var(--text3);font-weight:700;margin-bottom:6px;text-transform:uppercase;letter-spacing:.5px;}
        .indicator-value{font-size:17px;font-weight:800;font-variant-numeric:tabular-nums;letter-spacing:-.5px;}
        .indicator-signal{font-size:11px;font-weight:700;margin-top:6px;padding:3px 10px;border-radius:20px;display:inline-block;}
        .signal-buy{background:rgba(34,197,94,.12);color:var(--green);}
        .signal-sell{background:rgba(239,68,68,.12);color:var(--red);}
        .signal-neutral{background:rgba(234,179,8,.1);color:var(--yellow);}

        /* ===== FINANCE GRID ===== */
        .finance-grid{display:flex;flex-direction:column;}
        .finance-item{display:flex;justify-content:space-between;align-items:center;padding:16px 0;border-bottom:1px solid var(--border);}
        .finance-item:last-child{border-bottom:none;}
        .finance-label{font-size:14px;color:var(--text3);font-weight:500;}
        .finance-value{font-size:15px;font-weight:700;font-variant-numeric:tabular-nums;}

        /* ===== STOCK EARNINGS SCHEDULE ===== */
        .se-next{display:flex;align-items:center;gap:14px;padding:18px;background:var(--bg3);border-radius:var(--r3);margin-bottom:12px;}
        .se-next-icon{width:44px;height:44px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:22px;flex-shrink:0;}
        .se-next-icon.upcoming{background:rgba(59,130,246,.12);}
        .se-next-icon.past{background:rgba(75,85,99,.15);}
        .se-next-info{flex:1;min-width:0;}
        .se-next-label{font-size:11px;font-weight:700;color:var(--text3);letter-spacing:.3px;margin-bottom:3px;}
        .se-next-date{font-size:16px;font-weight:800;letter-spacing:-.3px;}
        .se-next-detail{font-size:12px;color:var(--text2);margin-top:2px;}
        .se-next-dday{font-size:13px;font-weight:800;padding:5px 12px;border-radius:20px;white-space:nowrap;flex-shrink:0;}
        .se-next-dday.soon{background:rgba(239,68,68,.12);color:var(--red);}
        .se-next-dday.normal{background:rgba(59,130,246,.1);color:var(--blue);}
        .se-next-dday.done{background:rgba(75,85,99,.12);color:var(--text3);}
        .se-history{margin-top:4px;}
        .se-history-title{font-size:13px;font-weight:700;color:var(--text2);margin-bottom:10px;padding-left:2px;}
        .se-history-item{display:flex;align-items:center;gap:12px;padding:12px 0;border-bottom:1px solid var(--border);}
        .se-history-item:last-child{border-bottom:none;}
        .se-history-date{font-size:13px;font-weight:600;min-width:90px;color:var(--text2);}
        .se-history-eps{flex:1;display:flex;gap:16px;}
        .se-eps-box{display:flex;flex-direction:column;gap:1px;}
        .se-eps-label{font-size:10px;color:var(--text3);font-weight:600;}
        .se-eps-val{font-size:13px;font-weight:700;font-variant-numeric:tabular-nums;}
        .se-surprise{font-size:12px;font-weight:700;padding:3px 8px;border-radius:12px;white-space:nowrap;flex-shrink:0;}
        .se-surprise.beat{background:rgba(34,197,94,.12);color:var(--green);}
        .se-surprise.miss{background:rgba(239,68,68,.12);color:var(--red);}
        .se-surprise.meet{background:rgba(234,179,8,.1);color:var(--yellow);}
        .se-empty{text-align:center;padding:30px 0;color:var(--text3);font-size:13px;}

        /* ===== COMPANY PROFILE ===== */
        .cp-overview{display:flex;gap:16px;align-items:flex-start;padding:18px;background:var(--bg3);border-radius:var(--r3);margin-bottom:16px;}
        .cp-logo{width:56px;height:56px;border-radius:14px;background:var(--bg4);display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:800;color:var(--text2);flex-shrink:0;overflow:hidden;}
        .cp-logo img{width:100%;height:100%;object-fit:contain;}
        .cp-info{flex:1;min-width:0;}
        .cp-name{font-size:18px;font-weight:800;letter-spacing:-.3px;margin-bottom:2px;}
        .cp-meta{font-size:12px;color:var(--text3);line-height:1.6;}
        .cp-meta span{display:inline-flex;align-items:center;gap:4px;margin-right:12px;}
        .cp-section-title{font-size:14px;font-weight:700;color:var(--text);margin:16px 0 8px;padding-left:2px;display:flex;align-items:center;gap:6px;}
        .cp-info-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
        .cp-info-row{display:flex;justify-content:space-between;align-items:flex-start;gap:8px;padding:12px 14px;background:var(--bg3);border-radius:var(--r3);}
        .cp-info-label{font-size:12px;color:var(--text3);font-weight:600;flex-shrink:0;padding-top:1px;}
        .cp-info-value{font-size:13px;font-weight:700;text-align:right;word-break:break-word;overflow-wrap:break-word;max-width:62%;}
        .cp-shares-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:8px;}
        .cp-shares-card{padding:14px;background:var(--bg3);border-radius:var(--r3);}
        .cp-shares-label{font-size:11px;color:var(--text3);font-weight:600;margin-bottom:4px;}
        .cp-shares-value{font-size:18px;font-weight:800;font-variant-numeric:tabular-nums;}
        .cp-exec-table{width:100%;border-collapse:separate;border-spacing:0 2px;}
        .cp-exec-table th{font-size:11px;font-weight:700;color:var(--text3);letter-spacing:.3px;padding:8px 12px;text-align:left;background:var(--bg3);border-bottom:1px solid var(--border);}
        .cp-exec-table th:last-child{text-align:right;}
        .cp-exec-table td{font-size:13px;padding:12px;background:var(--bg3);border-bottom:1px solid rgba(255,255,255,.04);}
        .cp-exec-table tr:last-child td{border-bottom:none;}
        .cp-exec-table tr td:first-child{border-radius:8px 0 0 8px;}
        .cp-exec-table tr td:last-child{border-radius:0 8px 8px 0;text-align:right;}
        .cp-exec-name{font-weight:700;}
        .cp-exec-title{font-size:11px;color:var(--text3);margin-top:2px;}
        .cp-exec-pay{font-weight:700;color:var(--blue);font-variant-numeric:tabular-nums;}
        .cp-holder-list{display:flex;flex-direction:column;gap:8px;}
        .cp-holder-item{display:flex;align-items:center;gap:10px;padding:12px 16px;background:var(--bg3);border-radius:var(--r3);transition:background .15s;}
        .cp-holder-item:hover{background:var(--bg4);}
        .cp-holder-rank{width:24px;height:24px;border-radius:50%;background:var(--bg4);display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700;color:var(--text3);flex-shrink:0;}
        .cp-holder-name{font-size:13px;font-weight:600;flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .cp-holder-pct{font-size:13px;font-weight:700;color:var(--cyan);font-variant-numeric:tabular-nums;min-width:55px;text-align:right;}
        .cp-holder-shares{font-size:11px;color:var(--text3);min-width:70px;text-align:right;}
        .cp-insider-table{width:100%;border-collapse:separate;border-spacing:0 2px;}
        .cp-insider-table th{font-size:11px;font-weight:700;color:var(--text3);letter-spacing:.3px;padding:8px 10px;text-align:left;position:sticky;top:0;background:var(--bg2);z-index:1;}
        .cp-insider-table td{font-size:12px;padding:10px;background:var(--bg3);font-variant-numeric:tabular-nums;}
        .cp-insider-table tr td:first-child{border-radius:8px 0 0 8px;}
        .cp-insider-table tr td:last-child{border-radius:0 8px 8px 0;}
        .cp-insider-buy{color:var(--green);font-weight:700;}
        .cp-insider-sell{color:var(--red);font-weight:700;}
        .cp-insider-scroll{max-height:500px;overflow-y:auto;}
        .cp-empty{text-align:center;padding:30px 0;color:var(--text3);font-size:13px;}
        @media(max-width:600px){.cp-info-grid{grid-template-columns:1fr;}}

        /* ===== AI SCORE ===== */
        .ai-score-container{display:flex;align-items:center;gap:24px;margin-bottom:24px;}
        .ai-score-circle{width:110px;height:110px;border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;flex-shrink:0;}
        .ai-score-circle::before{content:'';position:absolute;inset:0;border-radius:50%;padding:4px;background:conic-gradient(var(--score-color) calc(var(--score)*3.6deg),var(--bg3) 0deg);-webkit-mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);-webkit-mask-composite:xor;mask-composite:exclude;}
        .ai-score-number{font-size:32px;font-weight:800;letter-spacing:-1.5px;}
        .ai-score-label{font-size:11px;color:var(--text3);font-weight:500;}
        .ai-recommendation{font-size:22px;font-weight:800;margin-bottom:6px;letter-spacing:-.5px;}
        .ai-summary{font-size:14px;color:var(--text2);line-height:1.7;}
        .ai-details{display:flex;flex-direction:column;gap:10px;margin-top:20px;}
        .ai-detail-item{background:var(--bg3);border-radius:var(--r3);padding:16px;}
        .ai-detail-title{font-size:14px;font-weight:700;margin-bottom:6px;display:flex;align-items:center;justify-content:space-between;}
        .ai-detail-text{font-size:13px;color:var(--text2);line-height:1.7;}
        .ai-bar{height:4px;background:var(--bg4);border-radius:2px;margin-top:10px;overflow:hidden;}
        .ai-bar-fill{height:100%;border-radius:2px;transition:width .6s ease;}
        .warning-box{background:rgba(234,179,8,.05);border:1px solid rgba(234,179,8,.15);border-radius:var(--r3);padding:16px;margin-top:20px;}
        .warning-box .title{font-size:13px;font-weight:700;color:var(--yellow);margin-bottom:4px;}
        .warning-box .text{font-size:12px;color:var(--text3);line-height:1.7;}

        /* ===== TIMING COMBINED CARD ===== */
        /* ===== ENTRY CARD ===== */
        .entry-card{position:relative;overflow:hidden;padding-left:0;padding-right:0;}
        .exit-card{padding-left:0;padding-right:0;}
        .entry-card::before{display:none;}
        .entry-verdict{text-align:center;padding:12px 0 8px;}
        .entry-icon{font-size:48px;line-height:1;margin-bottom:8px;}
        .entry-title{font-size:24px;font-weight:800;margin-bottom:4px;}
        .entry-subtitle{font-size:14px;color:var(--text2);line-height:1.7;}
        .entry-checklist{margin-top:8px;display:flex;flex-direction:column;gap:6px;}
        .entry-check-item{display:flex;align-items:flex-start;gap:12px;padding:10px 0;border-bottom:1px solid var(--border);font-size:13px;line-height:1.5;}
        .entry-check-item:last-child{border-bottom:none;}
        .entry-check-icon{flex-shrink:0;width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:800;margin-top:1px;}
        .entry-check-icon.pass{background:rgba(34,197,94,.15);color:var(--green);}
        .entry-check-icon.fail{background:rgba(239,68,68,.15);color:var(--red);}
        .entry-check-icon.warn{background:rgba(234,179,8,.15);color:var(--yellow);}
        .entry-check-text{flex:1;}
        .entry-check-label{font-weight:700;}
        .entry-check-desc{color:var(--text2);font-size:12px;margin-top:2px;}
        .entry-strategy{margin-top:8px;background:var(--bg3);border-radius:var(--r3);padding:14px;}
        .entry-strategy-title{font-size:14px;font-weight:700;margin-bottom:8px;color:var(--cyan);}
        .entry-strategy-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border);font-size:13px;}
        .entry-strategy-row:last-child{border-bottom:none;}
        .entry-strategy-label{color:var(--text3);}
        .entry-strategy-value{font-weight:700;}
        .entry-meter{margin-top:8px;}
        .entry-meter-bar{height:8px;background:var(--bg3);border-radius:4px;overflow:hidden;position:relative;}
        .entry-meter-fill{height:100%;border-radius:4px;transition:width .8s ease;}
        .entry-meter-labels{display:flex;justify-content:space-between;margin-top:6px;font-size:11px;color:var(--text3);}
        .entry-meter-pointer{position:absolute;top:-6px;width:3px;height:20px;background:#fff;border-radius:2px;transform:translateX(-50%);transition:left .8s ease;box-shadow:0 0 6px rgba(255,255,255,.5);}
        .entry-conditions-summary{display:flex;justify-content:center;gap:20px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);}
        .entry-cond-count{font-size:13px;font-weight:600;}
        .entry-cond-count .num{font-size:20px;font-weight:800;}

        /* ===== EXIT (매도) CARD ===== */
        .exit-card{position:relative;overflow:hidden;}
        .exit-card::before{display:none;}
        .exit-verdict{text-align:center;padding:12px 0 8px;}
        .exit-checklist{margin-top:8px;display:flex;flex-direction:column;gap:6px;}
        .exit-meter{margin-top:8px;}
        .exit-strategy{margin-top:8px;background:var(--bg3);border-radius:var(--r3);padding:14px;}


        /* ===== LOADING ===== */
        .loading-overlay{display:none;position:fixed;inset:0;background:color-mix(in srgb, var(--bg) 90%, transparent);z-index:1000;justify-content:center;align-items:center;flex-direction:column;gap:18px;backdrop-filter:blur(12px);}
        .loading-overlay.active{display:flex;}
        .spinner{width:40px;height:40px;border:3px solid var(--bg4);border-top-color:var(--blue);border-radius:50%;animation:spin .7s linear infinite;}
        @keyframes spin{to{transform:rotate(360deg);}}
        .loading-text{font-size:15px;color:var(--text2);font-weight:500;}

        /* ===== TOAST ===== */
        .toast{position:fixed;bottom:36px;left:50%;transform:translateX(-50%) translateY(120px);background:var(--bg3);border:1px solid var(--red);color:var(--red);padding:14px 28px;border-radius:16px;font-size:14px;font-weight:600;z-index:2000;transition:transform .3s cubic-bezier(.16,1,.3,1);max-width:90%;text-align:center;box-shadow:0 12px 40px rgba(0,0,0,.5);}
        .toast.show{transform:translateX(-50%) translateY(0);}

        /* ===== SCROLLBAR ===== */
        ::-webkit-scrollbar{width:3px;}
        ::-webkit-scrollbar-track{background:transparent;}
        ::-webkit-scrollbar-thumb{background:rgba(255,255,255,.08);border-radius:3px;}

        /* ===== DESKTOP 2-COL ===== */
        @media(min-width:900px){
            .app{max-width:1200px;}
            .stock-hero{padding:32px 32px 24px;}
            .card{margin:4px 0px;}
            .tab-content.active{display:grid;grid-template-columns:1fr 440px;gap:0;align-items:start;}
            #tabChart.active{display:block;}
            #tabAnalysis.active{display:block;}
            #tabOptions.active{display:block;}
            #tabInfo.active,#tabCompany.active{gap:8px;}
            #tabInfo .tab-col-left,#tabCompany .tab-col-left{padding-right:0;}
            #tabInfo .tab-col-right,#tabCompany .tab-col-right{padding-left:0;}
            #tabInfo .tab-col-left .card{margin-right:0;}
            #tabInfo .tab-col-right .card{margin-left:0;}
            .tab-col-left,.tab-col-right{display:flex;flex-direction:column;padding:0 32px;}
            #rrAnalysis{padding:0 32px;}
            .tv-chart-wrap{height:650px;}
            .sub-chart-grid{grid-template-columns:1fr 1fr;}
            .sub-chart-grid .card{margin:4px 12px;}
            .indicator-grid{grid-template-columns:repeat(3,1fr);}
            .header-top{max-width:1440px;margin:0 auto;}
            .tab-nav{padding:0 32px;}
        }
        @media(min-width:1100px){
            .app{max-width:1440px;}
            .tab-content.active{grid-template-columns:1fr 860px;}
            #tabChart.active{display:block;}
            #tabAnalysis.active{display:block;}
            #tabOptions.active{display:block;}
            .tv-chart-wrap{height:700px;}
        }

        /* ===== MOBILE (≤640px) ===== */
        @media(max-width:640px){
            /* ----- Header (2줄 레이아웃) ----- */
            .header{padding:10px 14px 10px;}
            .header-top{flex-wrap:wrap;gap:8px;margin-bottom:0;}
            .logo{font-size:17px;flex:1;}        /* 로고가 빈 공간 채움 */
            .search-wrap{order:3;flex:0 0 100%;width:100%;margin-top:6px;min-width:0;overflow:hidden;} /* 검색줄 전체 너비 */
            .search-box{min-width:0;} /* flex 아이템이 내용 크기 이하로 축소 가능하도록 */
            .search-box input{font-size:16px;padding:9px 8px;min-width:0;} /* 16px → iOS 자동 확대 방지 */
            .search-btn{padding:9px 16px;font-size:14px;font-weight:800;flex-shrink:0;white-space:nowrap;}

            /* ----- Welcome screen ----- */
            .welcome-top{padding:50px 16px 32px;}
            .welcome-screen h2{font-size:22px;}
            .welcome-screen p{font-size:13px;margin-bottom:24px;}
            .example-chip{padding:10px 16px;font-size:13px;}

            /* ----- Top 100 ----- */
            .top100-section{padding:0 10px;}
            .top100-title{font-size:15px;}
            .top100-row{grid-template-columns:28px 1fr 72px 64px;padding:8px 10px;gap:6px;}
            .top100-row-head{display:none;}
            .top100-vol{display:none;}
            .skel-row{grid-template-columns:28px 1fr 72px 64px;padding:7px 10px;}
            .skel-vol{display:none;}
            .top100-symbol{font-size:13px;}
            .top100-price{font-size:13px;}
            .top100-change{font-size:12px;}

            /* ----- Stock hero ----- */
            .stock-hero{padding:18px 16px 12px;}
            .stock-name{font-size:18px;}
            .stock-code{font-size:12px;}
            .stock-price{font-size:32px;letter-spacing:-1.5px;margin-top:8px;}
            .stock-change{font-size:14px;margin-top:4px;}

            /* ----- Session badges ----- */
            .session-badge{min-width:0;padding:8px 10px;gap:6px;}
            .session-price{font-size:13px;}
            .session-change{font-size:11px;}

            /* ----- Tab nav ----- */
            .tab-nav{padding:0 4px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;}
            .tab-nav::-webkit-scrollbar{display:none;}
            .tab-item{padding:12px 10px;margin-right:2px;font-size:13px;white-space:nowrap;flex-shrink:0;}

            /* ----- Cards ----- */
            .card{margin:4px 10px;padding:16px;}
            .card-title{font-size:14px;margin-bottom:12px;}
            .ai-summary,.ai-detail-text,.entry-subtitle,.entry-check-desc,.warning-box .text,.entry-strategy-label,.top100-name{overflow-wrap:break-word;word-break:keep-all;}
            .ai-detail-title{flex-wrap:wrap;gap:4px;}

            /* ----- Chart ----- */
            .tv-chart-wrap{height:340px;}
            .chart-toolbar{padding:6px 8px;gap:3px;overflow-x:auto;-webkit-overflow-scrolling:touch;flex-wrap:nowrap;scrollbar-width:none;}
            .chart-toolbar::-webkit-scrollbar{display:none;}
            .chart-tb-btn{padding:4px 8px;font-size:11px;flex-shrink:0;}
            .chart-tb-label{font-size:10px;flex-shrink:0;}
            .chart-toolbar-divider{margin:0 3px;}
            .draw-toolbar{padding:5px 8px;gap:3px;overflow-x:auto;-webkit-overflow-scrolling:touch;flex-wrap:nowrap;scrollbar-width:none;}
            .draw-toolbar::-webkit-scrollbar{display:none;}

            /* ----- AI score & analysis ----- */
            .ai-score-container{flex-direction:column;align-items:flex-start;gap:14px;}
            .ai-score-circle{width:82px;height:82px;}
            .ai-score-number{font-size:24px;}
            .ai-recommendation{font-size:19px;}
            .ai-summary{font-size:13px;}
            .indicator-grid{grid-template-columns:repeat(2,1fr);}
            .indicator-item{padding:12px 10px;}
            .indicator-val{font-size:14px;}
            .ai-detail-item{padding:12px;}

            /* ----- Entry / Exit cards ----- */
            .entry-icon{font-size:38px;}
            .entry-title{font-size:20px;}
            .entry-subtitle{font-size:13px;}
            .entry-check-item{padding:9px 0;gap:8px;font-size:12px;}
            .entry-check-icon{width:20px;height:20px;font-size:10px;}
            .entry-strategy{padding:12px;}
            .entry-strategy-row{font-size:12px;}
            .entry-conditions-summary{gap:14px;}

            /* ----- Sub charts ----- */
            .sub-chart-container{height:120px;}
            .sub-chart-grid .card{margin:4px 10px;}

            /* ----- Trade style tabs ----- */
            .trade-style-tabs{margin:4px 10px 0;padding:5px 8px;gap:5px;}
            .trade-style-tab{font-size:13px;padding:11px 8px;gap:5px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
            .trade-style-tab svg{width:14px;height:14px;flex-shrink:0;}

            /* ----- Options ----- */
            .options-wrap{padding:12px 0 24px;}
            .options-toggle-row{padding:0 12px;flex-wrap:wrap;gap:6px;}
            .options-summary-row{padding:0 12px;grid-template-columns:repeat(2,1fr)!important;}
            .options-exp-bar{padding:0 12px 10px;overflow-x:auto;flex-wrap:nowrap;scrollbar-width:none;}
            .options-exp-bar::-webkit-scrollbar{display:none;}
            .opt-tbl th,.opt-tbl td{padding:5px 4px;font-size:11px;}
            .opt-strike{font-size:11px;}
            .opt-iv{font-size:10px;}
            .options-chain-grid{padding:0;overflow-x:hidden;}

            /* ----- Analysis refresh bar ----- */
            .analysis-refresh-bar{padding:5px 12px 2px;font-size:11px;gap:5px;}
            .analysis-refresh-btn{padding:2px 8px;font-size:10px;}

            /* ----- Company info ----- */
            .cp-info-grid{grid-template-columns:1fr;}
            .cp-insider-table th,.cp-insider-table td{font-size:11px;padding:7px 7px;}
        }


        /* ===== LIGHT MODE OVERRIDES ===== */
        [data-theme="light"] .side-nav{background:var(--bg2);border-right-color:var(--border);}
        [data-theme="light"] .side-nav-close{background:var(--bg3);color:var(--text2);}
        [data-theme="light"] .search-box{background:var(--bg3);}
        [data-theme="light"] .search-box input{color:var(--text);}
        [data-theme="light"] .market-toggle{background:var(--bg3);}
        [data-theme="light"] .toast{background:var(--bg2);border-color:var(--red);color:var(--red);box-shadow:0 12px 40px rgba(0,0,0,.12);}
        [data-theme="light"] .card{background:var(--bg2);box-shadow:0 1px 3px rgba(0,0,0,.05);}
        [data-theme="light"] .chart-toolbar{background:var(--bg2);}
        [data-theme="light"] .draw-toolbar{background:var(--bg2);}
        [data-theme="light"] .top100-row{background:var(--bg2);}
        [data-theme="light"] .top100-row:hover{background:var(--bg3);}
        [data-theme="light"] .session-badge{background:var(--bg3);}
        [data-theme="light"] .hamburger-btn{background:var(--bg3);color:var(--text2);}
        [data-theme="light"] ::-webkit-scrollbar-thumb{background:rgba(0,0,0,.12);}
        [data-theme="light"] .side-nav-backdrop{background:rgba(0,0,0,.25);}

        /* Side nav theme toggle */
        .side-nav-footer{padding:16px;border-top:1px solid var(--border);}
        /* PWA 설치 버튼 */
        .pwa-install-btn{display:none;align-items:center;gap:12px;width:100%;padding:12px 14px;border:1.5px solid var(--blue);background:rgba(59,130,246,.08);color:var(--blue);border-radius:var(--r3);cursor:pointer;font-size:14px;font-weight:700;font-family:inherit;transition:all .18s;margin-bottom:10px;}
        .pwa-install-btn:hover{background:rgba(59,130,246,.16);}
        .pwa-install-btn.visible{display:flex;}
        .pwa-install-icon{font-size:18px;flex-shrink:0;}
        .theme-toggle-btn{display:flex;align-items:center;gap:12px;width:100%;padding:12px 14px;border:none;background:var(--bg3);color:var(--text2);border-radius:var(--r3);cursor:pointer;font-size:14px;font-weight:600;font-family:inherit;transition:all .15s;}
        .theme-toggle-btn:hover{background:var(--bg4);color:var(--text);}
        .theme-toggle-btn .theme-icon{width:20px;text-align:center;font-size:16px;flex-shrink:0;}
        .theme-toggle-btn .theme-switch{margin-left:auto;width:40px;height:22px;border-radius:11px;position:relative;transition:background .2s;flex-shrink:0;}
        .theme-toggle-btn .theme-switch.dark{background:var(--bg4);}
        .theme-toggle-btn .theme-switch.light{background:var(--blue);}
        .theme-toggle-btn .theme-switch::after{content:'';position:absolute;top:3px;width:16px;height:16px;border-radius:50%;background:#fff;transition:left .2s;box-shadow:0 1px 3px rgba(0,0,0,.2);}
        .theme-toggle-btn .theme-switch.dark::after{left:3px;}
        .theme-toggle-btn .theme-switch.light::after{left:21px;}

        /* icon dot for card titles */
        .card-title .icon{width:8px;height:8px;border-radius:50%;display:inline-block;}

        /* period-selector (compat) */
        .period-selector{display:flex;gap:6px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;padding:2px 0;}
        .period-selector::-webkit-scrollbar{display:none;}

        /* ===== TRADE STYLE TABS (단타/스윙) ===== */
        .trade-style-tabs{display:flex;gap:6px;padding:8px 16px;background:var(--bg2);border-radius:var(--r);margin:4px 16px 0;position:sticky;top:0;z-index:10;}
        .trade-style-tab{flex:1;display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border:2px solid var(--border);background:transparent;color:var(--text3);border-radius:var(--r3);cursor:pointer;font-size:14px;font-weight:700;font-family:inherit;transition:all .2s;}
        .trade-style-tab:hover{border-color:var(--text3);color:var(--text2);}
        .trade-style-tab.active[data-tstyle="day"]{background:linear-gradient(135deg,rgba(249,115,22,.12),rgba(249,115,22,.04));border-color:#f97316;color:#f97316;}
        .trade-style-tab.active[data-tstyle="swing"]{background:linear-gradient(135deg,rgba(139,92,246,.12),rgba(139,92,246,.04));border-color:#8b5cf6;color:#8b5cf6;}
        .trade-style-tab svg{flex-shrink:0;}
        .trade-style-panel{display:none;}
        .trade-style-panel.active{display:block;}
        .trade-badge{display:inline-block;padding:2px 8px;border-radius:4px;font-size:10px;font-weight:800;letter-spacing:.5px;margin-left:6px;vertical-align:middle;}
        .day-badge{background:rgba(249,115,22,.15);color:#f97316;}
        .swing-badge{background:rgba(139,92,246,.15);color:#8b5cf6;}
        @media(min-width:900px){
            .trade-style-tabs{margin:4px 24px 0;padding:8px 20px;}
            .trade-style-panel.active{display:block;}
        }
        @media(max-width:640px){
            .trade-style-tabs{margin:4px 12px 0;padding:6px 10px;}
            .trade-style-tab{font-size:12px;padding:10px 8px;gap:5px;}
            .trade-style-tab svg{width:14px;height:14px;}
        }
        [data-theme="light"] .trade-style-tabs{background:var(--bg2);}
        [data-theme="light"] .trade-style-tab{border-color:var(--border);}
        /* ===== OPTIONS CHAIN (옵션현황) ===== */
        .options-wrap{padding:20px 24px 32px;}
        .options-exp-bar{display:flex;gap:8px;flex-wrap:nowrap;overflow-x:auto;padding-bottom:6px;margin-bottom:20px;scrollbar-width:none;}
        .options-exp-bar::-webkit-scrollbar{display:none;}
        .options-exp-btn{padding:6px 16px;border:1.5px solid var(--border);background:var(--bg3);color:var(--text2);border-radius:20px;cursor:pointer;font-size:13px;font-weight:700;font-family:inherit;white-space:nowrap;transition:all .15s;flex-shrink:0;}
        .options-exp-btn.active{border-color:var(--blue);color:var(--blue);background:rgba(59,130,246,.1);}
        .options-exp-btn:hover:not(.active){border-color:var(--text3);color:var(--text);}
        .options-summary-row{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-bottom:20px;}
        @media(max-width:600px){.options-summary-row{grid-template-columns:repeat(2,1fr);}}
        .options-stat{background:var(--bg2);border:1px solid var(--border);border-radius:var(--r2);padding:12px 14px;}
        .options-stat-label{font-size:11px;color:var(--text3);font-weight:600;letter-spacing:.3px;margin-bottom:4px;}
        .options-stat-val{font-size:17px;font-weight:800;font-variant-numeric:tabular-nums;}
        .options-pcr-bar{height:5px;border-radius:3px;background:var(--bg4);margin-top:8px;overflow:hidden;}
        .options-pcr-fill-c{height:100%;float:left;background:var(--green);border-radius:3px 0 0 3px;}
        .options-pcr-fill-p{height:100%;float:right;background:var(--red);border-radius:0 3px 3px 0;}
        .options-chain-grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;}
        @media(max-width:700px){.options-chain-grid{grid-template-columns:1fr;}}
        .options-card{background:var(--bg2);border:1px solid var(--border);border-radius:var(--r);overflow:hidden;}
        .options-card-hd{display:flex;align-items:center;justify-content:space-between;padding:13px 16px;border-bottom:1px solid var(--border);}
        .options-card-title{font-size:15px;font-weight:800;}
        .options-card-title.call{color:var(--green);}
        .options-card-title.put{color:var(--red);}
        .options-card-sub{font-size:11px;color:var(--text3);font-weight:600;}
        .opt-tbl{width:100%;border-collapse:collapse;font-size:12px;}
        .opt-tbl th{font-size:10px;font-weight:700;color:var(--text3);padding:8px 8px;text-align:right;background:var(--bg3);border-bottom:1px solid var(--border);white-space:nowrap;letter-spacing:.3px;}
        .opt-tbl th:first-child{text-align:left;padding-left:12px;}
        .opt-tbl td{padding:7px 8px;text-align:right;border-bottom:1px solid rgba(255,255,255,.03);font-variant-numeric:tabular-nums;font-weight:600;color:var(--text2);}
        .opt-tbl td:first-child{text-align:left;padding-left:12px;}
        .opt-tbl tr:last-child td{border-bottom:none;}
        .opt-tbl tr.itm-call td{background:rgba(34,197,94,.05);}
        .opt-tbl tr.itm-call .opt-strike{color:var(--green);}
        .opt-tbl tr.itm-put td{background:rgba(239,68,68,.05);}
        .opt-tbl tr.itm-put .opt-strike{color:var(--red);}
        .opt-tbl tr:hover td{background:var(--bg4)!important;}
        .opt-strike{font-size:13px;font-weight:800;color:var(--text);}
        .opt-iv{color:var(--purple);font-size:11px;}
        .opt-vol{color:var(--cyan);}
        .opt-up{color:var(--green);}
        .opt-down{color:var(--red);}
        .opt-itm-badge{display:inline-block;font-size:9px;font-weight:800;padding:1px 5px;border-radius:4px;margin-left:4px;vertical-align:middle;}
        .opt-itm-badge.call{background:rgba(34,197,94,.15);color:var(--green);}
        .opt-itm-badge.put{background:rgba(239,68,68,.15);color:var(--red);}
        .options-empty{text-align:center;padding:48px 20px;color:var(--text3);font-size:14px;line-height:1.8;}
        .options-loading{display:flex;flex-direction:column;align-items:center;gap:12px;padding:48px 20px;color:var(--text3);font-size:14px;}
        .options-itm-only-label{font-size:12px;color:var(--text3);font-weight:600;display:flex;align-items:center;gap:6px;}
        .options-toggle-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;gap:8px;flex-wrap:wrap;}
        .options-filter-btns{display:flex;gap:6px;flex-wrap:wrap;}
        .options-filter-btn{padding:5px 12px;border:1px solid var(--border);background:transparent;color:var(--text3);border-radius:8px;cursor:pointer;font-size:12px;font-weight:600;font-family:inherit;transition:all .15s;}
        .options-filter-btn.active{background:var(--bg3);color:var(--text);border-color:var(--text3);}
        /* ===== OPTIONS ANALYSIS CARD ===== */
        .options-analysis{background:var(--bg2);border:1px solid var(--border);border-radius:var(--r);padding:20px;margin-bottom:20px;}
        .options-anal-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;}
        .options-anal-title{font-size:15px;font-weight:800;}
        .options-anal-verdict{padding:5px 14px;border-radius:20px;font-size:13px;font-weight:800;}
        .options-anal-verdict.bull{background:rgba(34,197,94,.15);color:var(--green);}
        .options-anal-verdict.strong-bull{background:rgba(34,197,94,.2);color:var(--green);border:1px solid rgba(34,197,94,.3);}
        .options-anal-verdict.bear{background:rgba(239,68,68,.15);color:var(--red);}
        .options-anal-verdict.strong-bear{background:rgba(239,68,68,.2);color:var(--red);border:1px solid rgba(239,68,68,.3);}
        .options-anal-verdict.neutral{background:var(--bg3);color:var(--text2);}
        .options-anal-section-title{font-size:11px;font-weight:700;color:var(--text3);text-transform:uppercase;letter-spacing:.5px;margin-bottom:10px;}
        .options-anal-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:14px;}
        @media(max-width:600px){.options-anal-grid{grid-template-columns:1fr 1fr;}}
        .options-anal-item{background:var(--bg3);border-radius:var(--r3);padding:12px 14px;}
        .options-anal-item-label{font-size:11px;color:var(--text3);font-weight:600;margin-bottom:4px;}
        .options-anal-item-val{font-size:16px;font-weight:800;font-variant-numeric:tabular-nums;}
        .options-anal-item-sub{font-size:10px;color:var(--text3);margin-top:3px;line-height:1.4;}
        .options-anal-divider{height:1px;background:var(--border);margin:14px 0;}
        .options-signals{display:flex;flex-direction:column;gap:8px;}
        .options-signal-row{display:flex;align-items:flex-start;gap:10px;padding:10px 12px;background:var(--bg3);border-radius:var(--r3);}
        .options-signal-icon{font-size:13px;flex-shrink:0;margin-top:1px;}
        .options-signal-text{flex:1;font-size:13px;color:var(--text2);font-weight:600;line-height:1.5;}
        .options-signal-text strong{color:var(--text);font-weight:700;}
        .options-filter-label{font-size:12px;color:var(--text3);font-weight:600;white-space:nowrap;}
        /* 자동 분석 갱신 바 */
        .analysis-refresh-bar{display:flex;align-items:center;gap:7px;padding:7px 16px 4px;font-size:12px;color:var(--text3);flex-wrap:wrap;}
        .analysis-refresh-dot{width:7px;height:7px;border-radius:50%;background:var(--green);flex-shrink:0;animation:pulseGreen 2.4s ease-in-out infinite;}
        @keyframes pulseGreen{0%,100%{opacity:1;transform:scale(1);}50%{opacity:.4;transform:scale(.75);}}
        .analysis-refresh-time{font-weight:700;color:var(--text2);}
        .analysis-refresh-btn{margin-left:auto;padding:3px 10px;border:1px solid var(--border);background:transparent;color:var(--text3);border-radius:6px;cursor:pointer;font-size:11px;font-weight:600;font-family:inherit;transition:all .15s;}
        .analysis-refresh-btn:hover{background:var(--bg3);color:var(--text);border-color:var(--text3);}
        .analysis-refresh-btn.spinning{pointer-events:none;opacity:.6;}
        .opt-th-sort{cursor:pointer;user-select:none;}
        .opt-th-sort:hover{color:var(--text)!important;}
        .opt-sort-icon{font-size:10px;opacity:.35;margin-left:2px;}
        .opt-sort-icon.active{opacity:1;color:var(--yellow);}

        /* ===== SEARCH DROPDOWN ===== */
        .search-wrap{position:relative;}
        .search-dropdown{
            display:none;position:absolute;top:calc(100% + 6px);left:0;right:0;
            background:var(--bg2);border:1px solid var(--border);border-radius:var(--r2);
            box-shadow:0 8px 32px rgba(0,0,0,.28);z-index:150;overflow:hidden;
            max-height:420px;overflow-y:auto;scrollbar-width:thin;
        }
        .search-dropdown.open{display:block;}
        .sdrop-section-title{font-size:10px;font-weight:800;color:var(--text3);
            text-transform:uppercase;letter-spacing:.8px;padding:10px 14px 5px;
            display:flex;align-items:center;gap:6px;}
        .sdrop-item{display:flex;align-items:center;gap:10px;padding:9px 14px;
            cursor:pointer;transition:background .1s;user-select:none;
            border-top:1px solid var(--border);}
        .sdrop-item:first-of-type{border-top:none;}
        .sdrop-item:hover,.sdrop-item.highlighted{background:var(--bg3);}
        .sdrop-flag{font-size:16px;flex-shrink:0;width:22px;text-align:center;line-height:1;}
        .sdrop-info{flex:1;min-width:0;}
        .sdrop-name{font-size:13px;font-weight:700;
            overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--text);}
        .sdrop-ticker{font-size:11px;font-weight:500;color:var(--text3);margin-top:1px;}
        .sdrop-badge{font-size:10px;font-weight:800;padding:2px 6px;border-radius:4px;flex-shrink:0;}
        .sdrop-badge.stock{background:rgba(59,130,246,.12);color:var(--blue);}
        .sdrop-badge.etf{background:rgba(234,179,8,.12);color:var(--yellow);}
        .sdrop-badge.kr{background:rgba(59,130,246,.12);color:var(--blue);}
        .sdrop-badge.us{background:rgba(167,139,250,.12);color:var(--purple);}
        .sdrop-price{font-size:12px;font-weight:700;color:var(--text2);
            font-variant-numeric:tabular-nums;white-space:nowrap;flex-shrink:0;}
        .sdrop-change{font-size:11px;font-weight:700;
            font-variant-numeric:tabular-nums;white-space:nowrap;flex-shrink:0;}
        .sdrop-change.up{color:var(--green);}
        .sdrop-change.down{color:var(--red);}
        .sdrop-change.flat{color:var(--text3);}
        .sdrop-skel{padding:9px 14px;display:flex;align-items:center;gap:10px;}
        .sdrop-skel-circle{width:22px;height:22px;border-radius:50%;
            background:linear-gradient(90deg,var(--bg3) 25%,var(--bg4) 50%,var(--bg3) 75%);
            background-size:600px 100%;animation:shimmer 1.2s infinite linear;flex-shrink:0;}
        .sdrop-skel-line{height:13px;border-radius:5px;
            background:linear-gradient(90deg,var(--bg3) 25%,var(--bg4) 50%,var(--bg3) 75%);
            background-size:600px 100%;animation:shimmer 1.2s infinite linear;}
        [data-theme="light"] .search-dropdown{box-shadow:0 8px 32px rgba(0,0,0,.10);}
        @media(max-width:640px){
            .search-wrap{overflow:visible;}
            .search-dropdown{max-height:340px;}
            .sdrop-name{font-size:12px;}
        }

        /* ===== ENTRY / EXIT ROW (나란히) ===== */
        .entry-exit-row{display:flex;align-items:start;gap:8px;}
        .entry-exit-row>.card{flex:1;min-width:0;margin:4px 0;}
        @media(max-width:640px){
            .entry-exit-row{flex-direction:column;padding:0 10px;}
            .entry-exit-row>.card{width:100%;}
        }
        @media(min-width:900px){
            .entry-exit-row{gap:8px;}
            .entry-exit-row>.card{margin:4px 0;}
            .entry-exit-row>.card:first-child{margin-left:0;}
            .entry-exit-row>.card:last-child{margin-right:0;}
        }

        /* ===== SPLIT CALC ===== */
        .sc-input-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;}
        .sc-input-group{display:flex;flex-direction:column;gap:5px;}
        .sc-input-group label{font-size:11px;color:var(--text3);font-weight:700;text-transform:uppercase;letter-spacing:.3px;}
        .sc-input-group input,.sc-input-group select{background:var(--bg3);border:1px solid var(--border);border-radius:var(--r2);padding:8px 12px;font-size:13px;color:var(--text1);outline:none;font-family:inherit;width:100%;box-sizing:border-box;}
        .sc-input-group input:focus,.sc-input-group select:focus{border-color:var(--cyan);}
        .sc-tbl{width:100%;border-collapse:collapse;font-size:13px;}
        .sc-tbl th{padding:7px 10px;text-align:right;font-weight:600;font-size:11px;color:var(--text3);border-bottom:1px solid var(--border);white-space:nowrap;}
        .sc-tbl th:first-child{text-align:left;}
        .sc-tbl td{padding:9px 10px;text-align:right;border-bottom:1px solid rgba(255,255,255,.04);white-space:nowrap;}
        .sc-tbl td:first-child{text-align:left;}
        .sc-tbl tr:last-child td{border-bottom:none;}
        .sc-tbl tbody tr:hover td{background:rgba(255,255,255,.02);}
        .sc-summary{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding-top:12px;border-top:1px solid var(--border);margin-top:8px;}
        .sc-sum-item{background:var(--bg3);border-radius:var(--r2);padding:10px 12px;}
        .sc-sum-label{font-size:11px;color:var(--text3);margin-bottom:3px;}
        .sc-sum-val{font-size:14px;font-weight:700;}

        /* ===== R/R ANALYSIS CARD ===== */
        .rr-basis-badge{font-size:11px;font-weight:700;padding:3px 8px;border-radius:6px;
            background:rgba(34,211,238,.12);color:var(--cyan);margin-left:auto;}
        .rr-action-row{display:flex;align-items:flex-start;gap:12px;margin-bottom:16px;
            padding:14px;background:var(--bg3);border-radius:var(--r3);}
        .rr-action-badge{font-size:14px;font-weight:800;padding:6px 14px;border-radius:20px;white-space:nowrap;flex-shrink:0;}
        .rr-action-buy    {background:rgba(34,197,94,.15); color:var(--green); border:1px solid rgba(34,197,94,.3);}
        .rr-action-partial{background:rgba(234,179,8,.12); color:var(--yellow);border:1px solid rgba(234,179,8,.3);}
        .rr-action-wait   {background:rgba(148,163,184,.1);color:var(--text2); border:1px solid var(--border);}
        .rr-action-block  {background:rgba(239,68,68,.15); color:var(--red);   border:1px solid rgba(239,68,68,.4);}
        .rr-action-desc{font-size:13px;color:var(--text2);line-height:1.6;}
        .rr-table{display:flex;flex-direction:column;border:1px solid var(--border);
            border-radius:var(--r3);overflow:hidden;margin-bottom:12px;}
        .rr-row{display:flex;justify-content:space-between;align-items:center;
            padding:10px 14px;font-size:13px;border-bottom:1px solid var(--border);}
        .rr-row:last-child{border-bottom:none;}
        .rr-row-rr{background:var(--bg3);}
        .rr-label{color:var(--text3);font-weight:500;}
        .rr-value{font-weight:700;display:flex;align-items:center;gap:6px;}
        .rr-pct{font-size:12px;font-weight:700;opacity:.8;}
        .rr-ratio-value{font-size:16px;font-weight:800;letter-spacing:-.3px;}
        .rr-legend{display:flex;align-items:center;gap:6px;font-size:11px;color:var(--text3);flex-wrap:wrap;}
        .rr-legend-dot{width:8px;height:8px;border-radius:50%;display:inline-block;flex-shrink:0;margin-left:8px;}
        .rr-legend-dot:first-child{margin-left:0;}
        .rr-knife-warning{display:flex;align-items:flex-start;gap:12px;
            background:rgba(239,68,68,.08);border:1px solid rgba(239,68,68,.3);
            border-radius:var(--r3);padding:14px;margin-bottom:14px;}
        .rr-knife-icon{font-size:22px;flex-shrink:0;line-height:1.3;}
        .rr-knife-title{font-size:13px;font-weight:800;color:var(--red);margin-bottom:4px;}
        .rr-knife-desc{font-size:12px;color:var(--text2);line-height:1.6;}
    </style>
</head>
<body>
<!-- Side Navigation -->
<nav class="side-nav" id="sideNav">
    <div class="side-nav-header">
        <div class="side-nav-title">StockAI</div>
        <button class="side-nav-close" onclick="closeSideNav()">&times;</button>
    </div>
    <div class="side-nav-body">
        <div class="side-nav-section">
            <div class="side-nav-menu">
                <button class="side-nav-item active" onclick="goHome();closeSideNav();">
                    <span class="side-nav-item-icon">&#127968;</span>
                    <span class="side-nav-item-text">홈</span>
                </button>
            </div>
        </div>
        <div class="side-nav-divider"></div>
        <div class="side-nav-section">
            <div class="side-nav-section-title">&#11088; 즐겨찾기 종목</div>
            <div id="favList" class="side-nav-menu">
                <div class="fav-empty">즐겨찾기한 종목이 없습니다.<br>종목 분석 후 &#9734; 버튼으로 추가하세요.</div>
            </div>
        </div>
    </div>
    <div class="side-nav-footer">
        <button class="pwa-install-btn" id="pwaInstallBtn" onclick="pwaInstall()">
            <span class="pwa-install-icon">&#8681;</span>
            <span>앱 설치하기</span>
        </button>
        <button class="theme-toggle-btn" id="themeToggleBtn" onclick="toggleTheme()">
            <span class="theme-icon" id="themeIcon">&#9790;</span>
            <span id="themeLabel">다크 모드</span>
            <span class="theme-switch dark" id="themeSwitch"></span>
        </button>
    </div>
</nav>
<div class="side-nav-backdrop" id="sideNavBackdrop" onclick="closeSideNav()"></div>

<div class="app-wrapper">
<div class="app">
    <!-- Header -->
    <header class="header">
        <div class="header-top">
            <div class="logo" onclick="goHome()" style="cursor:pointer;">Stock<span>AI</span></div>
            <div class="search-wrap" id="searchWrap">
                <div class="search-box">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>
                    <input type="text" id="searchInput"
                           placeholder="종목 입력 (예: 삼성전자, AAPL, 005930)"
                           autocomplete="off"
                           onkeydown="handleSearchKeydown(event)">
                </div>
                <button class="search-btn" onclick="searchStock()">분석</button>
                <div class="search-dropdown" id="searchDropdown" role="listbox"></div>
            </div>
            <button class="hamburger-btn" id="themeHeaderBtn" onclick="toggleTheme()" title="테마 변경">&#9790;</button>
            <button class="hamburger-btn" onclick="toggleSideNav()" title="메뉴">&#9776;</button>
        </div>
    </header>

    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <div class="welcome-top">
            <h2>주식 종목 분석을 시작하세요</h2>
            <p>종목코드 또는 티커를 입력하고 AI 기반 종합 분석을 확인하세요</p>
            <div class="example-chips">
                <div class="example-chip" onclick="quickSearch('005930','KR')">삼성전자</div>
                <div class="example-chip" onclick="quickSearch('000660','KR')">SK하이닉스</div>
                <div class="example-chip" onclick="quickSearch('AAPL','US')">Apple</div>
                <div class="example-chip" onclick="quickSearch('TSLA','US')">Tesla</div>
                <div class="example-chip" onclick="quickSearch('NVDA','US')">NVIDIA</div>
                <div class="example-chip" onclick="quickSearch('035420','KR')">NAVER</div>
            </div>
        </div>

        <!-- 미국주식 인기 TOP 100 -->
        <div class="top100-section">
            <div class="top100-header">
                <div class="top100-title">미국주식 당일 인기 TOP 100 <span class="badge">LIVE</span></div>
                <div class="top100-updated" id="top100Updated"></div>
            </div>
            <div class="top100-filters">
                <button class="top100-filter active" data-filter="most_actives" onclick="setTop100Filter('most_actives')">거래량 TOP</button>
                <button class="top100-filter" data-filter="day_gainers" onclick="setTop100Filter('day_gainers')">상승률 TOP</button>
                <button class="top100-filter" data-filter="day_losers" onclick="setTop100Filter('day_losers')">하락률 TOP</button>
            </div>
            <div class="top100-grid" id="top100Grid">
                <div class="top100-loading">데이터를 불러오는 중...</div>
            </div>
        </div>
    </div>

    <!-- Stock Hero (대형 가격 표시) -->
    <div class="stock-hero" id="stockHero">
        <div style="display:flex;align-items:center;gap:0;">
            <div class="stock-name" id="stockName">-</div>
            <button class="fav-star-btn" id="favStarBtn" onclick="toggleFavorite()"><span class="star">&#9734;</span><span id="favStarText">즐겨찾기</span></button>
        </div>
        <div class="stock-code" id="stockCode">-</div>
        <div class="stock-price" id="stockPrice">-</div>
        <div class="stock-change" id="stockChange">-</div>
        <div class="market-session-info" id="marketSessionInfo"></div>
    </div>

    <!-- Tab Navigation -->
    <nav class="tab-nav" id="tabNav">
        <button class="tab-item active" data-tab="chart" onclick="switchTab('chart')">차트</button>
        <button class="tab-item" data-tab="analysis" onclick="switchTab('analysis')">분석</button>
        <button class="tab-item" data-tab="info" onclick="switchTab('info')">종목정보</button>
        <button class="tab-item" data-tab="company" onclick="switchTab('company')">기업</button>
        <button class="tab-item" data-tab="options" onclick="switchTab('options')">옵션</button>
    </nav>

    <!-- Main Content -->
    <div class="main-content" id="mainContent">
        <!-- Tab 1: 차트 (풀 너비) -->
        <div class="tab-content" id="tabChart" data-tab="chart">
            <div class="chart-full-col">
                <!-- Lightweight Charts -->
                <div class="card tv-chart-card" style="padding:0;overflow:hidden;" id="tvChartCard">
                    <div class="chart-toolbar" id="chartToolbar">
                        <span class="chart-tb-label">봉</span>
                        <div class="chart-toolbar-group">
                            <button class="chart-tb-btn interval-btn" data-interval="1m" onclick="setChartInterval('1m')">1분</button>
                            <button class="chart-tb-btn interval-btn" data-interval="5m" onclick="setChartInterval('5m')">5분</button>
                            <button class="chart-tb-btn interval-btn" data-interval="15m" onclick="setChartInterval('15m')">15분</button>
                            <button class="chart-tb-btn interval-btn" data-interval="1h" onclick="setChartInterval('1h')">1시간</button>
                            <button class="chart-tb-btn interval-btn active" data-interval="1d" onclick="setChartInterval('1d')">일봉</button>
                            <button class="chart-tb-btn interval-btn" data-interval="1wk" onclick="setChartInterval('1wk')">주봉</button>
                        </div>
                        <div class="chart-toolbar-divider"></div>
                        <span class="chart-tb-label">기간</span>
                        <div class="chart-toolbar-group">
                            <button class="chart-tb-btn range-btn" data-range="1d" onclick="setPeriod('1d')" style="display:none">1일</button>
                            <button class="chart-tb-btn range-btn" data-range="5d" onclick="setPeriod('5d')" style="display:none">5일</button>
                            <button class="chart-tb-btn range-btn" data-range="1mo" onclick="setPeriod('1mo')">1개월</button>
                            <button class="chart-tb-btn range-btn" data-range="3mo" onclick="setPeriod('3mo')">3개월</button>
                            <button class="chart-tb-btn range-btn active" data-range="6mo" onclick="setPeriod('6mo')">6개월</button>
                            <button class="chart-tb-btn range-btn" data-range="1y" onclick="setPeriod('1y')">1년</button>
                            <button class="chart-tb-btn range-btn" data-range="5y" onclick="setPeriod('5y')">5년</button>
                        </div>
                        <div style="margin-left:auto;">
                            <button class="tv-fullscreen-btn" id="tvFullscreenBtn" onclick="toggleChartFullscreen()" title="전체화면" style="position:static;border:none;background:transparent;">
                                <svg id="tvFsIconExpand" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg>
                                <svg id="tvFsIconShrink" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="display:none"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/></svg>
                            </button>
                        </div>
                    </div>
                    <div class="draw-toolbar" id="drawToolbar">
                        <span class="draw-tb-label">그리기</span>
                        <!-- 도구 선택 -->
                        <button class="draw-tb-btn" id="drawBtnNone" onclick="setDrawTool('none')" title="선택 (그리기 끄기)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg>
                        </button>
                        <button class="draw-tb-btn" id="drawBtnLine" onclick="setDrawTool('line')" title="추세선">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><line x1="4" y1="20" x2="20" y2="4"/></svg>
                        </button>
                        <button class="draw-tb-btn" id="drawBtnHLine" onclick="setDrawTool('hline')" title="수평선">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><line x1="2" y1="12" x2="22" y2="12"/></svg>
                        </button>
                        <button class="draw-tb-btn" id="drawBtnRay" onclick="setDrawTool('ray')" title="반직선 (레이)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><line x1="4" y1="18" x2="20" y2="6"/><circle cx="4" cy="18" r="2" fill="currentColor"/></svg>
                        </button>
                        <button class="draw-tb-btn" id="drawBtnRect" onclick="setDrawTool('rect')" title="사각형 영역">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><rect x="3" y="5" width="18" height="14" rx="1"/></svg>
                        </button>
                        <button class="draw-tb-btn" id="drawBtnFib" onclick="setDrawTool('fib')" title="피보나치 되돌림">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"><line x1="2" y1="4" x2="22" y2="4" stroke-dasharray="2 2"/><line x1="2" y1="9" x2="22" y2="9"/><line x1="2" y1="14" x2="22" y2="14" stroke-dasharray="4 2"/><line x1="2" y1="20" x2="22" y2="20"/><text x="1" y="3" fill="currentColor" font-size="5" font-weight="700">F</text></svg>
                        </button>
                        <div class="draw-tb-divider"></div>
                        <!-- 색상 -->
                        <span class="draw-tb-label">색상</span>
                        <button class="draw-color-btn active" style="background:#ef4444;color:#ef4444" onclick="setDrawColor('#ef4444')" title="빨강"></button>
                        <button class="draw-color-btn" style="background:#3b82f6;color:#3b82f6" onclick="setDrawColor('#3b82f6')" title="파랑"></button>
                        <button class="draw-color-btn" style="background:#22c55e;color:#22c55e" onclick="setDrawColor('#22c55e')" title="초록"></button>
                        <button class="draw-color-btn" style="background:#eab308;color:#eab308" onclick="setDrawColor('#eab308')" title="노랑"></button>
                        <button class="draw-color-btn" style="background:#a78bfa;color:#a78bfa" onclick="setDrawColor('#a78bfa')" title="보라"></button>
                        <button class="draw-color-btn" style="background:#ffffff;color:#ffffff" onclick="setDrawColor('#ffffff')" title="흰색"></button>
                        <div class="draw-tb-divider"></div>
                        <!-- 두께 -->
                        <button class="draw-width-btn active" data-w="1" onclick="setDrawWidth(1)">1</button>
                        <button class="draw-width-btn" data-w="2" onclick="setDrawWidth(2)">2</button>
                        <button class="draw-width-btn" data-w="3" onclick="setDrawWidth(3)">3</button>
                        <div class="draw-tb-divider"></div>
                        <!-- 되돌리기/전체삭제 -->
                        <button class="draw-tb-btn" onclick="undoDraw()" title="되돌리기 (Ctrl+Z)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
                        </button>
                        <button class="draw-tb-btn" onclick="clearAllDrawings()" title="전체 삭제">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14H6L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4h6v2"/></svg>
                        </button>
                        <span class="draw-count-badge" id="drawCountBadge">0</span>
                    </div>
                    <div class="tv-chart-wrap" id="tvChartWrap">
                        <canvas class="draw-canvas" id="drawCanvas"></canvas>
                    </div>
                </div>

                <!-- AI 보조지표 -->
                <div class="card ai-ind" id="aiIndCard">
                    <div class="ai-ind-key-row" id="aiIndKeyRow">
                        <input type="password" class="ai-ind-key-input" id="aiIndKeyInput" placeholder="Gemini API Key 입력 (aistudio.google.com에서 무료 발급)" />
                        <button class="ai-ind-key-btn" onclick="saveAiKey()">저장</button>
                    </div>
                    <div class="card-title" style="margin-bottom:0;"><span class="dot" style="background:var(--purple)"></span>AI 보조지표</div>
                    <div class="ai-ind-tabs">
                        <button class="ai-ind-tab active" data-aitab="generate" onclick="switchAiTab('generate')">생성</button>
                        <button class="ai-ind-tab" data-aitab="lines" onclick="switchAiTab('lines')">보조선 <span class="ai-ind-tab-badge" id="aiLineBadge">0</span></button>
                    </div>

                    <!-- 생성 탭 -->
                    <div class="ai-ind-panel active" id="aiPanelGenerate" data-aitab="generate">
                        <div class="ai-ind-header">
                            <div class="ai-ind-prompt-row">
                                <input type="text" class="ai-ind-input" id="aiIndInput" placeholder="원하는 보조지표를 입력하세요 (예: 빗각, 엔벨로프, 일목균형표...)" onkeydown="if(event.key==='Enter')runAiIndicator()">
                                <button class="ai-ind-send" id="aiIndSendBtn" onclick="runAiIndicator()">생성</button>
                            </div>
                        </div>
                        <div class="ai-ind-examples">
                            <button class="ai-ind-example" onclick="setAiPrompt('빗각 (기울기 추세선)')">빗각</button>
                            <button class="ai-ind-example" onclick="setAiPrompt('엔벨로프 20일 5%')">엔벨로프</button>
                            <button class="ai-ind-example" onclick="setAiPrompt('일목균형표')">일목균형표</button>
                            <button class="ai-ind-example" onclick="setAiPrompt('피봇 포인트 (Pivot Point)')">피봇 포인트</button>
                            <button class="ai-ind-example" onclick="setAiPrompt('파라볼릭 SAR')">파라볼릭 SAR</button>
                            <button class="ai-ind-example" onclick="setAiPrompt('VWAP 밴드 ±1σ, ±2σ')">VWAP 밴드</button>
                        </div>
                        <div class="ai-ind-status" id="aiIndStatus" style="display:none"></div>
                        <div class="ai-ind-chart" id="aiIndChartWrap" style="display:none"><canvas id="aiIndChart"></canvas></div>
                    </div>

                    <!-- 보조선 관리 탭 -->
                    <div class="ai-ind-panel" id="aiPanelLines" data-aitab="lines">
                        <div class="ai-line-list" id="aiLineList">
                            <div class="ai-line-empty">생성된 보조선이 없습니다.<br>생성 탭에서 보조지표를 추가하세요.</div>
                        </div>
                        <button class="ai-line-clear-btn" id="aiLineClearAll" onclick="clearAllAiLines()" style="display:none">모든 보조선 삭제</button>
                    </div>
                </div>

                <!-- 보조 지표 2열 그리드 -->
                <div class="sub-chart-grid">
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--purple)"></span>RSI (14)</div>
                        <div class="sub-chart-container"><canvas id="rsiChart"></canvas></div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--cyan)"></span>MACD (12, 26, 9)</div>
                        <div class="sub-chart-container"><canvas id="macdChart"></canvas></div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--yellow)"></span>Stochastic (14, 3)</div>
                        <div class="sub-chart-container"><canvas id="stochChart"></canvas></div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--green)"></span>ADX (14) / DI</div>
                        <div class="sub-chart-container"><canvas id="adxChart"></canvas></div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--red)"></span>CCI (20)</div>
                        <div class="sub-chart-container"><canvas id="cciChart"></canvas></div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:#e879f9"></span>OBV (On Balance Volume)</div>
                        <div class="sub-chart-container"><canvas id="obvChart"></canvas></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 2: 분석 -->
        <div class="tab-content" id="tabAnalysis" data-tab="analysis">
            <!-- 단타/스윙 전환 탭 -->
            <div class="trade-style-tabs">
                <button class="trade-style-tab active" data-tstyle="day" onclick="switchTradeStyle('day')">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
                    단타 (Day Trading)
                </button>
                <button class="trade-style-tab" data-tstyle="swing" onclick="switchTradeStyle('swing')">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12c2-4 6-8 10-4s8 0 10-4"/><path d="M2 20c2-4 6-8 10-4s8 0 10-4"/></svg>
                    스윙 (Swing Trading)
                </button>
            </div>

            <!-- 자동 분석 갱신 바 -->
            <div class="analysis-refresh-bar" id="analysisRefreshBar" style="display:none;">
                <span class="analysis-refresh-dot"></span>
                <span>5분마다 자동 갱신</span>
                <span>·</span>
                <span class="analysis-refresh-time" id="analysisRefreshTime">-</span>
                <button class="analysis-refresh-btn" id="analysisRefreshBtn" onclick="manualAnalysisRefresh()">↻ 지금 갱신</button>
            </div>

            <!-- R/R Analysis Card: 단타/스윙 공통, 항상 노출 -->
            <div id="rrAnalysis"></div>

            <!-- ===== 단타 분석 ===== -->
            <div class="trade-style-panel active" id="tsPanelDay" data-tstyle="day">
                <div class="tab-col-left">
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:#f97316"></span>단타 종합 분석 <span class="trade-badge day-badge">DAY</span></div>
                        <div class="ai-score-container">
                            <div class="ai-score-circle" id="dayScoreCircle">
                                <div class="ai-score-number" id="dayScoreNumber">-</div>
                                <div class="ai-score-label">단타 점수</div>
                            </div>
                            <div>
                                <div class="ai-recommendation" id="dayRecommendation">-</div>
                                <div class="ai-summary" id="daySummary">-</div>
                            </div>
                        </div>
                        <div class="ai-details" id="dayDetails"></div>
                        <div class="warning-box">
                            <div class="title">단타 투자 주의사항</div>
                            <div class="text">단타 매매는 짧은 시간 내 빠른 판단이 필요하며, 손절 기준을 철저히 지켜야 합니다. 거래 수수료와 슬리피지를 고려하세요.</div>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--green)"></span>단타 기술적 지표</div>
                        <div class="indicator-grid" id="dayIndicatorGrid"></div>
                    </div>
                </div>
                <div class="tab-col-right">
                    <div class="entry-exit-row">
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--cyan)"></span>단타 진입 시점 <span class="trade-badge day-badge">DAY</span></div>
                        <div class="entry-card" id="dayEntryCard">
                            <div class="entry-verdict" id="dayEntryVerdict"></div>
                            <div class="entry-meter" id="dayEntryMeter"></div>
                            <div class="entry-checklist" id="dayEntryChecklist"></div>
                            <div class="entry-strategy" id="dayEntryStrategy"></div>
                            <div class="warning-box" style="margin-top:12px">
                                <div class="title">단타 리스크</div>
                                <div class="text">단타는 -2~3% 손절이 철칙입니다. 목표 수익률에 도달하면 미련 없이 익절하세요.</div>
                            </div>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--red)"></span>단타 매도 시점 <span class="trade-badge day-badge">DAY</span></div>
                        <div class="exit-card" id="dayExitCard">
                            <div class="exit-verdict" id="dayExitVerdict"></div>
                            <div class="exit-meter" id="dayExitMeter"></div>
                            <div class="exit-checklist" id="dayExitChecklist"></div>
                            <div class="exit-strategy" id="dayExitStrategy"></div>
                            <div class="warning-box" style="margin-top:12px">
                                <div class="title">단타 매도 원칙</div>
                                <div class="text">단타는 당일 청산이 원칙입니다. 오버나잇 리스크를 최소화하세요.</div>
                            </div>
                        </div>
                    </div>
                    </div>
                    <div id="splitCalcWrap"></div>
                </div>
            </div>

            <!-- ===== 스윙 분석 ===== -->
            <div class="trade-style-panel" id="tsPanelSwing" data-tstyle="swing">
                <div class="tab-col-left">
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:#8b5cf6"></span>스윙 종합 분석 <span class="trade-badge swing-badge">SWING</span></div>
                        <div class="ai-score-container">
                            <div class="ai-score-circle" id="swingScoreCircle">
                                <div class="ai-score-number" id="swingScoreNumber">-</div>
                                <div class="ai-score-label">스윙 점수</div>
                            </div>
                            <div>
                                <div class="ai-recommendation" id="swingRecommendation">-</div>
                                <div class="ai-summary" id="swingSummary">-</div>
                            </div>
                        </div>
                        <div class="ai-details" id="swingDetails"></div>
                        <div class="warning-box">
                            <div class="title">스윙 투자 주의사항</div>
                            <div class="text">스윙 매매는 2~10일의 보유 기간을 기준으로 하며, 오버나잇 리스크를 감안해야 합니다. 분할 매수/매도 전략을 활용하세요.</div>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--green)"></span>스윙 기술적 지표</div>
                        <div class="indicator-grid" id="swingIndicatorGrid"></div>
                    </div>
                </div>
                <div class="tab-col-right">
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--cyan)"></span>스윙 진입 시점 <span class="trade-badge swing-badge">SWING</span></div>
                        <div class="entry-card" id="swingEntryCard">
                            <div class="entry-verdict" id="swingEntryVerdict"></div>
                            <div class="entry-meter" id="swingEntryMeter"></div>
                            <div class="entry-checklist" id="swingEntryChecklist"></div>
                            <div class="entry-strategy" id="swingEntryStrategy"></div>
                            <div class="warning-box" style="margin-top:12px">
                                <div class="title">스윙 리스크</div>
                                <div class="text">스윙은 -5~7% 손절 기준을 설정하고, 이동평균선을 기준으로 추세를 따라가세요.</div>
                            </div>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title"><span class="dot" style="background:var(--red)"></span>스윙 매도 시점 <span class="trade-badge swing-badge">SWING</span></div>
                        <div class="exit-card" id="swingExitCard">
                            <div class="exit-verdict" id="swingExitVerdict"></div>
                            <div class="exit-meter" id="swingExitMeter"></div>
                            <div class="exit-checklist" id="swingExitChecklist"></div>
                            <div class="exit-strategy" id="swingExitStrategy"></div>
                            <div class="warning-box" style="margin-top:12px">
                                <div class="title">스윙 매도 원칙</div>
                                <div class="text">목표가 도달 시 50% 익절 후 나머지는 트레일링 스탑으로 관리하세요.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 3: 종목정보 -->
        <div class="tab-content" id="tabInfo" data-tab="info">
            <div class="tab-col-left">
                <!-- Financial Info -->
                <div class="card">
                    <div class="card-title"><span class="dot" style="background:var(--yellow)"></span>재무 정보</div>
                    <div class="finance-grid" id="financeGrid"></div>
                </div>
            </div>
            <div class="tab-col-right">
                <!-- 종목별 실적 발표 일정 -->
                <div class="card">
                    <div class="card-title"><span class="dot" style="background:var(--purple)"></span>실적 발표 일정</div>
                    <div id="stockEarnings">
                        <div style="text-align:center;padding:30px 0;color:var(--text3);font-size:14px;">종목 정보를 불러오면 표시됩니다.</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 4: 기업 -->
        <div class="tab-content" id="tabCompany" data-tab="company">
            <div class="tab-col-left">
                <!-- 개요: 기업소개 + 기본정보 -->
                <div class="card">
                    <div class="card-title"><span class="dot" style="background:var(--blue)"></span>개요</div>
                    <div id="companyOverview"><div class="cp-empty">종목을 검색하면 기업 정보가 표시됩니다.</div></div>
                </div>
                <!-- 주요 임원 -->
                <div class="card">
                    <div class="card-title"><span class="dot" style="background:var(--green)"></span>주요 임원</div>
                    <div id="companyExecutives"><div class="cp-empty">종목을 검색하면 표시됩니다.</div></div>
                </div>
                <!-- 최근 내부자 거래 -->
                <div class="card">
                    <div class="card-title"><span class="dot" style="background:var(--red)"></span>최근 내부자 거래</div>
                    <div id="companyInsider"><div class="cp-empty">종목을 검색하면 표시됩니다.</div></div>
                </div>
            </div>
            <div class="tab-col-right">
                <!-- 주요 투자 기관 -->
                <div class="card">
                    <div class="card-title"><span class="dot" style="background:var(--cyan)"></span>주요 투자 기관</div>
                    <div id="companyHolders"><div class="cp-empty">종목을 검색하면 표시됩니다.</div></div>
                </div>
            </div>
        </div>

        <!-- Tab 5: 옵션현황 -->
        <div class="tab-content" id="tabOptions" data-tab="options">
            <div class="options-wrap">
                <div class="options-empty" id="optionsEmpty">
                    종목을 검색하면 옵션 데이터가 표시됩니다.<br>
                    <span style="font-size:12px;margin-top:6px;display:block;">미국 주식 콜/풋 옵션 체인을 제공합니다.</span>
                </div>
                <div id="optionsContent" style="display:none;">
                    <!-- 만기일 선택 -->
                    <div class="options-exp-bar" id="optionsExpBar"></div>
                    <!-- 요약 통계 -->
                    <div class="options-summary-row" id="optionsSummary"></div>
                    <!-- 옵션 시장 분석 -->
                    <div id="optionsAnalysis"></div>
                    <!-- 필터 -->
                    <div class="options-toggle-row">
                        <span id="optionsCurrentExp" style="font-size:13px;font-weight:700;color:var(--text);"></span>
                        <div class="options-filter-btns">
                            <button class="options-filter-btn active" id="optITMBtn_all" onclick="setOptionsFilter('all')">전체</button>
                            <button class="options-filter-btn" id="optITMBtn_itm" onclick="setOptionsFilter('itm')">ITM만</button>
                            <button class="options-filter-btn" id="optITMBtn_otm" onclick="setOptionsFilter('otm')">OTM만</button>
                        </div>
                    </div>
                    <div class="options-toggle-row" style="margin-bottom:14px;">
                        <span class="options-filter-label">행사가 범위</span>
                        <div class="options-filter-btns">
                            <button class="options-filter-btn opt-range-btn active" data-r="all" onclick="setOptionsStrikeRange('all')">전체</button>
                            <button class="options-filter-btn opt-range-btn" data-r="5" onclick="setOptionsStrikeRange('5')">ATM±5%</button>
                            <button class="options-filter-btn opt-range-btn" data-r="10" onclick="setOptionsStrikeRange('10')">ATM±10%</button>
                            <button class="options-filter-btn opt-range-btn" data-r="20" onclick="setOptionsStrikeRange('20')">ATM±20%</button>
                        </div>
                        <button class="options-filter-btn" id="optionsVolBtn" onclick="toggleOptionsVolFilter()">거래량 &gt; 0</button>
                    </div>
                    <!-- 콜/풋 테이블 -->
                    <div class="options-chain-grid" id="optionsChainGrid"></div>
                </div>
            </div>
        </div>

    </div>
</div>
</div><!-- /app-wrapper -->

<!-- Loading -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
    <div class="loading-text" id="loadingText">데이터를 불러오는 중...</div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

    <script>
    // ========================================
    // State
    // ========================================
    let currentMarket = 'US';
    let currentPeriod = '6mo';
    let currentInterval = '1d';
    let currentSymbol = '';
    let currentFullSymbol = '';  // Yahoo Finance용 풀 심볼 (예: NVDA, 005930.KS)
    let liveUpdateTimer      = null;  // 실시간 가격 업데이트 타이머 (30초)
    let analysisRefreshTimer = null;  // 분석 자동 갱신 타이머 (5분)
    let rsiChart = null;
    let macdChart = null;
    let stochChart = null;
    let adxChart = null;
    let cciChart = null;
    let obvChart = null;
    let stockData = null;

    // Lightweight Charts 인스턴스
    let lwChart = null;
    let lwCandleSeries = null;
    let lwVolumeSeries = null;
    let lwMaSeries = {};       // { ma5, ma20, ma60, ma120 }
    let lwBbUpper = null;
    let lwBbLower = null;
    let lwAiOverlaySeries = []; // AI 보조지표 오버레이 라인들

    // ========================================
    // Side Navigation
    // ========================================
    function toggleSideNav() {
        document.getElementById('sideNav').classList.toggle('open');
        document.getElementById('sideNavBackdrop').classList.toggle('show');
    }
    function openSideNav() {
        document.getElementById('sideNav').classList.add('open');
        document.getElementById('sideNavBackdrop').classList.add('show');
    }
    function closeSideNav() {
        document.getElementById('sideNav').classList.remove('open');
        document.getElementById('sideNavBackdrop').classList.remove('show');
    }
    // window에 명시적 노출 + addEventListener 이중 바인딩
    window.closeSideNav = closeSideNav;
    window.toggleSideNav = toggleSideNav;
    window.openSideNav = openSideNav;
    document.querySelector('.side-nav-close')?.addEventListener('click', function(e) {
        e.stopPropagation();
        closeSideNav();
    });
    document.getElementById('sideNavBackdrop')?.addEventListener('click', function() {
        closeSideNav();
    });
    // 사이드바는 항상 닫힌 상태로 시작 (수동으로 햄버거 버튼 클릭 시 열림)

    // ========================================
    // Favorites (즐겨찾기) - localStorage
    // ========================================
    const FAV_KEY = 'stockai_favorites';

    function getFavorites() {
        try {
            return JSON.parse(localStorage.getItem(FAV_KEY)) || [];
        } catch(e) { return []; }
    }

    function saveFavorites(favs) {
        localStorage.setItem(FAV_KEY, JSON.stringify(favs));
    }

    function isFavorited(symbol, market) {
        return getFavorites().some(f => f.symbol === symbol && f.market === market);
    }

    function toggleFavorite() {
        if (!currentSymbol || !stockData) return;
        const market = currentMarket;
        const symbol = currentSymbol;
        const meta = stockData.meta;

        let name = meta.symbol;
        if (market === 'KR') {
            name = KR_STOCK_NAMES[symbol] || meta.symbol.replace('.KS','').replace('.KQ','');
        } else {
            // Try to find Korean name for US stock
            const usEntry = Object.entries(US_STOCK_NAMES).find(([k,v]) => v === symbol);
            name = usEntry ? usEntry[0] + ' (' + symbol + ')' : symbol;
        }

        let favs = getFavorites();
        const idx = favs.findIndex(f => f.symbol === symbol && f.market === market);
        if (idx >= 0) {
            favs.splice(idx, 1);
        } else {
            favs.unshift({ symbol, market, name, addedAt: Date.now() });
        }
        saveFavorites(favs);
        updateFavButton();
        renderFavList();
    }

    function removeFavorite(symbol, market) {
        let favs = getFavorites();
        favs = favs.filter(f => !(f.symbol === symbol && f.market === market));
        saveFavorites(favs);
        updateFavButton();
        renderFavList();
    }

    function updateFavButton() {
        const btn = document.getElementById('favStarBtn');
        const txt = document.getElementById('favStarText');
        if (!btn || !currentSymbol) return;
        const faved = isFavorited(currentSymbol, currentMarket);
        btn.classList.toggle('favorited', faved);
        btn.querySelector('.star').innerHTML = faved ? '&#9733;' : '&#9734;';
        if (txt) txt.textContent = faved ? '즐겨찾기 해제' : '즐겨찾기';
    }

    function renderFavList() {
        const container = document.getElementById('favList');
        if (!container) return;
        const favs = getFavorites();
        if (favs.length === 0) {
            container.innerHTML = '<div class="fav-empty">즐겨찾기한 종목이 없습니다.<br>종목 분석 후 &#9734; 버튼으로 추가하세요.</div>';
            return;
        }
        container.innerHTML = favs.map(f => {
            const sym = (f.symbol||'').replace(/'/g,'&#39;');
            const mkt = (f.market||'').replace(/'/g,'&#39;');
            const name = (f.name||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            return `<div class="fav-item" data-sym="${sym}" data-mkt="${mkt}">
                <span class="fav-item-market ${(f.market||'').toLowerCase()}">${mkt}</span>
                <div class="fav-item-info">
                    <div class="fav-item-name">${name}</div>
                    <div class="fav-item-code">${sym}</div>
                </div>
                <button class="fav-item-remove" title="삭제">&times;</button>
            </div>`;
        }).join('');
        // 이벤트 위임 (onclick 인라인 대신)
        container.querySelectorAll('.fav-item').forEach(el => {
            const sym = el.dataset.sym, mkt = el.dataset.mkt;
            el.addEventListener('click', () => favSearch(sym, mkt));
            el.querySelector('.fav-item-remove')?.addEventListener('click', e => {
                e.stopPropagation();
                removeFavorite(sym, mkt);
            });
        });
    }

    function favSearch(symbol, market) {
        closeSideNav();
        setMarket(market);
        document.getElementById('searchInput').value = symbol;
        searchStock();
    }

    // 초기 즐겨찾기 렌더
    renderFavList();

    // ========================================
    // Search Autocomplete Dropdown
    // ========================================
    let _searchTrending = null, _searchTrendingLoading = false, _dropdownHighlightIdx = -1;

    function debounce(fn, ms) { let t; return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), ms); }; }

    function _sdropItems() { return document.querySelectorAll('#searchDropdown .sdrop-item'); }

    function _sdropFmtPrice(p, market) {
        if (p == null) return '';
        return market === 'KR' ? Math.round(p).toLocaleString()+'원' : '$'+p.toFixed(2);
    }
    function _sdropFmtChg(pct) {
        if (pct == null) return {text:'', cls:'flat'};
        return { text:(pct>=0?'+':'')+pct.toFixed(2)+'%', cls:pct>0?'up':pct<0?'down':'flat' };
    }

    function _sdropItemHTML(item, idx) {
        const flag = item.market === 'KR' ? '🇰🇷' : '🇺🇸';
        const badgeCls = item.type === 'etf' ? 'etf' : 'stock';
        const badgeTxt = item.type === 'etf' ? 'ETF' : '주식';
        const mktCls = item.market === 'KR' ? 'kr' : 'us';
        const nameDisplay = (item.koreanName && item.koreanName !== item.ticker) ? item.koreanName : (item.name||item.ticker);
        const chg = _sdropFmtChg(item._changePct);
        const priceHTML = item._price != null
            ? `<span class="sdrop-price">${_sdropFmtPrice(item._price, item.market)}</span>
               <span class="sdrop-change ${chg.cls}">${chg.text}</span>` : '';
        return `<div class="sdrop-item" role="option" data-ticker="${item.ticker}" data-market="${item.market}" data-idx="${idx}">
            <span class="sdrop-flag">${flag}</span>
            <div class="sdrop-info">
                <div class="sdrop-name">${nameDisplay}</div>
                <div class="sdrop-ticker">${item.ticker}${item.sector?' · '+item.sector:''}</div>
            </div>
            <span class="sdrop-badge ${mktCls}">${item.market}</span>
            <span class="sdrop-badge ${badgeCls}">${badgeTxt}</span>
            ${priceHTML}
        </div>`;
    }

    function _sdropSkeletonHTML(n=5) {
        let h='';
        for(let i=0;i<n;i++) h+=`<div class="sdrop-skel">
            <div class="sdrop-skel-circle"></div>
            <div class="sdrop-info">
                <div class="sdrop-skel-line" style="width:${80+i*8}px;margin-bottom:5px;"></div>
                <div class="sdrop-skel-line" style="width:50px;height:10px;"></div>
            </div></div>`;
        return h;
    }

    function _attachDropdownClicks(el) {
        el.querySelectorAll('.sdrop-item').forEach(row => {
            row.addEventListener('mousedown', e => e.preventDefault());
            row.addEventListener('click', () => {
                const ticker = row.dataset.ticker, market = row.dataset.market;
                closeSearchDropdown();
                setMarket(market);
                document.getElementById('searchInput').value = ticker;
                searchStock();
            });
        });
    }

    function renderDropdown(mode, data) {
        const el = document.getElementById('searchDropdown');
        if (!el) return;
        _dropdownHighlightIdx = -1;
        if (mode === 'hidden') { el.classList.remove('open'); return; }
        let html = '';
        if (mode === 'empty') {
            const favs = getFavorites();
            if (favs.length) {
                html += `<div class="sdrop-section-title">⭐ 즐겨찾기</div>`;
                html += favs.slice(0,5).map((f,i) => {
                    const meta = ASSET_META[f.symbol]||{};
                    return _sdropItemHTML({ticker:f.symbol,name:f.name,koreanName:f.name,
                        market:f.market,type:meta.type||'stock',sector:meta.sector||'',score:0}, i);
                }).join('');
            }
            html += `<div class="sdrop-section-title">🔥 인기 종목</div>`;
            if (_searchTrending === null) {
                html += _sdropSkeletonHTML(5);
                el.innerHTML = html; el.classList.add('open');
                if (!_searchTrendingLoading) {
                    _searchTrendingLoading = true;
                    _fetchSearchTrending().then(() => {
                        const inp = document.getElementById('searchInput');
                        if (inp?.value.trim()==='' && el.classList.contains('open')) renderDropdown('empty',null);
                    });
                }
                return;
            } else if (!_searchTrending.length) {
                html += `<div style="padding:10px 14px;color:var(--text3);font-size:12px;">데이터를 불러올 수 없습니다.</div>`;
            } else {
                const offset = getFavorites().slice(0,5).length;
                html += _searchTrending.slice(0,5).map((item,i) => _sdropItemHTML(item, offset+i)).join('');
            }
        } else if (mode === 'results') {
            if (!data?.length) {
                html = `<div style="padding:14px 16px;color:var(--text3);font-size:13px;">검색 결과가 없습니다.</div>`;
            } else {
                html += `<div class="sdrop-section-title">🔍 검색 결과</div>`;
                html += data.map((item,i) => _sdropItemHTML(item,i)).join('');
            }
        }
        el.innerHTML = html; el.classList.add('open');
        _attachDropdownClicks(el);
    }

    async function _fetchSearchTrending() {
        try {
            if (top100Cache?.['day_gainers']?.items?.length &&
                Date.now() - top100Cache['day_gainers'].ts < TOP100_CACHE_MS) {
                _buildTrendingItems(top100Cache['day_gainers'].items); return;
            }
            const url = `https://query1.finance.yahoo.com/v1/finance/screener/predefined/saved?formatted=false&lang=en-US&region=US&scrIds=day_gainers&count=10`;
            const data = await fetchWithProxy(url);
            const quotes = data?.finance?.result?.[0]?.quotes;
            if (quotes?.length) { _buildTrendingItems(quotes); return; }
        } catch(e) {}
        _searchTrending = []; _searchTrendingLoading = false;
    }

    function _buildTrendingItems(items) {
        _searchTrending = items.slice(0,5).map(q => {
            const meta = ASSET_META[q.symbol]||{};
            const kor = Object.entries(US_STOCK_NAMES).find(([,v])=>v===q.symbol);
            return { ticker:q.symbol, name:q.shortName||q.symbol,
                koreanName:kor?kor[0]:(q.shortName||q.symbol),
                market:'US', type:meta.type||(q.quoteType==='ETF'?'etf':'stock'),
                sector:meta.sector||q.sector||'',
                _price:q.regularMarketPrice, _changePct:q.regularMarketChangePercent };
        });
        _searchTrendingLoading = false;
    }

    function openSearchDropdown() {
        const inp = document.getElementById('searchInput');
        if (inp?.value.trim()==='') renderDropdown('empty', null);
    }
    function closeSearchDropdown() { renderDropdown('hidden', null); }

    function _highlightDropdownItem(idx) {
        const items = _sdropItems();
        items.forEach(el => el.classList.remove('highlighted'));
        if (idx < 0 || idx >= items.length) { _dropdownHighlightIdx = -1; return; }
        _dropdownHighlightIdx = idx;
        items[idx].classList.add('highlighted');
        items[idx].scrollIntoView({block:'nearest'});
    }

    const _debouncedSuggest = debounce(query => {
        if (!query.trim()) { renderDropdown('empty', null); return; }
        renderDropdown('results', searchSuggest(query, 8));
    }, 300);

    function handleSearchKeydown(e) {
        const drop = document.getElementById('searchDropdown');
        const isOpen = drop?.classList.contains('open');
        switch(e.key) {
            case 'Enter':
                e.preventDefault();
                if (isOpen && _dropdownHighlightIdx >= 0) {
                    _sdropItems()[_dropdownHighlightIdx]?.click();
                } else { closeSearchDropdown(); searchStock(); }
                break;
            case 'Escape': closeSearchDropdown(); document.getElementById('searchInput').blur(); break;
            case 'ArrowDown':
                e.preventDefault();
                if (!isOpen) openSearchDropdown();
                else _highlightDropdownItem(Math.min(_dropdownHighlightIdx+1, _sdropItems().length-1));
                break;
            case 'ArrowUp':
                e.preventDefault();
                if (isOpen) _highlightDropdownItem(Math.max(_dropdownHighlightIdx-1, 0));
                break;
        }
    }

    // 이벤트 바인딩 (DOM 준비 후 실행)
    window.addEventListener('DOMContentLoaded', () => {
        const inp = document.getElementById('searchInput');
        if (!inp) return;
        inp.addEventListener('focus', () => {
            if (inp.value.trim()==='') openSearchDropdown();
            else renderDropdown('results', searchSuggest(inp.value, 8));
        });
        inp.addEventListener('input', () => _debouncedSuggest(inp.value));
        inp.addEventListener('blur', () => setTimeout(closeSearchDropdown, 150));
        document.addEventListener('click', e => {
            const wrap = document.getElementById('searchWrap');
            if (wrap && !wrap.contains(e.target)) closeSearchDropdown();
        });
    });

    // 백엔드 API 베이스 URL (같은 도메인 서빙 시 빈 문자열)
    const API_BASE = '';

    // ========================================
    // Market / Period / Chart Type
    // ========================================
    function setMarket(market) {
        currentMarket = market;
        document.querySelectorAll('.market-btn').forEach(b => b.classList.toggle('active', b.dataset.market === market));
        const input = document.getElementById('searchInput');
        input.placeholder = market === 'KR' ? '종목명 또는 코드 (예: 삼성전자, 005930)' : '종목명 또는 티커 (예: 테슬라, AAPL)';
        input.value = '';
    }

    // 분봉/시간봉인지 판별
    function isIntraday(interval) {
        return ['1m','5m','15m','1h'].includes(interval);
    }

    // 봉 타입별 허용 기간 및 기본 기간
    const INTERVAL_RANGES = {
        '1m':  { allowed: ['1d','5d'], defaultRange: '1d' },
        '5m':  { allowed: ['1d','5d'], defaultRange: '1d' },
        '15m': { allowed: ['1d','5d'], defaultRange: '5d' },
        '1h':  { allowed: ['5d','1mo'], defaultRange: '5d' },
        '1d':  { allowed: ['1mo','3mo','6mo','1y','5y'], defaultRange: '6mo' },
        '1wk': { allowed: ['3mo','6mo','1y','5y'], defaultRange: '1y' },
    };

    function setPeriod(period) {
        currentPeriod = period;
        document.querySelectorAll('.range-btn').forEach(b => b.classList.toggle('active', b.dataset.range === period));
        if (currentSymbol) searchStock();
    }

    function setChartInterval(interval) {
        currentInterval = interval;
        document.querySelectorAll('.interval-btn').forEach(b => b.classList.toggle('active', b.dataset.interval === interval));

        // 봉 타입에 맞게 기간 버튼 표시/숨김 및 기본 기간 설정
        const config = INTERVAL_RANGES[interval];
        const rangeButtons = document.querySelectorAll('.range-btn');
        let currentRangeValid = false;

        rangeButtons.forEach(b => {
            const r = b.dataset.range;
            if (config.allowed.includes(r)) {
                b.style.display = '';
                if (r === currentPeriod) currentRangeValid = true;
            } else {
                b.style.display = 'none';
                b.classList.remove('active');
            }
        });

        // 현재 기간이 유효하지 않으면 기본값으로 변경
        if (!currentRangeValid) {
            currentPeriod = config.defaultRange;
            rangeButtons.forEach(b => b.classList.toggle('active', b.dataset.range === currentPeriod));
        }

        if (currentSymbol) searchStock();
    }

    function setChartType() {}

    function getTimeUnit() {
        switch (currentInterval) {
            case '1m':  return 'minute';
            case '5m':  return 'minute';
            case '15m': return 'minute';
            case '1h':  return 'hour';
            case '1wk':
                return (currentPeriod === '5y') ? 'quarter' : 'month';
            default: // 1d
                if (currentPeriod === '5y' || currentPeriod === '1y') return 'month';
                if (currentPeriod === '6mo' || currentPeriod === '3mo') return 'week';
                return 'day';
        }
    }

    function getIntervalLabel() {
        const map = { '1m': '1분봉', '5m': '5분봉', '15m': '15분봉', '1h': '1시간봉', '1d': '일봉', '1wk': '주봉' };
        return map[currentInterval] || '일봉';
    }

    function quickSearch(symbol, market) {
        setMarket(market);
        document.getElementById('searchInput').value = symbol;
        searchStock();
    }

    // ========================================
    // Tab Navigation
    // ========================================
    function switchTab(tabName) {
        document.querySelectorAll('.tab-item').forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
        // 옵션 탭 클릭 시 데이터 로드 (lazy load)
        if (tabName === 'options' && currentFullSymbol) {
            renderOptionsTab(currentFullSymbol);
        }
    }

    // ========================================
    // US Top 100 Stocks (optimized)
    // ========================================
    let top100Cache = {};
    let top100Filter = 'most_actives';
    const TOP100_CACHE_MS = 180000; // 3분
    const TOP100_LS_KEY = 'top100_cache';
    const TOP100_FILTERS = ['most_actives','day_gainers','day_losers'];

    // localStorage에서 캐시 복원 (즉시 렌더용)
    try {
        const saved = JSON.parse(localStorage.getItem(TOP100_LS_KEY));
        if (saved && typeof saved === 'object') {
            for (const k of TOP100_FILTERS) {
                if (saved[k]?.items?.length && Date.now() - saved[k].ts < TOP100_CACHE_MS) {
                    top100Cache[k] = saved[k];
                }
            }
        }
    } catch(e) {}

    function showTop100Skeleton() {
        const grid = document.getElementById('top100Grid');
        if (!grid) return;
        let html = `<div class="top100-row top100-row-head">
            <div>#</div><div>종목</div><div style="text-align:right">현재가</div><div style="text-align:right">등락률</div><div style="text-align:right">거래량</div>
        </div>`;
        for (let i = 0; i < 20; i++) {
            html += `<div class="skel-row">
                <div class="skel-block skel-rank"></div>
                <div class="skel-info"><div class="skel-block skel-sym"></div><div class="skel-block skel-name"></div></div>
                <div class="skel-block skel-price"></div>
                <div class="skel-block skel-chg"></div>
                <div class="skel-block skel-vol"></div>
            </div>`;
        }
        grid.innerHTML = html;
    }

    function setTop100Filter(filter) {
        top100Filter = filter;
        document.querySelectorAll('.top100-filter').forEach(b => b.classList.toggle('active', b.dataset.filter === filter));
        // 캐시 있으면 즉시 렌더, 없으면 스켈레톤 + fetch
        if (top100Cache[filter] && Date.now() - top100Cache[filter].ts < TOP100_CACHE_MS) {
            renderTop100(top100Cache[filter].items);
        } else {
            showTop100Skeleton();
            fetchTop100Single(filter);
        }
    }

    async function fetchTop100Single(filter) {
        try {
            const url = `https://query1.finance.yahoo.com/v1/finance/screener/predefined/saved?formatted=false&lang=en-US&region=US&scrIds=${filter}&count=100`;
            const data = await fetchRace(url, 6000);
            const quotes = data?.finance?.result?.[0]?.quotes;
            if (quotes?.length) {
                const items = quotes.slice(0, 100);
                top100Cache[filter] = { items, ts: Date.now() };
                saveTop100LS();
                if (top100Filter === filter) renderTop100(items);
                return;
            }
        } catch(e) {}
        // fallback
        try {
            const fb = 'AAPL,MSFT,GOOGL,AMZN,NVDA,META,TSLA,BRK-B,JPM,V,UNH,XOM,JNJ,WMT,MA,PG,HD,CVX,ABBV,MRK,KO,PEP,BAC,COST,AVGO,LLY,TMO,MCD,CSCO,ACN,ABT,DHR,ADBE,CRM,NFLX,AMD,INTC,QCOM,TXN,ORCL,IBM,GS,MS,BA,CAT,DIS,NKE,PYPL,UBER,SQ,SNAP,SHOP,PLTR,COIN,ABNB,CRWD,SNOW,NET,DDOG,MDB,PANW,FTNT,TTD,RBLX,ARM,SMCI,SOFI,HOOD,MARA,RIOT,MSTR,TSM,ASML,MU,AMAT,LRCX,KLAC,NOW,INTU,ISRG,REGN,GILD,MRNA,PFE,UNP,HON,LOW,TJX,SBUX,CMG,YUM,CL,MMM,GE,RTX,LMT,DE,FDX,UPS,T,VZ,TMUS';
            const qData = await fetchWithProxy(`https://query1.finance.yahoo.com/v7/finance/quote?symbols=${fb}`);
            const quotes = qData?.quoteResponse?.result || [];
            if (quotes.length) {
                let sorted = [...quotes];
                if (filter === 'day_gainers') sorted.sort((a,b) => (b.regularMarketChangePercent||0) - (a.regularMarketChangePercent||0));
                else if (filter === 'day_losers') sorted.sort((a,b) => (a.regularMarketChangePercent||0) - (b.regularMarketChangePercent||0));
                else sorted.sort((a,b) => (b.regularMarketVolume||0) - (a.regularMarketVolume||0));
                const items = sorted.slice(0, 100);
                top100Cache[filter] = { items, ts: Date.now() };
                saveTop100LS();
                if (top100Filter === filter) renderTop100(items);
                return;
            }
        } catch(e) {}
        const grid = document.getElementById('top100Grid');
        if (grid && top100Filter === filter) grid.innerHTML = '<div class="top100-loading">데이터를 불러올 수 없습니다. 잠시 후 다시 시도해주세요.</div>';
    }

    function saveTop100LS() {
        try { localStorage.setItem(TOP100_LS_KEY, JSON.stringify(top100Cache)); } catch(e) {}
    }

    // 모든 필터 병렬 프리로드
    function preloadAllTop100() {
        TOP100_FILTERS.forEach(f => {
            if (!top100Cache[f] || Date.now() - top100Cache[f].ts >= TOP100_CACHE_MS) {
                fetchTop100Single(f);
            }
        });
    }

    function loadTop100() {
        const filter = top100Filter;
        if (top100Cache[filter] && Date.now() - top100Cache[filter].ts < TOP100_CACHE_MS) {
            renderTop100(top100Cache[filter].items);
            // 백그라운드에서 나머지 필터도 갱신
            preloadAllTop100();
        } else {
            showTop100Skeleton();
            preloadAllTop100();
        }
    }

    function renderTop100(items) {
        const grid = document.getElementById('top100Grid');
        const updatedEl = document.getElementById('top100Updated');
        if (!grid) return;

        if (!items || items.length === 0) {
            grid.innerHTML = '<div class="top100-loading">데이터가 없습니다.</div>';
            return;
        }

        const now = new Date();
        if (updatedEl) updatedEl.textContent = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')} 업데이트`;

        const fmtVol = v => {
            if (v == null) return '-';
            if (v >= 1e9) return (v/1e9).toFixed(1) + 'B';
            if (v >= 1e6) return (v/1e6).toFixed(1) + 'M';
            if (v >= 1e3) return (v/1e3).toFixed(0) + 'K';
            return v.toLocaleString();
        };

        let html = '';
        html += `<div class="top100-row top100-row-head">
            <div>#</div><div>종목</div><div style="text-align:right">현재가</div><div style="text-align:right">등락률</div><div style="text-align:right">거래량</div>
        </div>`;

        items.forEach((q, i) => {
            const symbol = q.symbol || '';
            const name = q.shortName || q.longName || symbol;
            const price = q.regularMarketPrice;
            const chg = q.regularMarketChangePercent;
            const vol = q.regularMarketVolume;

            const chgCls = chg > 0 ? 'up' : chg < 0 ? 'down' : 'flat';
            const chgText = chg != null ? `${chg >= 0 ? '+' : ''}${chg.toFixed(2)}%` : '-';
            const priceText = price != null ? `$${price.toFixed(2)}` : '-';
            const rankCls = i < 3 ? 'top3' : '';

            html += `<div class="top100-row" onclick="quickSearch('${symbol}','US')">
                <div class="top100-rank ${rankCls}">${i + 1}</div>
                <div class="top100-info">
                    <div class="top100-symbol">${symbol}</div>
                    <div class="top100-name">${name}</div>
                </div>
                <div class="top100-price">${priceText}</div>
                <div class="top100-change ${chgCls}">${chgText}</div>
                <div class="top100-vol">${fmtVol(vol)}</div>
            </div>`;
        });

        grid.innerHTML = html;
    }

    // 페이지 로드 시 즉시 실행
    loadTop100();

    function goHome() {
        document.getElementById('welcomeScreen').style.display = '';
        document.getElementById('stockHero').classList.remove('show');
        document.getElementById('tabNav').classList.remove('show');
        document.getElementById('marketSessionInfo').classList.remove('show');
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        destroyChart();
        aiLineStore = [];
        aiLineIdCounter = 0;
        renderAiLineList();
        clearAllDrawings();
        document.getElementById('searchInput').value = '';
        currentSymbol = '';
        currentFullSymbol = '';
        stockData = null;
        stopLiveUpdate();
        stopAnalysisRefresh();
        // 캐시 있으면 즉시 렌더, 없으면 스켈레톤 + 프리로드
        loadTop100();
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // ========================================
    // Korean Stock Name Mapping (주요 종목)
    // ========================================
    const KR_STOCK_NAMES = {
        '005930':'삼성전자','000660':'SK하이닉스','035420':'NAVER','035720':'카카오',
        '005380':'현대차','000270':'기아','006400':'삼성SDI','051910':'LG화학',
        '003670':'포스코홀딩스','105560':'KB금융','055550':'신한지주','096770':'SK이노베이션',
        '034730':'SK','015760':'한국전력','003550':'LG','032830':'삼성생명',
        '086790':'하나금융지주','066570':'LG전자','028260':'삼성물산','012330':'현대모비스',
        '030200':'KT','017670':'SK텔레콤','316140':'우리금융지주','009150':'삼성전기',
        '034020':'두산에너빌리티','010130':'고려아연','033780':'KT&G','011200':'HMM',
        '010950':'S-Oil','000810':'삼성화재','018260':'삼성에스디에스','036570':'NCsoft',
        '259960':'크래프톤','251270':'넷마블','263750':'펄어비스','352820':'하이브',
        '293490':'카카오게임즈','041510':'에스엠','122870':'YG엔터','047810':'한국항공우주',
        '012450':'한화에어로스페이스','042700':'한미반도체','403870':'HPSP','460860':'피엠티',
        '247540':'에코프로비엠','086520':'에코프로','373220':'LG에너지솔루션',
        '207940':'삼성바이오로직스','068270':'셀트리온','326030':'SK바이오팜',
        '196170':'알테오젠','000100':'유한양행','128940':'한미약품','006800':'미래에셋증권',
        '005490':'포스코','009540':'한국조선해양','010140':'삼성중공업',
        '329180':'현대중공업','042660':'한화오션','090430':'아모레퍼시픽',
        '051900':'LG생활건강','021240':'코웨이','004020':'현대제철','005830':'DB손해보험',
        '139480':'이마트','004170':'신세계','069500':'KODEX 200','005940':'NH투자증권',
        '024110':'기업은행','000720':'현대건설','010620':'현대미포조선','002790':'아모레G',
        '011070':'LG이노텍','009830':'한화솔루션','267250':'현대일렉트릭','298050':'효성첨단소재',
        '180640':'한진칼','003490':'대한항공','020560':'아시아나항공','078930':'GS',
        '138040':'메리츠금융지주','001450':'현대해상','036460':'한국가스공사','161390':'한국타이어앤테크놀로지',
        '114800':'KODEX 인버스','252670':'KODEX 레버리지',
        '233740':'KODEX 코스닥150레버리지','091160':'KODEX 반도체',
        '102110':'TIGER 200','229200':'KODEX 코스닥150',
        '251340':'KODEX 코스닥150인버스','360750':'TIGER 미국S&P500',
    };

    // 미국 주식 한글명 → 티커 매핑
    const US_STOCK_NAMES = {
        '애플':'AAPL','아마존':'AMZN','구글':'GOOGL','알파벳':'GOOGL',
        '마이크로소프트':'MSFT','메타':'META','페이스북':'META',
        '테슬라':'TSLA','엔비디아':'NVDA','넷플릭스':'NFLX',
        '아이폰':'AAPL','MS':'MSFT','구글A':'GOOGL','구글C':'GOOG',
        '알파벳A':'GOOGL','알파벳C':'GOOG',
        'AMD':'AMD','어드밴스트마이크로디바이시스':'AMD',
        '인텔':'INTC','퀄컴':'QCOM','브로드컴':'AVGO',
        '애플':'AAPL','코스트코':'COST','월마트':'WMT',
        '스타벅스':'SBUX','맥도날드':'MCD','나이키':'NKE','코카콜라':'KO',
        '펩시코':'PEP','펩시':'PEP','디즈니':'DIS','월트디즈니':'DIS',
        '비자':'V','마스터카드':'MA','페이팔':'PYPL',
        'JP모건':'JPM','제이피모건':'JPM','골드만삭스':'GS',
        '버크셔해서웨이':'BRK-B','버크셔':'BRK-B','워렌버핏':'BRK-B',
        '존슨앤존슨':'JNJ','존슨앤드존슨':'JNJ','화이자':'PFE',
        '모더나':'MRNA','일라이릴리':'LLY','릴리':'LLY',
        '유나이티드헬스':'UNH','애브비':'ABBV',
        '프록터앤갬블':'PG','P&G':'PG',
        '엑슨모빌':'XOM','셰브론':'CVX','쉐브론':'CVX',
        '보잉':'BA','록히드마틴':'LMT','레이시온':'RTX',
        '캐터필러':'CAT','쓰리엠':'MMM','3M':'MMM',
        '홈디포':'HD','세일즈포스':'CRM','어도비':'ADBE',
        '오라클':'ORCL','IBM':'IBM','시스코':'CSCO',
        '우버':'UBER','에어비앤비':'ABNB',
        '팔란티어':'PLTR','스노우플레이크':'SNOW',
        '크라우드스트라이크':'CRWD','데이터독':'DDOG',
        '쇼피파이':'SHOP','스퀘어':'SQ','블록':'SQ',
        '줌':'ZM','줌비디오':'ZM','로블록스':'RBLX',
        '리비안':'RIVN','루시드':'LCID','니오':'NIO',
        '샤오펑':'XPEV','리오토':'LI',
        'ARM':'ARM','아르키메데스':'ARM','아름':'ARM',
        '마이크론':'MU','어플라이드머티리얼즈':'AMAT',
        'ASML':'ASML','램리서치':'LRCX','KLA':'KLAC',
        '팔란티어':'PLTR','슈퍼마이크로':'SMCI',
        'TSM':'TSM','TSMC':'TSM','대만반도체':'TSM',
        '소파이':'SOFI','코인베이스':'COIN',
        '로빈후드':'HOOD','인튜이트':'INTU',
        '서비스나우':'NOW','몽고DB':'MDB',
        '트레이드데스크':'TTD','유니티':'U',
        'AT&T':'T','버라이즌':'VZ','티모바일':'TMUS',
        // ETF
        'S&P500':'SPY','SPY':'SPY','나스닥':'QQQ','QQQ':'QQQ',
        '다우존스':'DIA','러셀2000':'IWM',
        '반도체ETF':'SOXX','기술주ETF':'XLK',
        '금ETF':'GLD','은ETF':'SLV','원유ETF':'USO',
        '비트코인ETF':'IBIT','채권ETF':'TLT',
        '레버리지나스닥':'TQQQ','인버스나스닥':'SQQQ',
        '레버리지S&P':'SPXL','인버스S&P':'SPXS',
        'SOXL':'SOXL','레버리지반도체':'SOXL',
    };

    const US_ETF_NAMES = {
        'SPY':{ name:'SPDR S&P 500 ETF',              korean:['에스피와이','S&P500','스파이'],           sector:'Index',        themes:['sp500'] },
        'QQQ':{ name:'Invesco QQQ Trust',              korean:['큐큐큐','나스닥100'],                    sector:'Index',        themes:['nasdaq100'] },
        'IWM':{ name:'iShares Russell 2000 ETF',       korean:['러셀2000','소형주'],                     sector:'Index',        themes:['smallcap'] },
        'DIA':{ name:'SPDR Dow Jones ETF',             korean:['다우존스','DIA'],                        sector:'Index',        themes:['dow'] },
        'VTI':{ name:'Vanguard Total Market ETF',      korean:['VTI','전체시장'],                        sector:'Index',        themes:['totalmarket'] },
        'VOO':{ name:'Vanguard S&P 500 ETF',           korean:['VOO','뱅가드'],                          sector:'Index',        themes:['sp500'] },
        'TQQQ':{ name:'ProShares UltraPro QQQ',        korean:['티큐큐큐','3배레버리지나스닥'],          sector:'Leveraged',    themes:['3x','nasdaq'] },
        'SQQQ':{ name:'ProShares UltraPro Short QQQ',  korean:['인버스나스닥','3배인버스'],               sector:'Inverse',      themes:['inverse','nasdaq'] },
        'SOXL':{ name:'Direxion Semi Bull 3X',         korean:['SOXL','레버리지반도체','반도체3배'],     sector:'Leveraged',    themes:['3x','semiconductor'] },
        'SOXS':{ name:'Direxion Semi Bear 3X',         korean:['SOXS','인버스반도체'],                   sector:'Inverse',      themes:['inverse','semiconductor'] },
        'SOXX':{ name:'iShares Semiconductor ETF',     korean:['반도체ETF','SOXX'],                      sector:'Sector',       themes:['semiconductor'] },
        'SMH':{ name:'VanEck Semiconductor ETF',       korean:['SMH','반도체'],                          sector:'Sector',       themes:['semiconductor'] },
        'SPXL':{ name:'Direxion S&P 500 Bull 3X',      korean:['레버리지S&P','SPXL'],                   sector:'Leveraged',    themes:['3x','sp500'] },
        'SPXS':{ name:'Direxion S&P 500 Bear 3X',      korean:['인버스S&P','SPXS'],                     sector:'Inverse',      themes:['inverse','sp500'] },
        'XLK':{ name:'Technology Select SPDR',         korean:['기술주ETF','XLK'],                       sector:'Sector',       themes:['tech'] },
        'XLF':{ name:'Financial Select SPDR',          korean:['금융ETF','XLF'],                         sector:'Sector',       themes:['finance'] },
        'XLE':{ name:'Energy Select SPDR',             korean:['에너지ETF','XLE'],                       sector:'Sector',       themes:['energy'] },
        'XLV':{ name:'Health Care Select SPDR',        korean:['헬스케어ETF','XLV'],                     sector:'Sector',       themes:['healthcare'] },
        'ARKK':{ name:'ARK Innovation ETF',            korean:['아크이노베이션','ARKK','캐시우드'],       sector:'Thematic',     themes:['innovation'] },
        'ARKG':{ name:'ARK Genomic Revolution ETF',    korean:['아크유전체','ARKG'],                      sector:'Thematic',     themes:['genomics'] },
        'GLD':{ name:'SPDR Gold Shares',               korean:['금ETF','골드ETF','GLD'],                  sector:'Commodity',    themes:['gold'] },
        'SLV':{ name:'iShares Silver Trust',           korean:['은ETF','SLV'],                           sector:'Commodity',    themes:['silver'] },
        'USO':{ name:'United States Oil Fund',         korean:['원유ETF','USO'],                          sector:'Commodity',    themes:['oil'] },
        'TLT':{ name:'iShares 20+ Year Treasury',      korean:['장기채권ETF','TLT','채권ETF'],            sector:'Bond',         themes:['bond'] },
        'HYG':{ name:'iShares High Yield Corp Bond',   korean:['하이일드채권','HYG'],                    sector:'Bond',         themes:['highyield'] },
        'VNQ':{ name:'Vanguard Real Estate ETF',       korean:['리츠ETF','VNQ'],                         sector:'Real Estate',  themes:['reit'] },
        'IBIT':{ name:'iShares Bitcoin Trust',         korean:['비트코인ETF','IBIT'],                    sector:'Crypto',       themes:['bitcoin'] },
        'EEM':{ name:'iShares MSCI Emerging Markets',  korean:['신흥국ETF','EEM'],                        sector:'International',themes:['emerging'] },
        'EWJ':{ name:'iShares MSCI Japan ETF',         korean:['일본ETF','EWJ'],                         sector:'International',themes:['japan'] },
        'MCHI':{ name:'iShares MSCI China ETF',        korean:['중국ETF','MCHI'],                        sector:'International',themes:['china'] },
        'VXX':{ name:'iPath S&P 500 VIX ETF',          korean:['VIX','변동성ETF','공포지수'],            sector:'Volatility',   themes:['vix'] },
        'UVXY':{ name:'ProShares Ultra VIX ETF',       korean:['VIX레버리지','UVXY'],                    sector:'Volatility',   themes:['vix'] },
        'FNGU':{ name:'MicroSectors FANG+ 3X ETN',     korean:['FNGU','팡플러스레버리지'],               sector:'Leveraged',    themes:['fang','3x'] },
        'FNGD':{ name:'MicroSectors FANG+ -3X ETN',    korean:['FNGD','팡인버스'],                       sector:'Inverse',      themes:['fang','inverse'] },
        'BITO':{ name:'ProShares Bitcoin Strategy',    korean:['비트코인선물ETF','BITO'],                 sector:'Crypto',       themes:['bitcoin'] },
        'LQD':{ name:'iShares IG Corporate Bond',      korean:['투자등급채권','LQD'],                    sector:'Bond',         themes:['bond'] },
    };

    const ASSET_META = (() => {
        const m = {};
        const usStockSectors = {
            'AAPL':'Technology','MSFT':'Technology','GOOGL':'Technology','GOOG':'Technology',
            'AMZN':'Consumer','META':'Technology','TSLA':'EV','NVDA':'Semiconductor',
            'AMD':'Semiconductor','INTC':'Semiconductor','QCOM':'Semiconductor','AVGO':'Semiconductor',
            'MU':'Semiconductor','AMAT':'Semiconductor','ASML':'Semiconductor','TSM':'Semiconductor',
            'ARM':'Semiconductor','SMCI':'Technology',
            'NFLX':'Entertainment','DIS':'Entertainment','RBLX':'Gaming',
            'PLTR':'Software','SNOW':'Software','CRM':'Software','ADBE':'Software','ORCL':'Software',
            'NOW':'Software','MDB':'Software','DDOG':'Software','CRWD':'Software','NET':'Software',
            'PANW':'Software','FTNT':'Software','TTD':'AdTech',
            'JPM':'Finance','GS':'Finance','MS':'Finance','BAC':'Finance','V':'Finance','MA':'Finance',
            'PYPL':'Fintech','COIN':'Crypto','SOFI':'Fintech','HOOD':'Fintech','SQ':'Fintech',
            'XOM':'Energy','CVX':'Energy','BA':'Aerospace','LMT':'Defense','RTX':'Defense',
            'UBER':'Transport','ABNB':'Travel','SHOP':'Ecommerce',
            'JNJ':'Healthcare','PFE':'Healthcare','MRNA':'Biotech','LLY':'Pharma','ABBV':'Pharma',
            'UNH':'Healthcare','ISRG':'Healthcare','REGN':'Biotech','GILD':'Biotech',
            'WMT':'Retail','COST':'Retail','HD':'Retail','SBUX':'Consumer','MCD':'Consumer',
            'KO':'Consumer','PEP':'Consumer','NKE':'Consumer','T':'Telecom','VZ':'Telecom','TMUS':'Telecom',
            'MSTR':'Crypto','MARA':'Crypto','RIOT':'Crypto','BRK-B':'Conglomerate',
            'UNP':'Transport','FDX':'Transport','UPS':'Transport','IBM':'Technology','CSCO':'Technology',
            'INTU':'Software','TXN':'Semiconductor',
        };
        for (const [ticker, sector] of Object.entries(usStockSectors)) {
            m[ticker] = { type:'stock', sector, market:'US' };
        }
        for (const [ticker, etf] of Object.entries(US_ETF_NAMES)) {
            m[ticker] = { type:'etf', sector:etf.sector, market:'US' };
        }
        for (const code of Object.keys(KR_STOCK_NAMES)) {
            const name = KR_STOCK_NAMES[code];
            const isEtf = /^(KODEX|TIGER|KOSEF|KBSTAR|ARIRANG|HANARO)/.test(name);
            m[code] = { type: isEtf ? 'etf' : 'stock', sector: isEtf ? 'ETF' : '한국주식', market:'KR' };
        }
        return m;
    })();

    // Search by name (reverse lookup)
    // 입력어로 마켓 자동 감지 (KR / US)
    function autoDetectMarket(query) {
        const q = query.trim();
        // 6자리 숫자 → 한국 종목코드
        if (/^\d{6}$/.test(q)) return 'KR';
        // 한국 종목명 정확 매칭
        for (const [, name] of Object.entries(KR_STOCK_NAMES)) {
            if (name === q || name.toLowerCase() === q.toLowerCase()) return 'KR';
        }
        // 영문 티커 (알파벳/점/하이픈) → 미국
        if (/^[A-Za-z.\-]+$/.test(q)) return 'US';
        // 미국 종목 한글명 정확 매칭
        if (US_STOCK_NAMES[q]) return 'US';
        for (const [name] of Object.entries(US_STOCK_NAMES)) {
            if (name.toLowerCase() === q.toLowerCase()) return 'US';
        }
        // 한국 종목명 부분 매칭
        for (const [, name] of Object.entries(KR_STOCK_NAMES)) {
            if (name.includes(q)) return 'KR';
        }
        // 미국 종목 한글명 부분 매칭
        for (const [name] of Object.entries(US_STOCK_NAMES)) {
            if (name.includes(q)) return 'US';
        }
        return 'US'; // 기본값
    }

    function findKRCode(query) {
        const q = query.trim();
        if (/^\d{6}$/.test(q)) return q;
        // 정확 매칭
        for (const [code, name] of Object.entries(KR_STOCK_NAMES)) {
            if (name === q || name.toLowerCase() === q.toLowerCase()) return code;
        }
        // 부분 매칭 (입력어를 포함하는 종목)
        for (const [code, name] of Object.entries(KR_STOCK_NAMES)) {
            if (name.includes(q) || name.toLowerCase().includes(q.toLowerCase())) return code;
        }
        return q;
    }

    // 미국 주식 한글명 → 티커 변환
    function findUSTicker(query) {
        const q = query.trim();
        // 이미 영문 티커면 그대로
        if (/^[A-Za-z.\-]+$/.test(q)) return q.toUpperCase();
        // 정확 매칭
        if (US_STOCK_NAMES[q]) return US_STOCK_NAMES[q];
        // 대소문자 무시 매칭
        for (const [name, ticker] of Object.entries(US_STOCK_NAMES)) {
            if (name.toLowerCase() === q.toLowerCase()) return ticker;
        }
        // 부분 매칭
        for (const [name, ticker] of Object.entries(US_STOCK_NAMES)) {
            if (name.includes(q) || q.includes(name)) return ticker;
        }
        return q.toUpperCase();
    }

    // ========================================
    // Levenshtein 거리 (퍼지 검색용)
    // ========================================
    function levenshtein(a, b) {
        if (a === b) return 0;
        if (!a.length) return b.length;
        if (!b.length) return a.length;
        let prev = Array.from({length: b.length + 1}, (_, i) => i);
        let curr = new Array(b.length + 1);
        for (let i = 1; i <= a.length; i++) {
            curr[0] = i;
            for (let j = 1; j <= b.length; j++) {
                const cost = a[i-1] === b[j-1] ? 0 : 1;
                curr[j] = Math.min(curr[j-1]+1, prev[j]+1, prev[j-1]+cost);
            }
            [prev, curr] = [curr, prev];
        }
        return prev[b.length];
    }

    // ========================================
    // 통합 자동완성 서제스트
    // Returns: [{ ticker, name, koreanName, market, type, sector, score }]
    // ========================================
    function searchSuggest(query, limit = 8) {
        const q = query.trim();
        if (!q) return [];
        const results = [], seen = new Set(), qLow = q.toLowerCase();
        const isNumericSix = /^\d{6}$/.test(q);
        const isEnglish = /^[A-Za-z.\-]+$/.test(q);

        function add(ticker, name, koreanName, market, type, sector, score) {
            const key = ticker + ':' + market;
            if (seen.has(key)) return;
            seen.add(key);
            results.push({ ticker, name, koreanName, market, type, sector, score });
        }

        // 1. 영문 티커 정확 매칭 (ETF 우선)
        if (isEnglish) {
            const up = q.toUpperCase();
            if (US_ETF_NAMES[up]) {
                const e = US_ETF_NAMES[up];
                add(up, e.name, e.korean[0]||up, 'US', 'etf', e.sector, 100);
            }
            const korEntry = Object.entries(US_STOCK_NAMES).find(([,v]) => v === up);
            if (korEntry) {
                const meta = ASSET_META[up] || {};
                add(up, up, korEntry[0], 'US', meta.type||'stock', meta.sector||'US', 100);
            }
        }
        // 2. 한국 코드 정확 매칭
        if (isNumericSix && KR_STOCK_NAMES[q]) {
            const meta = ASSET_META[q] || {};
            add(q, KR_STOCK_NAMES[q], KR_STOCK_NAMES[q], 'KR', meta.type||'stock', meta.sector||'한국주식', 100);
        }
        // 3. 한국 종목명 정확 매칭
        for (const [code, name] of Object.entries(KR_STOCK_NAMES)) {
            if (name.toLowerCase() === qLow) {
                const meta = ASSET_META[code] || {};
                add(code, name, name, 'KR', meta.type||'stock', meta.sector||'한국주식', 95);
            }
        }
        // 4. 미국 한글명 / ETF 한글명 정확 매칭
        if (!isEnglish) {
            if (US_STOCK_NAMES[q]) {
                const t = US_STOCK_NAMES[q], meta = ASSET_META[t]||{};
                add(t, t, q, 'US', meta.type||'stock', meta.sector||'US', 95);
            }
            for (const [ticker, etf] of Object.entries(US_ETF_NAMES)) {
                if (etf.korean.some(k => k.toLowerCase() === qLow))
                    add(ticker, etf.name, etf.korean[0], 'US', 'etf', etf.sector, 95);
            }
        }
        // 5. ETF 부분 매칭 (티커 시작, 이름 포함, 테마)
        for (const [ticker, etf] of Object.entries(US_ETF_NAMES)) {
            if (ticker.startsWith(q.toUpperCase()) ||
                etf.name.toLowerCase().includes(qLow) ||
                etf.korean.some(k => k.toLowerCase().includes(qLow)) ||
                etf.themes.some(t => t.toLowerCase().includes(qLow)))
                add(ticker, etf.name, etf.korean[0]||ticker, 'US', 'etf', etf.sector, 80);
        }
        // 6. 한국 부분 매칭
        for (const [code, name] of Object.entries(KR_STOCK_NAMES)) {
            if (name.toLowerCase().includes(qLow) || code.includes(q)) {
                const meta = ASSET_META[code] || {};
                add(code, name, name, 'KR', meta.type||'stock', meta.sector||'한국주식', 75);
            }
        }
        // 7. 미국 부분 매칭
        if (!isEnglish) {
            for (const [korName, ticker] of Object.entries(US_STOCK_NAMES)) {
                if (korName.toLowerCase().includes(qLow)) {
                    const meta = ASSET_META[ticker]||{};
                    add(ticker, ticker, korName, 'US', meta.type||'stock', meta.sector||'US', 70);
                }
            }
        } else {
            for (const [korName, ticker] of Object.entries(US_STOCK_NAMES)) {
                if (ticker.toUpperCase().startsWith(q.toUpperCase())) {
                    const meta = ASSET_META[ticker]||{};
                    add(ticker, ticker, korName, 'US', meta.type||'stock', meta.sector||'US', 70);
                }
            }
        }
        // 8. 퍼지 매칭 (결과 < 2개일 때만, 길이 ≥ 2)
        if (results.length < 2 && q.length >= 2) {
            const T = 2;
            for (const [code, name] of Object.entries(KR_STOCK_NAMES)) {
                const d = levenshtein(qLow, name.slice(0, q.length+2).toLowerCase());
                if (d <= T) { const m=ASSET_META[code]||{}; add(code, name, name, 'KR', m.type||'stock', m.sector||'한국주식', 60-d*10); }
            }
            if (!isEnglish) {
                for (const [korName, ticker] of Object.entries(US_STOCK_NAMES)) {
                    const d = levenshtein(qLow, korName.slice(0, q.length+2).toLowerCase());
                    if (d <= T) { const m=ASSET_META[ticker]||{}; add(ticker, ticker, korName, 'US', m.type||'stock', m.sector||'US', 60-d*10); }
                }
            }
        }
        results.sort((a,b) => b.score - a.score);
        return results.slice(0, limit);
    }

    // ========================================
    // ========================================
    // Backend API Proxy (Yahoo Finance URL → 백엔드 엔드포인트 매핑)
    // ========================================
    function mapToBackend(url) {
        const base = 'https://query1.finance.yahoo.com';
        if (!url.startsWith(base)) return url;
        const p = url.slice(base.length);

        // /v8/finance/chart/{symbol}?range=&interval=&includePrePost=
        const chartM = p.match(/^\/v8\/finance\/chart\/([^?]+)(\?.*)?$/);
        if (chartM) {
            const sym = chartM[1];
            const params = new URLSearchParams(chartM[2]?.slice(1) || '');
            const q = new URLSearchParams();
            ['range', 'interval', 'includePrePost'].forEach(k => { if (params.has(k)) q.set(k, params.get(k)); });
            return `${API_BASE}/api/chart/${sym}?${q}`;
        }

        // /v7/finance/quote?symbols=...
        if (p.startsWith('/v7/finance/quote')) {
            const params = new URLSearchParams(p.includes('?') ? p.split('?')[1] : '');
            return `${API_BASE}/api/quote?symbols=${params.get('symbols') || ''}`;
        }

        // /v10/finance/quoteSummary/{symbol}?modules=...
        const summaryM = p.match(/^\/v10\/finance\/quoteSummary\/([^?]+)(\?.*)?$/);
        if (summaryM) {
            const sym = summaryM[1];
            const params = new URLSearchParams(summaryM[2]?.slice(1) || '');
            return `${API_BASE}/api/summary/${sym}?modules=${params.get('modules') || ''}`;
        }

        // /v1/finance/screener/predefined/saved?scrIds={filter}&count=...
        if (p.startsWith('/v1/finance/screener')) {
            const params = new URLSearchParams(p.includes('?') ? p.split('?')[1] : '');
            return `${API_BASE}/api/screener/${params.get('scrIds') || ''}?count=${params.get('count') || 100}`;
        }

        return url;
    }

    async function fetchWithProxy(url, timeout = 8000) {
        const backendUrl = mapToBackend(url);
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), timeout);
        try {
            const res = await fetch(backendUrl, { signal: ctrl.signal });
            clearTimeout(timer);
            if (!res.ok) {
                const errData = await res.json().catch(() => ({}));
                throw new Error(errData.error || `서버 오류 (${res.status})`);
            }
            return await res.json();
        } catch(e) {
            clearTimeout(timer);
            if (e.name === 'AbortError') throw new Error('요청 시간이 초과되었습니다.');
            throw new Error(e.message || '데이터를 가져올 수 없습니다.');
        }
    }

    // ========================================
    // Search Stock
    // ========================================
    async function searchStock() {
        let query = document.getElementById('searchInput').value.trim();
        if (!query) { showToast('종목코드 또는 종목명을 입력해주세요.'); return; }

        // 마켓 자동 감지
        currentMarket = autoDetectMarket(query);
        document.querySelectorAll('.market-btn').forEach(b => b.classList.toggle('active', b.dataset.market === currentMarket));

        let symbol;
        if (currentMarket === 'KR') {
            const code = findKRCode(query);
            // Try KOSPI first, then KOSDAQ
            symbol = code + '.KS';
            currentSymbol = code;
        } else {
            symbol = findUSTicker(query);
            currentSymbol = symbol;
        }

        showLoading('주가 데이터를 불러오는 중...');

        try {
            // Fetch chart data
            const range = currentPeriod;
            const interval = currentInterval;
            // Yahoo Finance: includePrePost=true → 프리/애프터마켓 데이터 포함
            const chartUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${range}&interval=${interval}&includePrePost=true`;
            let data = await fetchWithProxy(chartUrl);

            // If KR stock fails with .KS, try .KQ (KOSDAQ)
            if (currentMarket === 'KR' && (!data.chart?.result || data.chart?.error)) {
                symbol = currentSymbol + '.KQ';
                const chartUrl2 = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${currentPeriod}&interval=${interval}&includePrePost=true`;
                data = await fetchWithProxy(chartUrl2);
            }

            if (!data.chart?.result?.[0]) {
                throw new Error('종목을 찾을 수 없습니다.');
            }

            stockData = data.chart.result[0];
            currentFullSymbol = symbol;  // 실시간 업데이트용 풀 심볼 저장

            // Show stock UI, hide welcome
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('stockHero').classList.add('show');
            document.getElementById('tabNav').classList.add('show');
            switchTab('chart');

            // 즉시 렌더링 → 로딩 해제
            renderStockHeader(symbol);
            updateFavButton();
            renderPriceChart();
            hideLoading();

            // 로컬 계산 지표 (빠름)
            renderTechnicalIndicators();
            renderRSIChart();
            renderMACDChart();
            renderStochChart();
            renderADXChart();
            renderCCIChart();
            renderOBVChart();
            renderEntryTiming();
            renderExitTiming();
            renderAIAnalysis();
            renderRRAnalysis();
            renderVolumeChart();

            // 추가 API 호출이 필요한 것들은 병렬로 실행 (await 안 함 → UI 블로킹 없음)
            fetchMarketSession(symbol);
            renderFinancialInfo(symbol);
            renderStockEarnings(symbol);
            renderCompanyProfile(symbol);

            // 실시간 가격 업데이트 시작 (30초 간격)
            startLiveUpdate();
            // 분석 자동 갱신 시작 (5분 간격)
            startAnalysisRefresh();

        } catch(err) {
            showToast(err.message || '데이터를 불러오는데 실패했습니다.');
        } finally {
            hideLoading();
        }
    }

    // ========================================
    // Render Stock Header
    // ========================================
    function renderStockHeader(symbol) {
        const meta = stockData.meta;
        const quotes = stockData.indicators.quote[0];
        const closes = quotes.close.filter(v => v != null);
        // meta에서 실시간 가격 우선 사용 (차트 데이터보다 정확)
        const price = meta.regularMarketPrice ?? closes[closes.length - 1];
        const prevClose = meta.chartPreviousClose ?? meta.previousClose ?? (closes.length > 1 ? closes[closes.length - 2] : price);
        const change = price - prevClose;
        const changePercent = prevClose ? (change / prevClose * 100) : 0;

        let name = meta.symbol;
        if (currentMarket === 'KR') {
            const code = currentSymbol;
            name = KR_STOCK_NAMES[code] || meta.symbol.replace('.KS','').replace('.KQ','');
            document.getElementById('stockCode').textContent = `${code} · ${meta.exchangeName || 'KRX'}`;
        } else {
            name = meta.symbol;
            document.getElementById('stockCode').textContent = `${meta.symbol} · ${meta.exchangeName || 'US'}`;
        }

        document.getElementById('stockName').textContent = name;

        const isKR = currentMarket === 'KR';
        const formatted = isKR
            ? Math.round(price).toLocaleString() + '원'
            : '$' + price.toFixed(2);
        document.getElementById('stockPrice').textContent = formatted;

        const changeEl = document.getElementById('stockChange');
        const sign = change >= 0 ? '+' : '';
        const changeText = isKR
            ? `${sign}${Math.round(change).toLocaleString()}원 (${sign}${changePercent.toFixed(2)}%)`
            : `${sign}$${change.toFixed(2)} (${sign}${changePercent.toFixed(2)}%)`;
        changeEl.textContent = changeText;
        changeEl.className = 'stock-change ' + (change > 0 ? 'up' : change < 0 ? 'down' : 'flat');
        document.getElementById('stockPrice').style.color = change > 0 ? 'var(--red)' : change < 0 ? 'var(--blue)' : 'var(--text)';
    }

    // ========================================
    // Market Session (프리장 / 정규장 / 애프터장)
    // ========================================
    async function fetchMarketSession(symbol) {
        const container = document.getElementById('marketSessionInfo');
        container.innerHTML = '';
        container.classList.remove('show');

        try {
            // Yahoo Finance quote endpoint - 프리/정규/애프터 가격 포함 (fetchRace로 빠르게)
            const quoteUrl = `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbol}`;
            const data = await fetchRace(quoteUrl, 8000);
            const q = data?.quoteResponse?.result?.[0];
            if (!q) return;

            const isKR = currentMarket === 'KR';
            const fmtP = v => {
                if (v == null) return '-';
                return isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2);
            };
            const fmtChg = (chg, pct) => {
                if (chg == null) return { text: '-', cls: 'flat' };
                const s = chg >= 0 ? '+' : '';
                const p = pct != null ? ` (${s}${pct.toFixed(2)}%)` : '';
                const t = isKR
                    ? `${s}${Math.round(chg).toLocaleString()}원${p}`
                    : `${s}$${chg.toFixed(2)}${p}`;
                return { text: t, cls: chg > 0 ? 'up' : chg < 0 ? 'down' : 'flat' };
            };
            const fmtTime = ts => {
                if (!ts) return '';
                const d = new Date(ts * 1000);
                const h = d.getHours().toString().padStart(2,'0');
                const m = d.getMinutes().toString().padStart(2,'0');
                return `${h}:${m}`;
            };

            const state = q.marketState; // PRE, REGULAR, POST, PREPRE, POSTPOST, CLOSED
            const badges = [];

            // 정규장 가격 (항상 표시)
            const regPrice = q.regularMarketPrice;
            const regChg = q.regularMarketChange;
            const regPct = q.regularMarketChangePercent;
            const regTime = q.regularMarketTime;
            const regC = fmtChg(regChg, regPct);

            const isOpen = state === 'REGULAR';
            badges.push(`
                <div class="session-badge">
                    <span class="session-dot ${isOpen ? 'regular' : 'closed'}"></span>
                    <div>
                        <div class="session-label">${isOpen ? '🟢 정규장 거래중' : '정규장 마감'}</div>
                        <div class="session-price">${fmtP(regPrice)}</div>
                        <div class="session-time">${fmtTime(regTime)}</div>
                    </div>
                    <div class="session-change ${regC.cls}">${regC.text}</div>
                </div>
            `);

            // 프리마켓 (장 시작 전)
            const prePrice = q.preMarketPrice;
            if (prePrice != null) {
                const preChg = q.preMarketChange;
                const prePct = q.preMarketChangePercent;
                const preTime = q.preMarketTime;
                const preC = fmtChg(preChg, prePct);
                const isPreLive = (state === 'PRE' || state === 'PREPRE');
                badges.push(`
                    <div class="session-badge">
                        <span class="session-dot ${isPreLive ? 'pre' : 'closed'}"></span>
                        <div>
                            <div class="session-label">${isPreLive ? '🟣 프리마켓 거래중' : '프리마켓'}</div>
                            <div class="session-price">${fmtP(prePrice)}</div>
                            <div class="session-time">${fmtTime(preTime)}</div>
                        </div>
                        <div class="session-change ${preC.cls}">${preC.text}</div>
                    </div>
                `);
            }

            // 애프터마켓 (장 마감 후)
            const postPrice = q.postMarketPrice;
            if (postPrice != null) {
                const postChg = q.postMarketChange;
                const postPct = q.postMarketChangePercent;
                const postTime = q.postMarketTime;
                const postC = fmtChg(postChg, postPct);
                const isPostLive = (state === 'POST' || state === 'POSTPOST');
                badges.push(`
                    <div class="session-badge">
                        <span class="session-dot ${isPostLive ? 'post' : 'closed'}"></span>
                        <div>
                            <div class="session-label">${isPostLive ? '🟡 애프터마켓 거래중' : '애프터마켓'}</div>
                            <div class="session-price">${fmtP(postPrice)}</div>
                            <div class="session-time">${fmtTime(postTime)}</div>
                        </div>
                        <div class="session-change ${postC.cls}">${postC.text}</div>
                    </div>
                `);
            }

            if (badges.length > 0) {
                container.innerHTML = badges.join('');
                container.classList.add('show');
            }

            // 헤더 가격을 quote API 기준으로 동기화
            // 현재 활성 세션 가격 우선 표시: PRE → preMarketPrice, POST → postMarketPrice, 그 외 → regularMarketPrice
            // 참고: marketState가 CLOSED/PREPRE여도 preMarketPrice가 있으면 프리마켓 진행 중
            let livePrice = regPrice;
            let liveChg = regChg;
            let livePct = regPct;
            let livePrev = q.regularMarketPreviousClose ?? (regPrice - regChg);

            // 프리마켓 가격이 존재하고, 정규장이 아닌 경우 → 프리마켓 가격 표시
            if (state !== 'REGULAR' && prePrice != null && q.preMarketChange != null) {
                livePrice = prePrice;
                liveChg = q.preMarketChange;
                livePct = q.preMarketChangePercent;
                livePrev = regPrice;
            }
            // 애프터마켓 가격이 존재하고, 정규장이 아닌 경우 → 애프터마켓 가격 표시
            // (프리마켓보다 애프터마켓이 우선되진 않으므로, 둘 다 있으면 프리 우선)
            else if (state !== 'REGULAR' && postPrice != null && q.postMarketChange != null) {
                livePrice = postPrice;
                liveChg = q.postMarketChange;
                livePct = q.postMarketChangePercent;
                livePrev = regPrice;
            }

            if (livePrice != null) {
                const priceEl = document.getElementById('stockPrice');
                const changeEl = document.getElementById('stockChange');
                priceEl.textContent = fmtP(livePrice);
                const sign = liveChg >= 0 ? '+' : '';
                changeEl.textContent = isKR
                    ? `${sign}${Math.round(liveChg).toLocaleString()}원 (${sign}${livePct.toFixed(2)}%)`
                    : `${sign}$${liveChg.toFixed(2)} (${sign}${livePct.toFixed(2)}%)`;
                changeEl.className = 'stock-change ' + (liveChg > 0 ? 'up' : liveChg < 0 ? 'down' : 'flat');
                priceEl.style.color = liveChg > 0 ? 'var(--red)' : liveChg < 0 ? 'var(--blue)' : 'var(--text)';
            }
        } catch(e) {
            // 실패해도 무시 - 메인 기능에 영향 없음
        }
    }

    // ========================================
    // Analysis Auto-Refresh (5분 자동 분석 갱신)
    // ========================================
    function updateAnalysisTimestamp() {
        const el = document.getElementById('analysisRefreshTime');
        if (!el) return;
        const now = new Date();
        const hh  = now.getHours().toString().padStart(2, '0');
        const mm  = now.getMinutes().toString().padStart(2, '0');
        el.textContent = `마지막 갱신 ${hh}:${mm}`;
    }

    function stopAnalysisRefresh() {
        if (analysisRefreshTimer) { clearInterval(analysisRefreshTimer); analysisRefreshTimer = null; }
        const bar = document.getElementById('analysisRefreshBar');
        if (bar) bar.style.display = 'none';
    }

    async function runAnalysisRefresh() {
        if (!currentFullSymbol) return;
        try {
            const chartUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${currentFullSymbol}` +
                `?range=${currentPeriod}&interval=${currentInterval}&includePrePost=true`;
            const data = await fetchWithProxy(chartUrl);
            if (!data.chart?.result?.[0]) return;
            stockData = data.chart.result[0];

            // 분석 관련 함수만 재실행 (차트 전체 재렌더 제외 → 줌/팬 유지)
            renderTechnicalIndicators();
            renderRSIChart();
            renderMACDChart();
            renderStochChart();
            renderADXChart();
            renderCCIChart();
            renderOBVChart();
            renderEntryTiming();
            renderExitTiming();
            renderAIAnalysis();
            renderRRAnalysis();
            renderVolumeChart();
            updateAnalysisTimestamp();
        } catch(e) { /* 네트워크 오류 시 조용히 무시 */ }
    }

    async function manualAnalysisRefresh() {
        const btn = document.getElementById('analysisRefreshBtn');
        if (btn) { btn.classList.add('spinning'); btn.textContent = '갱신 중...'; }
        await runAnalysisRefresh();
        if (btn) { btn.classList.remove('spinning'); btn.textContent = '↻ 지금 갱신'; }
    }

    function startAnalysisRefresh() {
        stopAnalysisRefresh();
        const bar = document.getElementById('analysisRefreshBar');
        if (bar) bar.style.display = 'flex';
        updateAnalysisTimestamp(); // 분석 직후 초기 타임스탬프 설정
        analysisRefreshTimer = window.setInterval(runAnalysisRefresh, 5 * 60 * 1000); // 5분
    }

    // ========================================
    // Live Price Update (실시간 가격 업데이트)
    // ========================================
    function stopLiveUpdate() {
        if (liveUpdateTimer) { clearInterval(liveUpdateTimer); liveUpdateTimer = null; }
    }

    function startLiveUpdate() {
        stopLiveUpdate();
        // 30초마다 헤더 가격 + 차트 캔들 + 세션 뱃지 업데이트
        liveUpdateTimer = window.setInterval(async () => {
            if (!currentFullSymbol) return;
            try {
                const quoteUrl = `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${currentFullSymbol}`;
                const data = await fetchRace(quoteUrl, 6000);
                const q = data?.quoteResponse?.result?.[0];
                if (!q) return;

                const state = q.marketState;
                const isKR = currentMarket === 'KR';
                const regPrice = q.regularMarketPrice;
                const prePrice = q.preMarketPrice;
                const postPrice = q.postMarketPrice;

                let livePrice = regPrice;
                let liveChg = q.regularMarketChange;
                let livePct = q.regularMarketChangePercent;

                if (state !== 'REGULAR' && prePrice != null && q.preMarketChange != null) {
                    livePrice = prePrice;
                    liveChg = q.preMarketChange;
                    livePct = q.preMarketChangePercent;
                } else if (state !== 'REGULAR' && postPrice != null && q.postMarketChange != null) {
                    livePrice = postPrice;
                    liveChg = q.postMarketChange;
                    livePct = q.postMarketChangePercent;
                }

                // 헤더 가격 업데이트
                const fmtP = v => isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2);
                const priceEl = document.getElementById('stockPrice');
                const changeEl = document.getElementById('stockChange');
                if (priceEl && livePrice != null) {
                    priceEl.textContent = fmtP(livePrice);
                    const sign = liveChg >= 0 ? '+' : '';
                    changeEl.textContent = isKR
                        ? `${sign}${Math.round(liveChg).toLocaleString()}원 (${sign}${livePct.toFixed(2)}%)`
                        : `${sign}$${liveChg.toFixed(2)} (${sign}${livePct.toFixed(2)}%)`;
                    changeEl.className = 'stock-change ' + (liveChg > 0 ? 'up' : liveChg < 0 ? 'down' : 'flat');
                    priceEl.style.color = liveChg > 0 ? 'var(--red)' : liveChg < 0 ? 'var(--blue)' : 'var(--text)';
                }

                // 차트 마지막 캔들 업데이트
                if (lwCandleSeries && regPrice != null && stockData?.timestamp?.length) {
                    const lastTs = stockData.timestamp[stockData.timestamp.length - 1];
                    const lastQ = stockData.indicators.quote[0];
                    const lastIdx = lastQ.close.length - 1;
                    const open = lastQ.open[lastIdx] ?? regPrice;
                    const high = Math.max(lastQ.high[lastIdx] ?? regPrice, regPrice);
                    const low = Math.min(lastQ.low[lastIdx] ?? regPrice, regPrice);
                    lwCandleSeries.update({ time: lastTs, open, high, low, close: regPrice });
                    if (lwVolumeSeries) {
                        lwVolumeSeries.update({
                            time: lastTs,
                            value: q.regularMarketVolume || lastQ.volume[lastIdx] || 0,
                            color: regPrice >= open ? 'rgba(239,68,68,0.25)' : 'rgba(59,130,246,0.25)',
                        });
                    }
                }

                // 세션 뱃지 갱신
                fetchMarketSession(currentFullSymbol);
            } catch(e) {}
        }, 30000);
    }

    // ========================================
    // Technical Calculations
    // ========================================
    function calcSMA(data, period) {
        const result = [];
        for (let i = 0; i < data.length; i++) {
            if (i < period - 1) { result.push(null); continue; }
            let sum = 0, count = 0;
            for (let j = i - period + 1; j <= i; j++) {
                if (data[j] != null) { sum += data[j]; count++; }
            }
            result.push(count > 0 ? sum / count : null);
        }
        return result;
    }

    function calcEMA(data, period) {
        const result = [];
        const k = 2 / (period + 1);
        let ema = null;
        for (let i = 0; i < data.length; i++) {
            if (data[i] == null) { result.push(null); continue; }
            if (ema === null) { ema = data[i]; }
            else { ema = data[i] * k + ema * (1 - k); }
            result.push(ema);
        }
        return result;
    }

    function calcRSI(closes, period = 14) {
        const rsi = [];
        let avgGain = 0, avgLoss = 0;
        for (let i = 0; i < closes.length; i++) {
            if (i === 0 || closes[i] == null || closes[i-1] == null) { rsi.push(null); continue; }
            const change = closes[i] - closes[i-1];
            const gain = change > 0 ? change : 0;
            const loss = change < 0 ? -change : 0;

            if (i <= period) {
                avgGain += gain;
                avgLoss += loss;
                if (i === period) {
                    avgGain /= period;
                    avgLoss /= period;
                    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    rsi.push(100 - 100 / (1 + rs));
                } else {
                    rsi.push(null);
                }
            } else {
                avgGain = (avgGain * (period - 1) + gain) / period;
                avgLoss = (avgLoss * (period - 1) + loss) / period;
                const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                rsi.push(100 - 100 / (1 + rs));
            }
        }
        return rsi;
    }

    function calcMACD(closes) {
        const ema12 = calcEMA(closes, 12);
        const ema26 = calcEMA(closes, 26);
        const macdLine = ema12.map((v, i) => (v != null && ema26[i] != null) ? v - ema26[i] : null);
        const signalLine = calcEMA(macdLine.map(v => v ?? 0), 9);
        const histogram = macdLine.map((v, i) => (v != null && signalLine[i] != null) ? v - signalLine[i] : null);
        return { macdLine, signalLine, histogram };
    }

    function calcBollingerBands(closes, period = 20, mult = 2) {
        const sma = calcSMA(closes, period);
        const upper = [], lower = [];
        for (let i = 0; i < closes.length; i++) {
            if (sma[i] == null) { upper.push(null); lower.push(null); continue; }
            let sumSq = 0, count = 0;
            for (let j = i - period + 1; j <= i; j++) {
                if (closes[j] != null) { sumSq += Math.pow(closes[j] - sma[i], 2); count++; }
            }
            const std = Math.sqrt(sumSq / count);
            upper.push(sma[i] + mult * std);
            lower.push(sma[i] - mult * std);
        }
        return { upper, middle: sma, lower };
    }

    // Stochastic Oscillator (%K, %D)
    function calcStochastic(highs, lows, closes, kPeriod = 14, dPeriod = 3) {
        const kLine = [], dLine = [];
        for (let i = 0; i < closes.length; i++) {
            if (i < kPeriod - 1) { kLine.push(null); continue; }
            let hh = -Infinity, ll = Infinity;
            for (let j = i - kPeriod + 1; j <= i; j++) {
                if (highs[j] != null) hh = Math.max(hh, highs[j]);
                if (lows[j] != null) ll = Math.min(ll, lows[j]);
            }
            const k = hh === ll ? 50 : ((closes[i] - ll) / (hh - ll)) * 100;
            kLine.push(k);
        }
        for (let i = 0; i < kLine.length; i++) {
            if (i < kPeriod - 1 + dPeriod - 1 || kLine[i] == null) { dLine.push(null); continue; }
            let sum = 0, cnt = 0;
            for (let j = i - dPeriod + 1; j <= i; j++) {
                if (kLine[j] != null) { sum += kLine[j]; cnt++; }
            }
            dLine.push(cnt > 0 ? sum / cnt : null);
        }
        return { kLine, dLine };
    }

    // OBV (On Balance Volume)
    function calcOBV(closes, volumes) {
        const obv = [0];
        for (let i = 1; i < closes.length; i++) {
            if (closes[i] == null || closes[i-1] == null || volumes[i] == null) {
                obv.push(obv[obv.length-1]); continue;
            }
            if (closes[i] > closes[i-1]) obv.push(obv[obv.length-1] + volumes[i]);
            else if (closes[i] < closes[i-1]) obv.push(obv[obv.length-1] - volumes[i]);
            else obv.push(obv[obv.length-1]);
        }
        return obv;
    }

    // ── 불리시 다이버전스 탐지 ─────────────────────────────────────────────────
    function detectBullishDivergence(closes, rsiArr, lookback = 40) {
        const result = { detected: false, rsiDiff: 0 };
        if (!closes || !rsiArr || closes.length < lookback + 4) return result;
        const len = closes.length;
        const start = Math.max(2, len - lookback);
        const minima = [];
        for (let i = start; i < len - 2; i++) {
            if (closes[i] == null || rsiArr[i] == null) continue;
            if (closes[i] < closes[i-1] && closes[i] < closes[i-2] &&
                closes[i] < closes[i+1] && closes[i] < closes[i+2]) {
                minima.push({ price: closes[i], rsi: rsiArr[i] });
            }
        }
        if (minima.length < 2) return result;
        const m1 = minima[minima.length - 2]; // 이전 저점
        const m2 = minima[minima.length - 1]; // 최근 저점
        if (m2.price < m1.price && m2.rsi > m1.rsi) {
            result.detected = true;
            result.rsiDiff = m2.rsi - m1.rsi;
        }
        return result;
    }

    // ── OBV 패닉 투매 감지 ──────────────────────────────────────────────────────
    function _detectOBVPanic(obvArr, volumes, closes, period = 10) {
        const result = { panicSell: false, obvDeclining: false, volSpike: false };
        if (!obvArr || obvArr.length < period + 2) return result;
        const len = obvArr.length;
        const half = Math.floor(period / 2);
        const obvRecent  = obvArr.slice(len - half).reduce((a,b) => a+b, 0) / half;
        const obvEarlier = obvArr.slice(len - period, len - half).reduce((a,b) => a+b, 0) / half;
        result.obvDeclining = obvRecent < obvEarlier;
        const volSlice = volumes.slice(-period - 1, -1).filter(v => v != null);
        if (volSlice.length > 0) {
            const avgVol = volSlice.reduce((a,b) => a+b, 0) / volSlice.length;
            const lastVol = volumes[volumes.length - 1];
            result.volSpike = lastVol != null && lastVol > avgVol * 1.8;
        }
        result.panicSell = result.obvDeclining && result.volSpike;
        return result;
    }

    // ADX (Average Directional Index)
    function calcADX(highs, lows, closes, period = 14) {
        const pDI = [], mDI = [], adx = [];
        const trList = [], pDMList = [], mDMList = [];
        for (let i = 0; i < closes.length; i++) {
            if (i === 0 || highs[i]==null || lows[i]==null || closes[i-1]==null) {
                trList.push(null); pDMList.push(null); mDMList.push(null);
                pDI.push(null); mDI.push(null); adx.push(null);
                continue;
            }
            const tr = Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1]));
            const upMove = highs[i] - (highs[i-1]||0);
            const downMove = (lows[i-1]||0) - lows[i];
            trList.push(tr);
            pDMList.push(upMove > downMove && upMove > 0 ? upMove : 0);
            mDMList.push(downMove > upMove && downMove > 0 ? downMove : 0);
            if (i < period) { pDI.push(null); mDI.push(null); adx.push(null); continue; }
            if (i === period) {
                let sTR=0, sPDM=0, sMDM=0;
                for(let j=1;j<=period;j++){sTR+=(trList[j]||0);sPDM+=(pDMList[j]||0);sMDM+=(mDMList[j]||0);}
                const p = sTR===0?0:(sPDM/sTR)*100, m = sTR===0?0:(sMDM/sTR)*100;
                pDI.push(p); mDI.push(m);
                const dx = (p+m)===0?0:Math.abs(p-m)/(p+m)*100;
                adx.push(dx);
            } else {
                const prevPDI = pDI[pDI.length-1]||0, prevMDI = mDI[mDI.length-1]||0;
                const smoothTR = (trList.slice(i-period+1,i+1).reduce((a,b)=>a+(b||0),0));
                const p = smoothTR===0?0:(pDMList.slice(i-period+1,i+1).reduce((a,b)=>a+(b||0),0)/smoothTR)*100;
                const m = smoothTR===0?0:(mDMList.slice(i-period+1,i+1).reduce((a,b)=>a+(b||0),0)/smoothTR)*100;
                pDI.push(p); mDI.push(m);
                const dx = (p+m)===0?0:Math.abs(p-m)/(p+m)*100;
                const prevADX = adx.filter(v=>v!=null).pop() || dx;
                adx.push(((prevADX*(period-1))+dx)/period);
            }
        }
        return { pDI, mDI, adx };
    }

    // VWAP (Volume Weighted Average Price)
    function calcVWAP(highs, lows, closes, volumes) {
        const vwap = [];
        let cumVol = 0, cumTP = 0;
        for (let i = 0; i < closes.length; i++) {
            if (closes[i]==null||highs[i]==null||lows[i]==null||volumes[i]==null) { vwap.push(null); continue; }
            const tp = (highs[i]+lows[i]+closes[i])/3;
            cumTP += tp * volumes[i];
            cumVol += volumes[i];
            vwap.push(cumVol > 0 ? cumTP/cumVol : null);
        }
        return vwap;
    }

    // ATR (Average True Range)
    function calcATR(highs, lows, closes, period = 14) {
        const tr = [], atr = [];
        for (let i = 0; i < closes.length; i++) {
            if (i===0||highs[i]==null||lows[i]==null||closes[i-1]==null) { tr.push(null); atr.push(null); continue; }
            tr.push(Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1])));
            if (i < period) { atr.push(null); continue; }
            if (i === period) {
                let sum=0; for(let j=1;j<=period;j++) sum+=(tr[j]||0);
                atr.push(sum/period);
            } else {
                const prev = atr.filter(v=>v!=null).pop()||0;
                atr.push((prev*(period-1)+(tr[i]||0))/period);
            }
        }
        return atr;
    }

    // ========================================
    // Volume Profile & Resistance Detection
    // ========================================
    function calcVolumeProfile(closes, volumes, period, buckets = 20) {
        const n = Math.min(period, closes.length, volumes.length);
        const s = closes.slice(-n), v = volumes.slice(-n);
        const lo = Math.min(...s), hi = Math.max(...s);
        if (hi === lo) return [{ priceCenter: hi, volume: v.reduce((a,b)=>a+b, 0) }];
        const bsz = (hi - lo) / buckets;
        const profile = Array.from({length: buckets}, (_, i) => ({
            priceCenter: lo + (i + 0.5) * bsz, volume: 0
        }));
        for (let i = 0; i < s.length; i++) {
            const idx = Math.min(Math.floor((s[i] - lo) / bsz), buckets - 1);
            profile[idx].volume += (v[i] || 0);
        }
        return profile;
    }

    function findResistanceLevels(profile, currentPrice) {
        const above = profile.filter(b => b.priceCenter > currentPrice);
        if (!above.length) return [];
        const peaks = above.filter((b, i, arr) => {
            const prev = arr[i-1] ? arr[i-1].volume : 0;
            const next = arr[i+1] ? arr[i+1].volume : 0;
            return b.volume >= prev && b.volume >= next && b.volume > 0;
        });
        const pool = peaks.length ? peaks : [...above].sort((a,b)=>b.volume-a.volume).slice(0,2);
        return pool.sort((a,b)=>a.priceCenter-b.priceCenter).slice(0,2).map(b=>b.priceCenter);
    }

    // CCI (Commodity Channel Index)
    function calcCCI(highs, lows, closes, period = 20) {
        const cci = [];
        for (let i = 0; i < closes.length; i++) {
            if (i < period-1||closes[i]==null) { cci.push(null); continue; }
            const tps = [];
            for (let j=i-period+1;j<=i;j++) {
                if(highs[j]!=null&&lows[j]!=null&&closes[j]!=null) tps.push((highs[j]+lows[j]+closes[j])/3);
            }
            if (tps.length < period) { cci.push(null); continue; }
            const mean = tps.reduce((a,b)=>a+b,0)/tps.length;
            const md = tps.reduce((a,b)=>a+Math.abs(b-mean),0)/tps.length;
            const tp = (highs[i]+lows[i]+closes[i])/3;
            cci.push(md===0 ? 0 : (tp-mean)/(0.015*md));
        }
        return cci;
    }

    // Williams %R
    function calcWilliamsR(highs, lows, closes, period = 14) {
        const wr = [];
        for (let i = 0; i < closes.length; i++) {
            if (i < period-1) { wr.push(null); continue; }
            let hh = -Infinity, ll = Infinity;
            for (let j=i-period+1;j<=i;j++) {
                if(highs[j]!=null) hh=Math.max(hh,highs[j]);
                if(lows[j]!=null) ll=Math.min(ll,lows[j]);
            }
            wr.push(hh===ll ? -50 : ((hh-closes[i])/(hh-ll))*-100);
        }
        return wr;
    }

    // MFI (Money Flow Index)
    function calcMFI(highs, lows, closes, volumes, period = 14) {
        const mfi = [];
        const tps = closes.map((c,i) => (highs[i]!=null&&lows[i]!=null&&c!=null) ? (highs[i]+lows[i]+c)/3 : null);
        for (let i = 0; i < closes.length; i++) {
            if (i < period) { mfi.push(null); continue; }
            let posFlow=0, negFlow=0;
            for (let j=i-period+1;j<=i;j++) {
                if(tps[j]==null||tps[j-1]==null||volumes[j]==null) continue;
                const mf = tps[j]*volumes[j];
                if(tps[j]>tps[j-1]) posFlow+=mf; else negFlow+=mf;
            }
            const ratio = negFlow===0 ? 100 : posFlow/negFlow;
            mfi.push(100 - 100/(1+ratio));
        }
        return mfi;
    }

    // ========================================
    // Render Price Chart (Lightweight Charts)
    function toggleChartFullscreen() {
        const card = document.getElementById('tvChartCard');
        const iconExpand = document.getElementById('tvFsIconExpand');
        const iconShrink = document.getElementById('tvFsIconShrink');
        card.classList.toggle('fullscreen');
        const isFull = card.classList.contains('fullscreen');
        iconExpand.style.display = isFull ? 'none' : '';
        iconShrink.style.display = isFull ? '' : 'none';
        document.body.style.overflow = isFull ? 'hidden' : '';
        // 전체화면 전환 시 차트 리사이즈
        if (lwChart) {
            setTimeout(() => {
                const wrap = document.getElementById('tvChartWrap');
                if (wrap) lwChart.applyOptions({ width: wrap.clientWidth, height: wrap.clientHeight });
            }, 50);
        }
    }

    // ESC 키로 전체화면 해제
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            const card = document.getElementById('tvChartCard');
            if (card?.classList.contains('fullscreen')) toggleChartFullscreen();
        }
    });

    // 차트 리사이즈 옵저버
    let lwResizeObserver = null;

    function destroyChart() {
        if (lwResizeObserver) { lwResizeObserver.disconnect(); lwResizeObserver = null; }
        if (lwChart) { lwChart.remove(); lwChart = null; }
        lwCandleSeries = null;
        lwVolumeSeries = null;
        lwMaSeries = {};
        lwBbUpper = null;
        lwBbLower = null;
        lwAiOverlaySeries = [];
    }

    function renderPriceChart() {
        const wrap = document.getElementById('tvChartWrap');
        if (!wrap || !stockData) return;

        // 기존 차트 정리
        destroyChart();
        wrap.innerHTML = '';

        const ts = stockData.timestamp;
        const q = stockData.indicators.quote[0];
        if (!ts || !q) return;

        // 현재 테마 감지
        const isLight = document.documentElement.getAttribute('data-theme') === 'light';
        const chartBg = isLight ? '#ffffff' : '#111620';
        const chartText = isLight ? '#4a5568' : '#94a3b8';
        const chartGrid = isLight ? 'rgba(0,0,0,0.06)' : 'rgba(45,58,77,0.2)';

        // 차트 생성
        lwChart = LightweightCharts.createChart(wrap, {
            width: wrap.clientWidth,
            height: wrap.clientHeight,
            layout: {
                background: { type: 'solid', color: chartBg },
                textColor: chartText,
                fontSize: 12,
            },
            grid: {
                vertLines: { color: chartGrid },
                horzLines: { color: chartGrid },
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
                vertLine: { color: 'rgba(59,130,246,0.3)', width: 1, style: 2 },
                horzLine: { color: 'rgba(59,130,246,0.3)', width: 1, style: 2 },
            },
            rightPriceScale: {
                borderColor: 'rgba(45,58,77,0.3)',
                scaleMargins: { top: 0.05, bottom: 0.25 },
            },
            timeScale: {
                borderColor: 'rgba(45,58,77,0.3)',
                timeVisible: isIntraday(currentInterval),
                secondsVisible: false,
                rightOffset: 5,
                barSpacing: 8,
            },
            localization: {
                locale: 'ko-KR',
                priceFormatter: price => {
                    if (currentMarket === 'KR') return Math.round(price).toLocaleString();
                    return price.toFixed(2);
                },
            },
        });

        // 캔들스틱 시리즈
        lwCandleSeries = lwChart.addCandlestickSeries({
            upColor: '#ef4444',
            downColor: '#3b82f6',
            borderUpColor: '#ef4444',
            borderDownColor: '#3b82f6',
            wickUpColor: '#ef4444',
            wickDownColor: '#3b82f6',
        });

        // 거래량 시리즈
        lwVolumeSeries = lwChart.addHistogramSeries({
            priceFormat: { type: 'volume' },
            priceScaleId: 'volume',
        });
        lwChart.priceScale('volume').applyOptions({
            scaleMargins: { top: 0.8, bottom: 0 },
        });

        // 데이터 변환
        const candleData = [];
        const volumeData = [];

        for (let i = 0; i < ts.length; i++) {
            const o = q.open[i], h = q.high[i], l = q.low[i], c = q.close[i], v = q.volume[i];
            if (o == null || h == null || l == null || c == null) continue;

            const time = isIntraday(currentInterval) ? ts[i] : ts[i]; // UTC timestamp

            candleData.push({ time, open: o, high: h, low: l, close: c });
            volumeData.push({
                time,
                value: v || 0,
                color: c >= o ? 'rgba(239,68,68,0.25)' : 'rgba(59,130,246,0.25)',
            });
        }

        lwCandleSeries.setData(candleData);
        lwVolumeSeries.setData(volumeData);

        // 이동평균선 추가
        const closes = q.close;
        const maConfigs = [
            { period: 5, color: '#eab308', key: 'ma5' },
            { period: 20, color: '#a78bfa', key: 'ma20' },
            { period: 60, color: '#22c55e', key: 'ma60' },
            { period: 120, color: '#ef4444', key: 'ma120' },
        ];

        maConfigs.forEach(({ period, color, key }) => {
            const sma = calcSMA(closes, period);
            const maData = [];
            for (let i = 0; i < ts.length; i++) {
                if (sma[i] == null) continue;
                maData.push({ time: ts[i], value: sma[i] });
            }
            if (maData.length > 0) {
                const series = lwChart.addLineSeries({
                    color,
                    lineWidth: 1,
                    priceLineVisible: false,
                    lastValueVisible: false,
                    crosshairMarkerVisible: false,
                });
                series.setData(maData);
                lwMaSeries[key] = series;
            }
        });

        // 볼린저 밴드
        const bb = calcBollingerBands(closes, 20, 2);
        if (bb.upper.some(v => v != null)) {
            const upperData = [], lowerData = [];
            for (let i = 0; i < ts.length; i++) {
                if (bb.upper[i] != null) upperData.push({ time: ts[i], value: bb.upper[i] });
                if (bb.lower[i] != null) lowerData.push({ time: ts[i], value: bb.lower[i] });
            }
            lwBbUpper = lwChart.addLineSeries({
                color: 'rgba(34,211,238,0.4)',
                lineWidth: 1,
                lineStyle: 2,
                priceLineVisible: false,
                lastValueVisible: false,
                crosshairMarkerVisible: false,
            });
            lwBbLower = lwChart.addLineSeries({
                color: 'rgba(34,211,238,0.4)',
                lineWidth: 1,
                lineStyle: 2,
                priceLineVisible: false,
                lastValueVisible: false,
                crosshairMarkerVisible: false,
            });
            lwBbUpper.setData(upperData);
            lwBbLower.setData(lowerData);
        }

        // 차트 전체 보이게
        lwChart.timeScale().fitContent();

        // 기존 AI 보조선 복원
        restoreAiOverlays();

        // 드로잉 도구 이벤트 연결 + 기존 그림 다시 렌더
        hookDrawRedraw();
        setTimeout(redrawCanvas, 100);

        // 리사이즈 옵저버
        lwResizeObserver = new ResizeObserver(entries => {
            if (lwChart && entries[0]) {
                const { width, height } = entries[0].contentRect;
                lwChart.applyOptions({ width, height });
                redrawCanvas();
            }
        });
        lwResizeObserver.observe(wrap);
    }

    function renderVolumeChart() {}
    function toggleMA() {}

    // ========================================
    // Chart Drawing Tools (차트 드로잉 도구)
    // ========================================
    let drawTool = 'none';       // none | line | hline | ray | rect | fib
    let drawColor = '#ef4444';
    let drawWidth = 1;
    let drawObjects = [];        // { type, points, color, width }
    let drawState = null;        // { phase, startX, startY, startPrice, startTime }
    let drawPreview = null;      // 미리보기 좌표

    function setDrawTool(tool) {
        drawTool = tool;
        drawState = null;
        drawPreview = null;
        // 버튼 활성화 표시
        document.querySelectorAll('#drawToolbar .draw-tb-btn[id^="drawBtn"]').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById('drawBtn' + tool.charAt(0).toUpperCase() + tool.slice(1));
        if (btn) btn.classList.add('active');
        // 캔버스 활성화
        const canvas = document.getElementById('drawCanvas');
        if (tool === 'none') {
            canvas.classList.remove('active');
            // 차트 스크롤/줌 복원
            if (lwChart) lwChart.applyOptions({ handleScroll: true, handleScale: true });
        } else {
            canvas.classList.add('active');
            // 차트 스크롤/줌 비활성화 (드로잉 중)
            if (lwChart) lwChart.applyOptions({ handleScroll: false, handleScale: false });
        }
        redrawCanvas();
    }

    function setDrawColor(color) {
        drawColor = color;
        document.querySelectorAll('.draw-color-btn').forEach(b => {
            b.classList.toggle('active', b.style.background === color || b.style.backgroundColor === color);
        });
    }

    function setDrawWidth(w) {
        drawWidth = w;
        document.querySelectorAll('.draw-width-btn').forEach(b => b.classList.toggle('active', +b.dataset.w === w));
    }

    function undoDraw() {
        if (drawObjects.length === 0) return;
        drawObjects.pop();
        redrawCanvas();
        updateDrawBadge();
    }

    function clearAllDrawings() {
        drawObjects = [];
        drawState = null;
        drawPreview = null;
        redrawCanvas();
        updateDrawBadge();
    }

    function updateDrawBadge() {
        const badge = document.getElementById('drawCountBadge');
        if (badge) badge.textContent = drawObjects.length;
    }

    // 좌표 변환: 캔버스 픽셀 → (time, price)
    function canvasToChart(x, y) {
        if (!lwChart) return null;
        const timeScale = lwChart.timeScale();
        const priceScale = lwCandleSeries;
        if (!priceScale) return null;

        const time = timeScale.coordinateToTime(x);
        const logic = timeScale.coordinateToLogical(x);
        // price 변환은 series 기반
        const coordPrice = priceScale.coordinateToPrice(y);
        return { time, logic, price: coordPrice, x, y };
    }

    // 좌표 변환: (time, price) → 캔버스 픽셀
    function chartToCanvas(time, price) {
        if (!lwChart || !lwCandleSeries) return null;
        const x = lwChart.timeScale().timeToCoordinate(time);
        const y = lwCandleSeries.priceToCoordinate(price);
        if (x === null || y === null) return null;
        return { x, y };
    }

    function getCanvasXY(e) {
        const canvas = document.getElementById('drawCanvas');
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    // 피보나치 되돌림 레벨
    const FIB_LEVELS = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];

    function redrawCanvas() {
        const canvas = document.getElementById('drawCanvas');
        if (!canvas) return;
        const wrap = document.getElementById('tvChartWrap');
        canvas.width = wrap.clientWidth;
        canvas.height = wrap.clientHeight;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const isLight = document.documentElement.getAttribute('data-theme') === 'light';

        // 기존 드로잉 오브젝트 그리기
        drawObjects.forEach(obj => drawObject(ctx, obj, canvas, isLight));

        // 미리보기 그리기
        if (drawState && drawPreview) {
            drawPreviewObj(ctx, canvas, isLight);
        }
    }

    function drawObject(ctx, obj, canvas, isLight) {
        ctx.strokeStyle = obj.color;
        ctx.lineWidth = obj.width;
        ctx.setLineDash([]);

        if (obj.type === 'line') {
            const p1 = chartToCanvas(obj.points[0].time, obj.points[0].price);
            const p2 = chartToCanvas(obj.points[1].time, obj.points[1].price);
            if (!p1 || !p2) return;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        } else if (obj.type === 'hline') {
            const y = lwCandleSeries?.priceToCoordinate(obj.points[0].price);
            if (y === null || y === undefined) return;
            ctx.setLineDash([6, 3]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            // 가격 레이블
            ctx.setLineDash([]);
            const label = currentMarket === 'KR' ? Math.round(obj.points[0].price).toLocaleString() : obj.points[0].price.toFixed(2);
            ctx.font = '600 10px Pretendard, sans-serif';
            ctx.fillStyle = obj.color;
            const tw = ctx.measureText(label).width;
            ctx.fillRect(canvas.width - tw - 10, y - 8, tw + 8, 16);
            ctx.fillStyle = isLight ? '#fff' : '#000';
            ctx.fillText(label, canvas.width - tw - 6, y + 4);
        } else if (obj.type === 'ray') {
            const p1 = chartToCanvas(obj.points[0].time, obj.points[0].price);
            const p2 = chartToCanvas(obj.points[1].time, obj.points[1].price);
            if (!p1 || !p2) return;
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) return;
            const ext = 3000;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p1.x + dx / len * ext, p1.y + dy / len * ext);
            ctx.stroke();
            // 시작점 원
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = obj.color;
            ctx.fill();
        } else if (obj.type === 'rect') {
            const p1 = chartToCanvas(obj.points[0].time, obj.points[0].price);
            const p2 = chartToCanvas(obj.points[1].time, obj.points[1].price);
            if (!p1 || !p2) return;
            ctx.fillStyle = obj.color + '15';
            ctx.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
            ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
        } else if (obj.type === 'fib') {
            const p1 = chartToCanvas(obj.points[0].time, obj.points[0].price);
            const p2 = chartToCanvas(obj.points[1].time, obj.points[1].price);
            if (!p1 || !p2) return;
            const high = obj.points[0].price;
            const low = obj.points[1].price;
            const range = high - low;
            ctx.font = '600 10px Pretendard, sans-serif';
            FIB_LEVELS.forEach(level => {
                const price = high - range * level;
                const y = lwCandleSeries?.priceToCoordinate(price);
                if (y === null || y === undefined) return;
                ctx.strokeStyle = obj.color;
                ctx.globalAlpha = level === 0 || level === 1 ? 0.8 : 0.5;
                ctx.setLineDash(level === 0.5 ? [4, 4] : []);
                ctx.lineWidth = obj.width;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
                // 레이블
                const pLabel = currentMarket === 'KR' ? Math.round(price).toLocaleString() : price.toFixed(2);
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
                ctx.fillStyle = obj.color;
                ctx.fillText(`${(level * 100).toFixed(1)}%  ${pLabel}`, 8, y - 4);
            });
            ctx.globalAlpha = 1;
            // 배경 영역
            const yTop = lwCandleSeries?.priceToCoordinate(high);
            const yBot = lwCandleSeries?.priceToCoordinate(low);
            if (yTop != null && yBot != null) {
                ctx.fillStyle = obj.color + '08';
                ctx.fillRect(0, yTop, canvas.width, yBot - yTop);
            }
        }
    }

    function drawPreviewObj(ctx, canvas, isLight) {
        const s = drawState;
        const p = drawPreview;
        ctx.strokeStyle = drawColor + 'aa';
        ctx.lineWidth = drawWidth;
        ctx.setLineDash([4, 4]);

        if (s.tool === 'line' || s.tool === 'ray') {
            ctx.beginPath();
            ctx.moveTo(s.startX, s.startY);
            if (s.tool === 'ray') {
                const dx = p.x - s.startX, dy = p.y - s.startY;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                ctx.lineTo(s.startX + dx / len * 3000, s.startY + dy / len * 3000);
            } else {
                ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        } else if (s.tool === 'hline') {
            ctx.beginPath();
            ctx.moveTo(0, p.y);
            ctx.lineTo(canvas.width, p.y);
            ctx.stroke();
        } else if (s.tool === 'rect') {
            ctx.strokeRect(s.startX, s.startY, p.x - s.startX, p.y - s.startY);
        } else if (s.tool === 'fib') {
            ctx.beginPath();
            ctx.moveTo(s.startX, s.startY);
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    // 캔버스 이벤트 핸들러
    (function initDrawCanvas() {
        const canvas = document.getElementById('drawCanvas');
        if (!canvas) return;

        canvas.addEventListener('mousedown', function(e) {
            if (drawTool === 'none' || !lwChart) return;
            const { x, y } = getCanvasXY(e);
            const chart = canvasToChart(x, y);
            if (!chart) return;

            if (drawTool === 'hline') {
                // 수평선은 클릭 한 번으로 완성
                drawObjects.push({
                    type: 'hline',
                    points: [{ time: chart.time, price: chart.price }],
                    color: drawColor,
                    width: drawWidth,
                });
                redrawCanvas();
                updateDrawBadge();
                return;
            }

            // 나머지 도구는 시작점 설정
            drawState = {
                tool: drawTool,
                startX: x,
                startY: y,
                startTime: chart.time,
                startPrice: chart.price,
            };
        });

        canvas.addEventListener('mousemove', function(e) {
            if (!drawState) return;
            const { x, y } = getCanvasXY(e);
            drawPreview = { x, y };
            redrawCanvas();
        });

        canvas.addEventListener('mouseup', function(e) {
            if (!drawState || drawTool === 'none') return;
            const { x, y } = getCanvasXY(e);
            const chart = canvasToChart(x, y);
            if (!chart) { drawState = null; drawPreview = null; return; }

            const s = drawState;
            drawObjects.push({
                type: s.tool,
                points: [
                    { time: s.startTime, price: s.startPrice },
                    { time: chart.time, price: chart.price },
                ],
                color: drawColor,
                width: drawWidth,
            });
            drawState = null;
            drawPreview = null;
            redrawCanvas();
            updateDrawBadge();
        });

        // 차트 스크롤/줌 시 캔버스 다시 그리기
        const observer = new MutationObserver(() => redrawCanvas());
        observer.observe(canvas.parentElement, { childList: true, subtree: true });
    })();

    // 차트 timeScale 변경 시 드로잉 갱신
    function hookDrawRedraw() {
        if (!lwChart) return;
        lwChart.timeScale().subscribeVisibleTimeRangeChange(() => redrawCanvas());
        lwChart.subscribeCrosshairMove(() => {
            if (drawObjects.length > 0 || drawState) redrawCanvas();
        });
    }

    // Ctrl+Z 단축키
    document.addEventListener('keydown', e => {
        if (e.ctrlKey && e.key === 'z') {
            undoDraw();
            e.preventDefault();
        }
    });

    // ========================================
    // AI 보조지표 (Google Gemini API)
    // ========================================
    const AI_KEY_LS = 'stockai_gemini_key';
    let aiIndChart = null;

    // API 키 로드/저장
    (function initAiKey() {
        const saved = localStorage.getItem(AI_KEY_LS);
        if (saved) {
            document.getElementById('aiIndKeyInput').value = saved;
            document.getElementById('aiIndKeyRow').style.display = 'none';
        }
    })();

    function saveAiKey() {
        const key = document.getElementById('aiIndKeyInput').value.trim();
        if (!key) { showToast('API Key를 입력해주세요.'); return; }
        localStorage.setItem(AI_KEY_LS, key);
        document.getElementById('aiIndKeyRow').style.display = 'none';
        showToast('API Key가 저장되었습니다.');
    }

    function getAiKey() {
        return localStorage.getItem(AI_KEY_LS) || document.getElementById('aiIndKeyInput').value.trim();
    }

    function setAiPrompt(text) {
        document.getElementById('aiIndInput').value = text;
        runAiIndicator();
    }

    async function runAiIndicator() {
        const apiKey = getAiKey();
        if (!apiKey) {
            document.getElementById('aiIndKeyRow').style.display = 'flex';
            showToast('Gemini API Key를 먼저 입력해주세요. (aistudio.google.com에서 무료 발급)');
            return;
        }
        if (!stockData) { showToast('먼저 종목을 검색해주세요.'); return; }

        const prompt = document.getElementById('aiIndInput').value.trim();
        if (!prompt) { showToast('보조지표를 입력해주세요.'); return; }

        const btn = document.getElementById('aiIndSendBtn');
        const statusEl = document.getElementById('aiIndStatus');
        btn.disabled = true;
        statusEl.style.display = 'flex';
        statusEl.innerHTML = '<span class="spinner"></span>AI가 보조지표를 계산하고 있습니다...';

        try {
            // 주가 데이터 준비 (최근 200개로 제한)
            const ts = stockData.timestamp;
            const q = stockData.indicators.quote[0];
            const len = Math.min(ts.length, 200);
            const startIdx = ts.length - len;
            const dates = ts.slice(startIdx).map(t => {
                const d = new Date(t * 1000);
                return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
            });
            const closes = q.close.slice(startIdx);
            const opens = q.open.slice(startIdx);
            const highs = q.high.slice(startIdx);
            const lows = q.low.slice(startIdx);
            const volumes = q.volume.slice(startIdx);

            const systemPrompt = `You are a stock technical analysis expert. The user will request a custom indicator.
You must return ONLY a valid JSON object (no markdown, no explanation, no code fences).

The JSON must have this exact structure:
{
  "title": "indicator name in Korean",
  "datasets": [
    {
      "label": "line label",
      "data": [number or null, ...],
      "color": "#hexcolor",
      "type": "line" or "bar",
      "dashed": false,
      "fill": false
    }
  ],
  "annotations": []
}

Rules:
- "data" arrays MUST have exactly ${len} elements (matching the date count)
- Use null for insufficient data points at the beginning
- For "빗각" (slope angle): Draw trend lines using linear regression on recent closing prices, showing the angle/slope of the trend
- Colors should be vivid and distinct
- Maximum 6 datasets
- "annotations" can contain {index, text, color} for important points
- Respond in Korean for title/labels`;

            const userMsg = `주가 데이터 (최근 ${len}일):
종가: [${closes.map(v => v != null ? v.toFixed(2) : 'null').join(',')}]
시가: [${opens.map(v => v != null ? v.toFixed(2) : 'null').join(',')}]
고가: [${highs.map(v => v != null ? v.toFixed(2) : 'null').join(',')}]
저가: [${lows.map(v => v != null ? v.toFixed(2) : 'null').join(',')}]
거래량: [${volumes.join(',')}]

요청 보조지표: "${prompt}"

위 데이터를 기반으로 보조지표를 계산하여 JSON으로 반환해주세요.`;

            const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
            const res = await fetch(geminiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: systemPrompt + '\n\n' + userMsg }] }],
                    generationConfig: {
                        temperature: 0.2,
                        maxOutputTokens: 8192,
                        responseMimeType: 'application/json'
                    }
                })
            });

            if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                const msg = err.error?.message || `API 오류 (${res.status})`;
                if (res.status === 400 || res.status === 403) throw new Error('API Key가 유효하지 않습니다. 확인해주세요.');
                throw new Error(msg);
            }

            const result = await res.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text || '';

            // JSON 파싱 (코드 펜스 제거)
            const jsonStr = text.replace(/```json?\s*/g, '').replace(/```/g, '').trim();
            const indicator = JSON.parse(jsonStr);

            // 차트 렌더링
            renderAiIndChart(indicator, dates);
            statusEl.innerHTML = `✓ "${indicator.title}" 생성 완료`;

        } catch(e) {
            statusEl.innerHTML = `<span style="color:var(--red)">✗ 오류: ${e.message}</span>`;
            if (e.message.includes('401') || e.message.includes('403') || e.message.includes('invalid') || e.message.includes('API Key')) {
                document.getElementById('aiIndKeyRow').style.display = 'flex';
            }
        } finally {
            btn.disabled = false;
        }
    }

    // ========================================
    // AI 보조선 관리 시스템
    // ========================================
    // aiLineStore: [{ id, title, datasets, dates, seriesList (LW series[]), visible }]
    let aiLineStore = [];
    let aiLineIdCounter = 0;

    function switchAiTab(tab) {
        document.querySelectorAll('.ai-ind-tab').forEach(t => t.classList.toggle('active', t.dataset.aitab === tab));
        document.querySelectorAll('.ai-ind-panel').forEach(p => p.classList.toggle('active', p.dataset.aitab === tab));
    }

    function updateAiLineBadge() {
        document.getElementById('aiLineBadge').textContent = aiLineStore.length;
    }

    function renderAiLineList() {
        const list = document.getElementById('aiLineList');
        const clearBtn = document.getElementById('aiLineClearAll');

        if (aiLineStore.length === 0) {
            list.innerHTML = '<div class="ai-line-empty">생성된 보조선이 없습니다.<br>생성 탭에서 보조지표를 추가하세요.</div>';
            clearBtn.style.display = 'none';
        } else {
            list.innerHTML = aiLineStore.map(line => {
                const colors = line.datasets.filter(d => d.type !== 'bar').map(d => d.color || '#a78bfa');
                const colorDisplay = colors.length > 0 ? colors[0] : '#a78bfa';
                const lineCount = line.datasets.filter(d => d.type !== 'bar').length;
                return `
                    <div class="ai-line-item" data-lineid="${line.id}">
                        <div class="ai-line-color" style="background:${colorDisplay}"></div>
                        <div class="ai-line-info">
                            <div class="ai-line-name">${line.title}</div>
                            <div class="ai-line-sub">${lineCount}개 라인</div>
                        </div>
                        <button class="ai-line-toggle ${line.visible ? 'on' : 'off'}" onclick="toggleAiLine(${line.id})" title="${line.visible ? '숨기기' : '보이기'}"></button>
                        <button class="ai-line-remove" onclick="removeAiLine(${line.id})" title="삭제">&times;</button>
                    </div>
                `;
            }).join('');
            clearBtn.style.display = '';
        }
        updateAiLineBadge();
    }

    function addAiLineToChart(lineEntry) {
        if (!lwChart || !stockData?.timestamp) return;
        const ts = stockData.timestamp;
        const startIdx = ts.length - lineEntry.dates.length;

        lineEntry.seriesList = [];
        lineEntry.datasets.forEach(ds => {
            if (ds.type === 'bar') return;
            const lineData = [];
            for (let i = 0; i < ds.data.length; i++) {
                if (ds.data[i] == null) continue;
                const tIdx = startIdx + i;
                if (tIdx >= ts.length) continue;
                lineData.push({ time: ts[tIdx], value: ds.data[i] });
            }
            if (lineData.length === 0) return;

            const series = lwChart.addLineSeries({
                color: ds.color || '#a78bfa',
                lineWidth: 2,
                lineStyle: ds.dashed ? 2 : 0,
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                title: ds.label,
            });
            series.setData(lineData);
            lineEntry.seriesList.push(series);
            lwAiOverlaySeries.push(series);
        });
    }

    function removeAiLineFromChart(lineEntry) {
        if (!lwChart) return;
        lineEntry.seriesList.forEach(s => {
            try { lwChart.removeSeries(s); } catch(e) {}
            const idx = lwAiOverlaySeries.indexOf(s);
            if (idx >= 0) lwAiOverlaySeries.splice(idx, 1);
        });
        lineEntry.seriesList = [];
    }

    function toggleAiLine(id) {
        const line = aiLineStore.find(l => l.id === id);
        if (!line) return;
        line.visible = !line.visible;
        if (line.visible) {
            addAiLineToChart(line);
        } else {
            removeAiLineFromChart(line);
        }
        renderAiLineList();
    }

    function removeAiLine(id) {
        const idx = aiLineStore.findIndex(l => l.id === id);
        if (idx < 0) return;
        removeAiLineFromChart(aiLineStore[idx]);
        aiLineStore.splice(idx, 1);
        renderAiLineList();
    }

    function clearAllAiLines() {
        aiLineStore.forEach(line => removeAiLineFromChart(line));
        aiLineStore = [];
        renderAiLineList();
    }

    function clearAiOverlay() {
        // 메인 차트에서 AI 오버레이 라인 전체 제거
        if (lwChart) {
            lwAiOverlaySeries.forEach(s => {
                try { lwChart.removeSeries(s); } catch(e) {}
            });
        }
        lwAiOverlaySeries = [];
        // 차트 재생성 시 store의 seriesList도 비움
        aiLineStore.forEach(l => { l.seriesList = []; });
    }

    // 차트 재생성 후 visible 보조선 다시 그리기
    function restoreAiOverlays() {
        aiLineStore.forEach(line => {
            if (line.visible) addAiLineToChart(line);
        });
    }

    function renderAiIndChart(indicator, dates) {
        // 새 보조선을 store에 추가
        const lineEntry = {
            id: ++aiLineIdCounter,
            title: indicator.title,
            datasets: indicator.datasets,
            dates: dates,
            seriesList: [],
            visible: true,
        };
        aiLineStore.push(lineEntry);

        // 메인 차트에 오버레이
        addAiLineToChart(lineEntry);

        // 보조선 목록 갱신
        renderAiLineList();

        // 별도 Chart.js 차트에도 렌더링 (전체 지표 확인용)
        const wrap = document.getElementById('aiIndChartWrap');
        wrap.style.display = 'block';

        if (aiIndChart) aiIndChart.destroy();

        const chartDatasets = indicator.datasets.map(ds => ({
            label: ds.label,
            data: ds.data,
            borderColor: ds.color || '#a78bfa',
            backgroundColor: ds.fill ? (ds.color || '#a78bfa') + '20' : 'transparent',
            borderWidth: ds.type === 'bar' ? 0 : 1.8,
            borderDash: ds.dashed ? [5, 3] : [],
            pointRadius: 0,
            pointHoverRadius: 3,
            tension: 0.1,
            fill: ds.fill || false,
            type: ds.type === 'bar' ? 'bar' : 'line',
            yAxisID: ds.type === 'bar' ? 'yBar' : 'y',
            order: ds.type === 'bar' ? 1 : 0,
        }));

        const hasBar = chartDatasets.some(d => d.type === 'bar');

        const scales = {
            x: {
                type: 'category',
                ticks: { color: '#4b5563', maxTicksLimit: 10, font: { size: 10 } },
                grid: { color: 'rgba(45,58,77,0.15)' },
            },
            y: {
                position: 'right',
                ticks: { color: '#4b5563', font: { size: 10 } },
                grid: { color: 'rgba(45,58,77,0.15)' },
            }
        };
        if (hasBar) {
            scales.yBar = {
                position: 'left',
                ticks: { color: '#4b5563', font: { size: 10 } },
                grid: { drawOnChartArea: false },
            };
        }

        aiIndChart = new Chart(document.getElementById('aiIndChart'), {
            type: 'line',
            data: { labels: dates, datasets: chartDatasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { color: '#94a3b8', font: { size: 11, weight: '600' }, boxWidth: 14, padding: 12 },
                    },
                    title: {
                        display: true,
                        text: indicator.title + ' (차트에 오버레이 됨)',
                        color: '#f1f5f9',
                        font: { size: 13, weight: '700' },
                        padding: { bottom: 8 },
                    },
                },
                scales,
            }
        });

        // 생성 후 보조선 탭 뱃지에 숫자 표시
        switchAiTab('lines');
    }

    // ========================================
    // RSI Chart
    // ========================================
    function renderRSIChart() {
        if (rsiChart) rsiChart.destroy();

        const timestamps = stockData.timestamp;
        const closes = stockData.indicators.quote[0].close;
        const labels = timestamps.map(t => new Date(t * 1000));
        const rsi = calcRSI(closes);

        const ctx = document.getElementById('rsiChart').getContext('2d');
        rsiChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [{
                    label: 'RSI(14)',
                    data: rsi,
                    borderColor: '#8b5cf6',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    annotation: {}
                },
                scales: {
                    x: { type: 'time', display: false },
                    y: {
                        min: 0, max: 100,
                        position: 'right',
                        grid: { color: 'rgba(45,58,77,0.3)' },
                        ticks: { color: '#64748b', stepSize: 25 }
                    }
                }
            },
            plugins: [{
                id: 'rsiLines',
                beforeDraw(chart) {
                    const { ctx, chartArea: { left, right, top, bottom }, scales: { y } } = chart;
                    // Overbought (70)
                    const y70 = y.getPixelForValue(70);
                    const y30 = y.getPixelForValue(30);
                    ctx.save();
                    ctx.strokeStyle = 'rgba(239,68,68,0.4)';
                    ctx.setLineDash([4,4]);
                    ctx.beginPath(); ctx.moveTo(left, y70); ctx.lineTo(right, y70); ctx.stroke();
                    ctx.strokeStyle = 'rgba(59,130,246,0.4)';
                    ctx.beginPath(); ctx.moveTo(left, y30); ctx.lineTo(right, y30); ctx.stroke();
                    // Fill zones
                    ctx.fillStyle = 'rgba(239,68,68,0.05)';
                    ctx.fillRect(left, top, right - left, y70 - top);
                    ctx.fillStyle = 'rgba(59,130,246,0.05)';
                    ctx.fillRect(left, y30, right - left, bottom - y30);
                    ctx.restore();
                }
            }]
        });
    }

    // ========================================
    // MACD Chart
    // ========================================
    function renderMACDChart() {
        if (macdChart) macdChart.destroy();

        const timestamps = stockData.timestamp;
        const closes = stockData.indicators.quote[0].close;
        const labels = timestamps.map(t => new Date(t * 1000));
        const { macdLine, signalLine, histogram } = calcMACD(closes);

        const histColors = histogram.map(v => v >= 0 ? 'rgba(239,68,68,0.5)' : 'rgba(59,130,246,0.5)');

        const ctx = document.getElementById('macdChart').getContext('2d');
        macdChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [
                    {
                        label: 'Histogram',
                        data: histogram,
                        backgroundColor: histColors,
                        borderWidth: 0,
                        order: 2
                    },
                    {
                        label: 'MACD',
                        data: macdLine,
                        borderColor: '#06b6d4',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        type: 'line',
                        fill: false,
                        tension: 0.1,
                        order: 1
                    },
                    {
                        label: 'Signal',
                        data: signalLine,
                        borderColor: '#f59e0b',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        type: 'line',
                        fill: false,
                        tension: 0.1,
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { color: '#94a3b8', boxWidth: 12, padding: 8, font: { size: 11 } }
                    }
                },
                scales: {
                    x: { type: 'time', display: false },
                    y: {
                        position: 'right',
                        grid: { color: 'rgba(45,58,77,0.3)' },
                        ticks: { color: '#64748b' }
                    }
                }
            }
        });
    }

    // ========================================
    // Stochastic Chart
    // ========================================
    function renderStochChart() {
        if (stochChart) stochChart.destroy();
        const timestamps = stockData.timestamp;
        const q = stockData.indicators.quote[0];
        const labels = timestamps.map(t => new Date(t * 1000));
        const { kLine, dLine } = calcStochastic(q.high, q.low, q.close);

        const ctx = document.getElementById('stochChart').getContext('2d');
        stochChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label: '%K', data: kLine, borderColor: '#3b82f6', borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1 },
                    { label: '%D', data: dLine, borderColor: '#ef4444', borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1, borderDash: [3,3] }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { display: true, position: 'top', labels: { color: '#94a3b8', boxWidth: 12, padding: 8, font: { size: 11 } } } },
                scales: {
                    x: { type: 'time', display: false },
                    y: { min: 0, max: 100, position: 'right', grid: { color: 'rgba(45,58,77,0.3)' }, ticks: { color: '#64748b', stepSize: 25 } }
                }
            },
            plugins: [{
                id: 'stochLines',
                beforeDraw(chart) {
                    const { ctx, chartArea: { left, right, top, bottom }, scales: { y } } = chart;
                    const y80 = y.getPixelForValue(80), y20 = y.getPixelForValue(20);
                    ctx.save();
                    ctx.setLineDash([4,4]);
                    ctx.strokeStyle = 'rgba(239,68,68,0.4)';
                    ctx.beginPath(); ctx.moveTo(left, y80); ctx.lineTo(right, y80); ctx.stroke();
                    ctx.strokeStyle = 'rgba(59,130,246,0.4)';
                    ctx.beginPath(); ctx.moveTo(left, y20); ctx.lineTo(right, y20); ctx.stroke();
                    ctx.fillStyle = 'rgba(239,68,68,0.04)';
                    ctx.fillRect(left, top, right-left, y80-top);
                    ctx.fillStyle = 'rgba(59,130,246,0.04)';
                    ctx.fillRect(left, y20, right-left, bottom-y20);
                    ctx.restore();
                }
            }]
        });
    }

    // ========================================
    // ADX Chart
    // ========================================
    function renderADXChart() {
        if (adxChart) adxChart.destroy();
        const timestamps = stockData.timestamp;
        const q = stockData.indicators.quote[0];
        const labels = timestamps.map(t => new Date(t * 1000));
        const { pDI, mDI, adx } = calcADX(q.high, q.low, q.close);

        const ctx = document.getElementById('adxChart').getContext('2d');
        adxChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label: 'ADX', data: adx, borderColor: '#f59e0b', borderWidth: 2, pointRadius: 0, fill: false, tension: 0.1 },
                    { label: '+DI', data: pDI, borderColor: '#10b981', borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1 },
                    { label: '-DI', data: mDI, borderColor: '#ef4444', borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1 }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { display: true, position: 'top', labels: { color: '#94a3b8', boxWidth: 12, padding: 8, font: { size: 11 } } } },
                scales: {
                    x: { type: 'time', display: false },
                    y: { position: 'right', grid: { color: 'rgba(45,58,77,0.3)' }, ticks: { color: '#64748b' } }
                }
            },
            plugins: [{
                id: 'adxLine25',
                beforeDraw(chart) {
                    const { ctx, chartArea: { left, right }, scales: { y } } = chart;
                    const y25 = y.getPixelForValue(25);
                    ctx.save(); ctx.setLineDash([4,4]); ctx.strokeStyle='rgba(245,158,11,0.4)';
                    ctx.beginPath(); ctx.moveTo(left,y25); ctx.lineTo(right,y25); ctx.stroke(); ctx.restore();
                }
            }]
        });
    }

    // ========================================
    // CCI Chart
    // ========================================
    function renderCCIChart() {
        if (cciChart) cciChart.destroy();
        const timestamps = stockData.timestamp;
        const q = stockData.indicators.quote[0];
        const labels = timestamps.map(t => new Date(t * 1000));
        const cci = calcCCI(q.high, q.low, q.close);

        const ctx = document.getElementById('cciChart').getContext('2d');
        cciChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [{ label: 'CCI(20)', data: cci, borderColor: '#06b6d4', borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1 }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { type: 'time', display: false },
                    y: { position: 'right', grid: { color: 'rgba(45,58,77,0.3)' }, ticks: { color: '#64748b' } }
                }
            },
            plugins: [{
                id: 'cciZones',
                beforeDraw(chart) {
                    const { ctx, chartArea: { left, right, top, bottom }, scales: { y } } = chart;
                    const y100 = y.getPixelForValue(100), ym100 = y.getPixelForValue(-100), y0 = y.getPixelForValue(0);
                    ctx.save(); ctx.setLineDash([4,4]);
                    ctx.strokeStyle='rgba(239,68,68,0.4)'; ctx.beginPath(); ctx.moveTo(left,y100); ctx.lineTo(right,y100); ctx.stroke();
                    ctx.strokeStyle='rgba(59,130,246,0.4)'; ctx.beginPath(); ctx.moveTo(left,ym100); ctx.lineTo(right,ym100); ctx.stroke();
                    ctx.strokeStyle='rgba(100,116,139,0.3)'; ctx.setLineDash([2,2]); ctx.beginPath(); ctx.moveTo(left,y0); ctx.lineTo(right,y0); ctx.stroke();
                    ctx.restore();
                }
            }]
        });
    }

    // ========================================
    // OBV Chart
    // ========================================
    function renderOBVChart() {
        if (obvChart) obvChart.destroy();
        const timestamps = stockData.timestamp;
        const q = stockData.indicators.quote[0];
        const labels = timestamps.map(t => new Date(t * 1000));
        const obv = calcOBV(q.close, q.volume);
        const obvMA = calcSMA(obv, 20);

        const ctx = document.getElementById('obvChart').getContext('2d');
        obvChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label: 'OBV', data: obv, borderColor: '#e879f9', borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1 },
                    { label: 'OBV MA20', data: obvMA, borderColor: '#f59e0b', borderWidth: 1, pointRadius: 0, fill: false, tension: 0.1, borderDash: [3,3] }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { legend: { display: true, position: 'top', labels: { color: '#94a3b8', boxWidth: 12, padding: 8, font: { size: 11 } } } },
                scales: {
                    x: { type: 'time', display: false },
                    y: {
                        position: 'right', grid: { color: 'rgba(45,58,77,0.3)' },
                        ticks: { color: '#64748b', callback: v => { if(Math.abs(v)>=1e9) return (v/1e9).toFixed(1)+'B'; if(Math.abs(v)>=1e6) return (v/1e6).toFixed(0)+'M'; if(Math.abs(v)>=1e4) return (v/1e4).toFixed(0)+'만'; return v.toLocaleString(); } }
                    }
                }
            }
        });
    }

    // ========================================
    // Technical Indicators Panel
    // ========================================
    function renderTechnicalIndicators() {
        const q = stockData.indicators.quote[0];
        const closes = q.close.filter(v => v != null);
        const highs = q.high.filter(v => v != null);
        const lows = q.low.filter(v => v != null);
        const volumes = q.volume.filter(v => v != null);
        const price = closes[closes.length - 1];

        const ma5 = calcSMA(closes, 5);
        const ma20 = calcSMA(closes, 20);
        const ma60 = calcSMA(closes, 60);
        const ma120 = calcSMA(closes, 120);
        const rsi = calcRSI(closes);
        const { macdLine, signalLine } = calcMACD(closes);
        const bb = calcBollingerBands(closes);
        const { kLine, dLine } = calcStochastic(highs, lows, closes);
        const { adx } = calcADX(highs, lows, closes);
        const atr = calcATR(highs, lows, closes);
        const vwap = calcVWAP(highs, lows, closes, volumes);
        const cci = calcCCI(highs, lows, closes);
        const wr = calcWilliamsR(highs, lows, closes);
        const mfi = calcMFI(highs, lows, closes, volumes);

        const lastRSI = rsi.filter(v => v != null).pop();
        const lastMACD = macdLine.filter(v => v != null).pop();
        const lastSignal = signalLine.filter(v => v != null).pop();
        const lastBBUpper = bb.upper.filter(v => v != null).pop();
        const lastBBLower = bb.lower.filter(v => v != null).pop();
        const lastMA5 = ma5.filter(v => v != null).pop();
        const lastMA20 = ma20.filter(v => v != null).pop();
        const lastMA60 = ma60.filter(v => v != null).pop();
        const lastMA120 = ma120.filter(v => v != null).pop();
        const lastK = kLine.filter(v => v != null).pop();
        const lastD = dLine.filter(v => v != null).pop();
        const lastADX = adx.filter(v => v != null).pop();
        const lastATR = atr.filter(v => v != null).pop();
        const lastVWAP = vwap.filter(v => v != null).pop();
        const lastCCI = cci.filter(v => v != null).pop();
        const lastWR = wr.filter(v => v != null).pop();
        const lastMFI = mfi.filter(v => v != null).pop();

        const isKR = currentMarket === 'KR';
        const fmt = v => v == null ? '-' : isKR ? Math.round(v).toLocaleString() : v.toFixed(2);

        function maSignal(maVal) {
            if (maVal == null) return ['N/A', 'neutral'];
            return price > maVal ? ['상향 돌파', 'buy'] : ['하향 돌파', 'sell'];
        }

        const rsiSignal = lastRSI > 70 ? ['과매수', 'sell'] : lastRSI < 30 ? ['과매도', 'buy'] : ['중립', 'neutral'];
        const macdSignalText = lastMACD > lastSignal ? ['매수 신호', 'buy'] : ['매도 신호', 'sell'];

        // Stochastic signal
        const stochSig = lastK > 80 ? ['과매수', 'sell'] : lastK < 20 ? ['과매도', 'buy'] : lastK > lastD ? ['매수세', 'buy'] : ['매도세', 'sell'];

        // ADX signal
        const adxSig = lastADX == null ? ['N/A', 'neutral'] : lastADX >= 25 ? ['강한 추세', 'buy'] : ['추세 약함', 'neutral'];

        // VWAP signal
        const vwapSig = lastVWAP == null ? ['N/A', 'neutral'] : price > lastVWAP ? ['VWAP 위', 'buy'] : ['VWAP 아래', 'sell'];

        // CCI signal
        const cciSig = lastCCI == null ? ['N/A', 'neutral'] : lastCCI > 100 ? ['과매수', 'sell'] : lastCCI < -100 ? ['과매도', 'buy'] : ['중립', 'neutral'];

        // Williams %R signal
        const wrSig = lastWR == null ? ['N/A', 'neutral'] : lastWR > -20 ? ['과매수', 'sell'] : lastWR < -80 ? ['과매도', 'buy'] : ['중립', 'neutral'];

        // MFI signal
        const mfiSig = lastMFI == null ? ['N/A', 'neutral'] : lastMFI > 80 ? ['과매수', 'sell'] : lastMFI < 20 ? ['과매도', 'buy'] : ['중립', 'neutral'];

        const indicators = [
            { label: 'RSI (14)', value: lastRSI ? lastRSI.toFixed(1) : '-', signal: rsiSignal },
            { label: 'MACD', value: lastMACD ? lastMACD.toFixed(2) : '-', signal: macdSignalText },
            { label: 'Stoch %K', value: lastK ? lastK.toFixed(1) : '-', signal: stochSig },
            { label: 'ADX (14)', value: lastADX ? lastADX.toFixed(1) : '-', signal: adxSig },
            { label: 'CCI (20)', value: lastCCI ? lastCCI.toFixed(1) : '-', signal: cciSig },
            { label: 'W %R (14)', value: lastWR ? lastWR.toFixed(1) : '-', signal: wrSig },
            { label: 'MFI (14)', value: lastMFI ? lastMFI.toFixed(1) : '-', signal: mfiSig },
            { label: 'VWAP', value: fmt(lastVWAP), signal: vwapSig },
            { label: 'ATR (14)', value: lastATR ? (isKR ? Math.round(lastATR).toLocaleString() : lastATR.toFixed(2)) : '-', signal: ['변동성', 'neutral'] },
            { label: 'MA5', value: fmt(lastMA5), signal: maSignal(lastMA5) },
            { label: 'MA20', value: fmt(lastMA20), signal: maSignal(lastMA20) },
            { label: 'MA60', value: fmt(lastMA60), signal: maSignal(lastMA60) },
            { label: 'MA120', value: fmt(lastMA120), signal: maSignal(lastMA120) },
            { label: 'BB 상단', value: fmt(lastBBUpper), signal: price > lastBBUpper ? ['상단 돌파', 'sell'] : ['밴드 내', 'neutral'] },
            { label: 'BB 하단', value: fmt(lastBBLower), signal: price < lastBBLower ? ['하단 돌파', 'buy'] : ['밴드 내', 'neutral'] },
        ];

        const html = indicators.map(ind => `
            <div class="indicator-item">
                <div class="indicator-label">${ind.label}</div>
                <div class="indicator-value">${ind.value}</div>
                <div class="indicator-signal signal-${ind.signal[1]}">${ind.signal[0]}</div>
            </div>
        `).join('');
        const igEl = document.getElementById('indicatorGrid');
        if (igEl) igEl.innerHTML = html;
    }

    // ========================================
    // Financial Info
    // ========================================
    async function renderFinancialInfo(symbol) {
        const grid = document.getElementById('financeGrid');

        const meta = stockData.meta;
        const quotes = stockData.indicators.quote[0];
        const closes = quotes.close.filter(v => v != null);
        const highs = quotes.high.filter(v => v != null);
        const lows = quotes.low.filter(v => v != null);
        const vols = quotes.volume.filter(v => v != null);
        const avgVolume = vols.length ? vols.reduce((a,b) => a+b, 0) / vols.length : 0;

        const isKR = currentMarket === 'KR';
        const fmtP = v => {
            if (v == null || isNaN(v)) return '-';
            return isKR ? Math.round(v).toLocaleString() + '원' : '$' + Number(v).toFixed(2);
        };
        const fmtVol = v => {
            if (v >= 1e8) return (v/1e8).toFixed(1) + '억';
            if (v >= 1e4) return (v/1e4).toFixed(0) + '만';
            return Math.round(v).toLocaleString();
        };
        const fmtCap = mc => {
            if (mc == null) return '-';
            if (isKR) {
                if (mc >= 1e12) return (mc/1e12).toFixed(1) + '조원';
                if (mc >= 1e8) return (mc/1e8).toFixed(0) + '억원';
                return Math.round(mc).toLocaleString() + '원';
            }
            if (mc >= 1e12) return '$' + (mc/1e12).toFixed(2) + 'T';
            if (mc >= 1e9) return '$' + (mc/1e9).toFixed(1) + 'B';
            if (mc >= 1e6) return '$' + (mc/1e6).toFixed(0) + 'M';
            return '$' + Number(mc).toLocaleString();
        };

        // 차트 데이터에서 바로 가져올 수 있는 기본값
        const chartOpen = quotes.open?.filter(v=>v!=null).pop();
        const chartDayHigh = quotes.high?.filter(v=>v!=null).pop();
        const chartDayLow = quotes.low?.filter(v=>v!=null).pop();
        const chartHigh52 = Math.max(...highs);
        const chartLow52 = Math.min(...lows);

        // 결과를 담을 객체
        const fin = {
            marketCap: null, per: null, forwardPE: null, pbr: null,
            eps: null, dividend: null, high52: null, low52: null,
            open: null, dayHigh: null, dayLow: null, avgVol: null,
            revenue: null, profitMargin: null, targetPrice: null, beta: null
        };

        // ★ 1단계: 차트 데이터로 즉시 렌더링 (API 응답 기다리지 않음)
        const renderGrid = () => {
            const items = [
                { label: '시가총액', value: fin.marketCap != null ? fmtCap(fin.marketCap) : '-' },
                { label: '시가', value: fmtP(fin.open ?? chartOpen) },
                { label: '고가', value: fmtP(fin.dayHigh ?? chartDayHigh) },
                { label: '저가', value: fmtP(fin.dayLow ?? chartDayLow) },
                { label: 'PER (TTM)', value: fin.per != null ? Number(fin.per).toFixed(2) : '-' },
                { label: 'Forward PER', value: fin.forwardPE != null ? Number(fin.forwardPE).toFixed(2) : '-' },
                { label: 'PBR', value: fin.pbr != null ? Number(fin.pbr).toFixed(2) : '-' },
                { label: 'EPS (TTM)', value: fin.eps != null ? fmtP(fin.eps) : '-' },
                { label: '배당수익률', value: fin.dividend != null && fin.dividend > 0 ? (fin.dividend * 100).toFixed(2) + '%' : '-' },
                { label: '52주 최고', value: fmtP(fin.high52 ?? chartHigh52) },
                { label: '52주 최저', value: fmtP(fin.low52 ?? chartLow52) },
                { label: '평균 거래량', value: fmtVol(fin.avgVol ?? avgVolume) },
            ];
            if (fin.revenue != null) items.push({ label: '매출 (연간)', value: fmtCap(fin.revenue) });
            if (fin.profitMargin != null) items.push({ label: '이익률', value: (fin.profitMargin * 100).toFixed(1) + '%' });
            if (fin.targetPrice != null) items.push({ label: '목표주가 (평균)', value: fmtP(fin.targetPrice) });
            if (fin.beta != null) items.push({ label: '베타', value: Number(fin.beta).toFixed(2) });

            grid.innerHTML = items.map(item => `
                <div class="finance-item">
                    <span class="finance-label">${item.label}</span>
                    <span class="finance-value">${item.value}</span>
                </div>
            `).join('');
        };

        // 즉시 차트 기본 데이터로 렌더
        renderGrid();

        // fin 객체에 값 병합하는 헬퍼
        const mergeIfNull = (key, val) => { if (fin[key] == null && val != null) fin[key] = val; };

        // ★ 2단계: 3개 API를 동시에 병렬 호출
        const api1 = async () => {
            // 방법 1: Yahoo Finance 페이지 HTML 스크래핑 (백엔드 프록시)
            const res = await fetch(`${API_BASE}/api/page/${symbol}`, { signal: AbortSignal.timeout(8000) });
            if (!res.ok) return;
            const html = await res.text();
            const jsonMatches = html.match(/"QuoteSummaryStore":\s*(\{[\s\S]*?\})\s*,\s*"/);
            if (jsonMatches) {
                try {
                    const store = JSON.parse(jsonMatches[1]);
                    const sd = store.summaryDetail || {};
                    const fd = store.financialData || {};
                    const pr = store.price || {};
                    const ks = store.defaultKeyStatistics || {};
                    mergeIfNull('marketCap', pr.marketCap?.raw || sd.marketCap?.raw);
                    mergeIfNull('per', sd.trailingPE?.raw);
                    mergeIfNull('forwardPE', sd.forwardPE?.raw || ks.forwardPE?.raw);
                    mergeIfNull('pbr', sd.priceToBook?.raw || ks.priceToBook?.raw);
                    mergeIfNull('eps', ks.trailingEps?.raw);
                    mergeIfNull('dividend', sd.dividendYield?.raw || sd.trailingAnnualDividendYield?.raw);
                    mergeIfNull('high52', sd.fiftyTwoWeekHigh?.raw);
                    mergeIfNull('low52', sd.fiftyTwoWeekLow?.raw);
                    mergeIfNull('open', sd.open?.raw || pr.regularMarketOpen?.raw);
                    mergeIfNull('dayHigh', sd.dayHigh?.raw || pr.regularMarketDayHigh?.raw);
                    mergeIfNull('dayLow', sd.dayLow?.raw || pr.regularMarketDayLow?.raw);
                    mergeIfNull('avgVol', sd.averageVolume?.raw);
                    mergeIfNull('revenue', fd.totalRevenue?.raw);
                    mergeIfNull('profitMargin', fd.profitMargins?.raw);
                    mergeIfNull('targetPrice', fd.targetMeanPrice?.raw);
                    mergeIfNull('beta', ks.beta?.raw);
                } catch(pe) {}
            }
            if (fin.marketCap == null) {
                const parseTableVal = (label) => {
                    const patterns = [
                        new RegExp(label + '[^>]*>[^>]*>([^<]+)<', 'i'),
                        new RegExp('data-test="' + label + '"[^>]*>([^<]+)<', 'i'),
                    ];
                    for (const p of patterns) { const m = html.match(p); if (m) return m[1].trim(); }
                    return null;
                };
                const parseNum = s => {
                    if (!s || s === 'N/A' || s === '--') return null;
                    s = s.replace(/,/g, '');
                    const m = s.match(/([\d.]+)\s*(T|B|M|K)?/i);
                    if (!m) return parseFloat(s) || null;
                    let n = parseFloat(m[1]);
                    const suffix = (m[2] || '').toUpperCase();
                    if (suffix === 'T') n *= 1e12; else if (suffix === 'B') n *= 1e9;
                    else if (suffix === 'M') n *= 1e6; else if (suffix === 'K') n *= 1e3;
                    return n;
                };
                const mcStr = parseTableVal('MARKET_CAP') || parseTableVal('Market Cap');
                if (mcStr) fin.marketCap = parseNum(mcStr);
                const peStr = parseTableVal('PE_RATIO') || parseTableVal('PE Ratio');
                if (peStr) fin.per = parseFloat(peStr);
                const epsStr = parseTableVal('EPS_RATIO') || parseTableVal('EPS');
                if (epsStr) fin.eps = parseFloat(epsStr);
            }
        };

        const api2 = async () => {
            // 방법 2: v7/finance/quote API
            const quoteUrl = `https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbol}`;
            const data = await fetchWithProxy(quoteUrl);
            const q = data?.quoteResponse?.result?.[0];
            if (!q) return;
            mergeIfNull('marketCap', q.marketCap);
            mergeIfNull('per', q.trailingPE);
            mergeIfNull('forwardPE', q.forwardPE);
            mergeIfNull('pbr', q.priceToBook);
            mergeIfNull('eps', q.epsTrailingTwelveMonths);
            if (fin.dividend == null && q.trailingAnnualDividendYield > 0) fin.dividend = q.trailingAnnualDividendYield;
            mergeIfNull('high52', q.fiftyTwoWeekHigh);
            mergeIfNull('low52', q.fiftyTwoWeekLow);
            mergeIfNull('open', q.regularMarketOpen);
            mergeIfNull('dayHigh', q.regularMarketDayHigh);
            mergeIfNull('dayLow', q.regularMarketDayLow);
            mergeIfNull('avgVol', q.averageDailyVolume3Month);
        };

        const api3 = async () => {
            // 방법 3: v10 quoteSummary
            const summaryUrl = `https://query1.finance.yahoo.com/v10/finance/quoteSummary/${symbol}?modules=defaultKeyStatistics,financialData,summaryDetail,price`;
            const summaryData = await fetchWithProxy(summaryUrl);
            const r = summaryData?.quoteSummary?.result?.[0];
            if (!r) return;
            const sd = r.summaryDetail || {};
            const fd = r.financialData || {};
            const pr = r.price || {};
            const ks = r.defaultKeyStatistics || {};
            mergeIfNull('marketCap', pr.marketCap?.raw || sd.marketCap?.raw);
            mergeIfNull('per', sd.trailingPE?.raw);
            mergeIfNull('forwardPE', sd.forwardPE?.raw);
            mergeIfNull('pbr', sd.priceToBook?.raw);
            mergeIfNull('eps', ks.trailingEps?.raw);
            mergeIfNull('dividend', sd.dividendYield?.raw || sd.trailingAnnualDividendYield?.raw);
            mergeIfNull('revenue', fd.totalRevenue?.raw);
            mergeIfNull('profitMargin', fd.profitMargins?.raw);
            mergeIfNull('targetPrice', fd.targetMeanPrice?.raw);
            mergeIfNull('beta', ks.beta?.raw);
            mergeIfNull('high52', sd.fiftyTwoWeekHigh?.raw);
            mergeIfNull('low52', sd.fiftyTwoWeekLow?.raw);
        };

        // ★ 병렬 실행 후 최종 렌더링
        await Promise.allSettled([
            api1().catch(()=>{}),
            api2().catch(()=>{}),
            api3().catch(()=>{})
        ]);

        // API 결과로 그리드 업데이트
        renderGrid();
    }

    // ========================================
    // Stock Earnings Schedule (종목별 실적 발표)
    // ========================================
    async function renderStockEarnings(symbol) {
        const container = document.getElementById('stockEarnings');
        if (!container) return;
        container.innerHTML = '<div class="se-empty">실적 발표 일정을 불러오는 중...</div>';

        try {
            // Yahoo Finance calendarEvents + earningsHistory
            const url = `https://query1.finance.yahoo.com/v10/finance/quoteSummary/${symbol}?modules=calendarEvents,earningsHistory,earnings`;
            const data = await fetchWithProxy(url);
            const result = data?.quoteSummary?.result?.[0];
            if (!result) throw new Error('no data');

            const calEvents = result.calendarEvents || {};
            const earningsHist = result.earningsHistory?.history || [];
            const earningsData = result.earnings?.earningsChart || {};

            let html = '';

            // 다음 실적 발표일
            const nextDate = calEvents.earnings?.earningsDate;
            if (nextDate && nextDate.length > 0) {
                const rawEpoch = nextDate[0]?.raw;
                if (rawEpoch) {
                    const nd = new Date(rawEpoch * 1000);
                    // KST 변환 (UTC + 9시간)
                    const kstDate = new Date(nd.getTime() + 9 * 3600 * 1000);
                    const now = new Date();
                    const diffDays = Math.ceil((nd.getTime() - now.getTime()) / 86400000);
                    const isPast = diffDays < 0;

                    const dayNames = ['일','월','화','수','목','금','토'];
                    const dateLabel = `${kstDate.getUTCFullYear()}년 ${kstDate.getUTCMonth()+1}월 ${kstDate.getUTCDate()}일 (${dayNames[kstDate.getUTCDay()]})`;

                    let rangeLabel = '';
                    if (nextDate.length > 1) {
                        const nd2 = new Date(nextDate[1].raw * 1000);
                        const kst2 = new Date(nd2.getTime() + 9 * 3600 * 1000);
                        rangeLabel = ` ~ ${kst2.getUTCMonth()+1}/${kst2.getUTCDate()}`;
                    }

                    let ddayText, ddayClass;
                    if (isPast) {
                        ddayText = '발표 완료';
                        ddayClass = 'done';
                    } else if (diffDays === 0) {
                        ddayText = 'D-DAY';
                        ddayClass = 'soon';
                    } else if (diffDays <= 7) {
                        ddayText = `D-${diffDays}`;
                        ddayClass = 'soon';
                    } else {
                        ddayText = `D-${diffDays}`;
                        ddayClass = 'normal';
                    }

                    // EPS 예상치
                    const epsEst = calEvents.earnings?.earningsAverage?.raw;
                    const epsHigh = calEvents.earnings?.earningsHigh?.raw;
                    const epsLow = calEvents.earnings?.earningsLow?.raw;
                    const revEst = calEvents.earnings?.revenueAverage?.raw;

                    const isKR = currentMarket === 'KR';
                    const fmtEps = v => v != null ? (isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2)) : '-';
                    const fmtRev = v => {
                        if (v == null) return '-';
                        if (isKR) {
                            if (v >= 1e12) return (v/1e12).toFixed(1) + '조원';
                            if (v >= 1e8) return (v/1e8).toFixed(0) + '억원';
                            return Math.round(v).toLocaleString() + '원';
                        }
                        if (v >= 1e9) return '$' + (v/1e9).toFixed(2) + 'B';
                        if (v >= 1e6) return '$' + (v/1e6).toFixed(0) + 'M';
                        return '$' + v.toLocaleString();
                    };

                    html += `<div class="se-next">
                        <div class="se-next-icon ${isPast ? 'past' : 'upcoming'}">${isPast ? '&#9989;' : '&#128197;'}</div>
                        <div class="se-next-info">
                            <div class="se-next-label">${isPast ? '최근 실적 발표' : '다음 실적 발표 (KST)'}</div>
                            <div class="se-next-date">${dateLabel}${rangeLabel}</div>
                            <div class="se-next-detail">`;
                    if (epsEst != null) html += `EPS 예상: ${fmtEps(epsEst)}`;
                    if (epsLow != null && epsHigh != null) html += ` (${fmtEps(epsLow)} ~ ${fmtEps(epsHigh)})`;
                    if (revEst != null) html += ` · 매출 예상: ${fmtRev(revEst)}`;
                    html += `</div>
                        </div>
                        <span class="se-next-dday ${ddayClass}">${ddayText}</span>
                    </div>`;
                }
            }

            // 분기별 실적 히스토리
            if (earningsHist.length > 0) {
                html += `<div class="se-history">
                    <div class="se-history-title">지난 실적 발표 이력</div>`;

                const isKR = currentMarket === 'KR';
                const fmtEps = v => v != null ? (isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2)) : '-';

                earningsHist.slice().reverse().forEach(h => {
                    const qDate = h.quarter?.fmt || '-';
                    const epsActual = h.epsActual?.raw;
                    const epsEst = h.epsEstimate?.raw;
                    const surprise = h.surprisePercent?.raw;

                    let surpriseHtml = '';
                    if (surprise != null) {
                        const pct = (surprise * 100).toFixed(1);
                        if (surprise > 0.01) {
                            surpriseHtml = `<span class="se-surprise beat">+${pct}%</span>`;
                        } else if (surprise < -0.01) {
                            surpriseHtml = `<span class="se-surprise miss">${pct}%</span>`;
                        } else {
                            surpriseHtml = `<span class="se-surprise meet">부합</span>`;
                        }
                    }

                    html += `<div class="se-history-item">
                        <div class="se-history-date">${qDate}</div>
                        <div class="se-history-eps">
                            <div class="se-eps-box"><div class="se-eps-label">실제</div><div class="se-eps-val">${fmtEps(epsActual)}</div></div>
                            <div class="se-eps-box"><div class="se-eps-label">예상</div><div class="se-eps-val">${fmtEps(epsEst)}</div></div>
                        </div>
                        ${surpriseHtml}
                    </div>`;
                });

                html += `</div>`;
            }

            // 분기별 매출/수익 차트 데이터 (텍스트 요약)
            const quarterly = earningsData.quarterly || [];
            if (quarterly.length > 0 && !earningsHist.length) {
                html += `<div class="se-history"><div class="se-history-title">분기별 EPS</div>`;
                const isKR = currentMarket === 'KR';
                const fmtEps = v => v != null ? (isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2)) : '-';
                quarterly.forEach(q => {
                    html += `<div class="se-history-item">
                        <div class="se-history-date">${q.date || '-'}</div>
                        <div class="se-history-eps">
                            <div class="se-eps-box"><div class="se-eps-label">실제</div><div class="se-eps-val">${fmtEps(q.actual?.raw)}</div></div>
                            <div class="se-eps-box"><div class="se-eps-label">예상</div><div class="se-eps-val">${fmtEps(q.estimate?.raw)}</div></div>
                        </div>
                    </div>`;
                });
                html += `</div>`;
            }

            if (!html) {
                html = '<div class="se-empty">이 종목의 실적 발표 일정 정보가 없습니다.</div>';
            }

            container.innerHTML = html;
        } catch(e) {
            container.innerHTML = '<div class="se-empty">실적 발표 일정을 불러올 수 없습니다.</div>';
        }
    }

    // ========================================
    // Company Profile (기업 정보)
    // ========================================
    // 백엔드 API를 통해 데이터 조회 (실패 시 null 반환)
    async function fetchRace(url, timeout = 5000) {
        try { return await fetchWithProxy(url, timeout); }
        catch(e) { return null; }
    }

    // 기업 프로필 캐시 (같은 종목 재검색 시 즉시 표시)
    const cpCache = {};

    async function renderCompanyProfile(symbol) {
        const ovEl = document.getElementById('companyOverview');
        const exEl = document.getElementById('companyExecutives');
        const hdEl = document.getElementById('companyHolders');
        const inEl = document.getElementById('companyInsider');
        if (!ovEl) return;

        const fmtMoney = v => { if(v==null||isNaN(v)) return '-'; if(v>=1e9) return '$'+(v/1e9).toFixed(1)+'B'; if(v>=1e6) return '$'+(v/1e6).toFixed(1)+'M'; if(v>=1e3) return '$'+(v/1e3).toFixed(0)+'K'; return '$'+Number(v).toLocaleString(); };
        const fmtShares = v => { if(v==null) return '-'; if(v>=1e9) return (v/1e9).toFixed(2)+'B'; if(v>=1e6) return (v/1e6).toFixed(1)+'M'; if(v>=1e3) return (v/1e3).toFixed(0)+'K'; return Number(v).toLocaleString(); };
        const fmtCap = mc => { if(mc==null) return '-'; if(mc>=1e12) return '$'+(mc/1e12).toFixed(2)+'T'; if(mc>=1e9) return '$'+(mc/1e9).toFixed(1)+'B'; if(mc>=1e6) return '$'+(mc/1e6).toFixed(0)+'M'; return '$'+Number(mc).toLocaleString(); };

        // 캐시 히트 → 즉시 렌더
        if (cpCache[symbol]) {
            renderCPData(cpCache[symbol], ovEl, exEl, hdEl, inEl, fmtMoney, fmtShares, fmtCap);
            return;
        }

        ovEl.innerHTML = exEl.innerHTML = hdEl.innerHTML = inEl.innerHTML = '<div class="cp-empty" style="display:flex;align-items:center;justify-content:center;gap:8px;"><div class="spinner" style="width:16px;height:16px;border-width:2px;"></div> 불러오는 중...</div>';

        // 단일 API 호출, 프록시 레이스
        const modules = 'assetProfile,majorHoldersBreakdown,institutionOwnership,insiderTransactions,price';
        const data = await fetchRace(`https://query1.finance.yahoo.com/v10/finance/quoteSummary/${symbol}?modules=${modules}`, 5000);
        const r = data?.quoteSummary?.result?.[0];

        if (r) cpCache[symbol] = r;
        renderCPData(r, ovEl, exEl, hdEl, inEl, fmtMoney, fmtShares, fmtCap);
    }

    function renderCPData(r, ovEl, exEl, hdEl, inEl, fmtMoney, fmtShares, fmtCap) {
        // === 개요 (기본정보 + 지분구성 + 거버넌스) ===
        try {
            const ap = r?.assetProfile || {};
            const mh = r?.majorHoldersBreakdown || {};
            const pr = r?.price || {};
            if (!ap.sector && !ap.industry) throw new Error('no data');

            const cleanSymbol = (pr.symbol || '').replace(/\.(KS|KQ)$/, '');
            const companyName = pr.shortName || pr.longName || cleanSymbol;
            let html = '';

            // 헤더
            html += `<div class="cp-overview"><div class="cp-logo">${cleanSymbol.charAt(0)}</div><div class="cp-info"><div class="cp-name">${companyName}</div><div class="cp-meta">`;
            if (ap.sector) html += `<span>🏢 ${ap.sector}</span>`;
            if (ap.industry) html += `<span>🔧 ${ap.industry}</span>`;
            if (ap.country) html += `<span>🌍 ${ap.country}</span>`;
            html += `</div></div></div>`;

            // 기업 기본정보 2컬럼 그리드
            const rows = [];
            if (pr.exchangeName) rows.push({ l:'거래소', v:pr.exchangeName });
            if (ap.industry) rows.push({ l:'산업', v:ap.industry });
            if (ap.sector) rows.push({ l:'섹터', v:ap.sector });
            if (pr.marketCap?.raw) rows.push({ l:'시가총액', v:fmtCap(pr.marketCap.raw) });
            if (ap.fullTimeEmployees) rows.push({ l:'직원 수', v:Number(ap.fullTimeEmployees).toLocaleString()+'명' });
            if (ap.website) rows.push({ l:'홈페이지', v:`<a href="${ap.website}" target="_blank" rel="noopener" style="color:var(--blue);text-decoration:none;font-size:12px;">${ap.website.replace(/^https?:\/\/(www\.)?/,'')}</a>` });
            if (ap.address1) rows.push({ l:'주소', v:[ap.city,ap.state,ap.country].filter(Boolean).join(', ') });
            if (ap.phone) rows.push({ l:'전화', v:ap.phone });
            if (rows.length % 2 !== 0) rows.push({ l:'', v:'' });
            if (rows.length) {
                html += `<div class="cp-section-title">📋 기업 기본정보</div><div class="cp-info-grid">`;
                html += rows.map(i => i.l ? `<div class="cp-info-row"><span class="cp-info-label">${i.l}</span><span class="cp-info-value">${i.v}</span></div>` : `<div class="cp-info-row" style="visibility:hidden"></div>`).join('');
                html += `</div>`;
            }

            // 지분 구성
            if (mh.insidersPercentHeld?.raw != null || mh.institutionsPercentHeld?.raw != null) {
                html += `<div class="cp-section-title">📊 지분 구성</div><div class="cp-shares-grid">`;
                if (mh.insidersPercentHeld?.raw != null) html += `<div class="cp-shares-card"><div class="cp-shares-label">내부자 보유</div><div class="cp-shares-value" style="color:var(--yellow)">${(mh.insidersPercentHeld.raw*100).toFixed(2)}%</div></div>`;
                if (mh.institutionsPercentHeld?.raw != null) html += `<div class="cp-shares-card"><div class="cp-shares-label">기관 보유</div><div class="cp-shares-value" style="color:var(--cyan)">${(mh.institutionsPercentHeld.raw*100).toFixed(2)}%</div></div>`;
                if (mh.institutionsFloatPercentHeld?.raw != null) html += `<div class="cp-shares-card"><div class="cp-shares-label">유동주식 대비 기관</div><div class="cp-shares-value" style="color:var(--blue)">${(mh.institutionsFloatPercentHeld.raw*100).toFixed(2)}%</div></div>`;
                if (mh.institutionsCount?.raw != null) html += `<div class="cp-shares-card"><div class="cp-shares-label">기관 투자자 수</div><div class="cp-shares-value" style="color:var(--text)">${Number(mh.institutionsCount.raw).toLocaleString()}개</div></div>`;
                html += `</div>`;
            }

            // 거버넌스 위험
            if (ap.overallRisk != null) {
                const risks = [{l:'종합 위험',v:ap.overallRisk},{l:'감사 위험',v:ap.auditRisk},{l:'이사회 위험',v:ap.boardRisk},{l:'보상 위험',v:ap.compensationRisk},{l:'주주권리 위험',v:ap.shareHolderRightsRisk}].filter(x=>x.v!=null);
                if (risks.length % 2 !== 0) risks.push({l:'',v:null});
                html += `<div class="cp-section-title">⚖️ 거버넌스 위험</div><div class="cp-info-grid">`;
                html += risks.map(i => i.l ? `<div class="cp-info-row"><span class="cp-info-label">${i.l}</span><span class="cp-info-value" style="color:${i.v<=3?'var(--green)':i.v<=6?'var(--yellow)':'var(--red)'}">${i.v}/10</span></div>` : `<div class="cp-info-row" style="visibility:hidden"></div>`).join('');
                html += `</div>`;
            }
            ovEl.innerHTML = html;
        } catch(e) { ovEl.innerHTML = '<div class="cp-empty">기업 개요를 불러올 수 없습니다.</div>'; }

        // === 주요 임원 ===
        try {
            const officers = r?.assetProfile?.companyOfficers || [];
            if (!officers.length) throw 0;
            let html = '<table class="cp-exec-table"><thead><tr><th>이름</th><th>직함</th><th>연봉</th></tr></thead><tbody>';
            officers.slice(0,10).forEach(o => { html += `<tr><td><div class="cp-exec-name">${o.name||'-'}</div></td><td style="color:var(--text2);font-size:12px;">${o.title||'-'}</td><td><span class="cp-exec-pay">${o.totalPay?.raw ? fmtMoney(o.totalPay.raw) : '-'}</span></td></tr>`; });
            html += '</tbody></table>';
            exEl.innerHTML = html;
        } catch(e) { exEl.innerHTML = '<div class="cp-empty">임원 정보를 불러올 수 없습니다.</div>'; }

        // === 주요 투자 기관 ===
        try {
            const inst = r?.institutionOwnership?.ownershipList || [];
            if (!inst.length) throw 0;
            let html = '<div class="cp-holder-list">';
            inst.slice(0,15).forEach((h,i) => { html += `<div class="cp-holder-item"><div class="cp-holder-rank">${i+1}</div><div class="cp-holder-name">${h.organization||'-'}</div><div class="cp-holder-pct">${h.pctHeld?.raw!=null?(h.pctHeld.raw*100).toFixed(2)+'%':'-'}</div><div class="cp-holder-shares">${fmtShares(h.position?.raw)}</div></div>`; });
            html += '</div>';
            hdEl.innerHTML = html;
        } catch(e) { hdEl.innerHTML = '<div class="cp-empty">투자 기관 정보를 불러올 수 없습니다.</div>'; }

        // === 최근 내부자 거래 ===
        try {
            const txns = r?.insiderTransactions?.transactions || [];
            if (!txns.length) throw 0;
            let html = '<div class="cp-insider-scroll"><table class="cp-insider-table"><thead><tr><th>거래일</th><th>거래자</th><th>취득/처분</th><th>거래타입</th><th>수량</th><th>가치</th></tr></thead><tbody>';
            txns.slice(0,20).forEach(t => {
                const text = t.transactionText||'';
                const isBuy = /purchase|acquisition|exercise|award|grant/i.test(text);
                const isSell = /sale|sell|dispos/i.test(text);
                html += `<tr><td style="white-space:nowrap">${t.startDate?.fmt||'-'}</td><td style="max-width:110px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${t.filerName||''}">${t.filerName||'-'}</td><td class="${isBuy?'cp-insider-buy':isSell?'cp-insider-sell':''}">${isBuy?'취득':isSell?'처분':'-'}</td><td style="font-size:11px;color:var(--text3);max-width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${text.split(' - ')[0]||''}">${text.split(' - ')[0]||'-'}</td><td>${t.shares?.raw?fmtShares(t.shares.raw):'-'}</td><td>${t.value?.raw?fmtMoney(t.value.raw):'-'}</td></tr>`;
            });
            html += '</tbody></table></div>';
            inEl.innerHTML = html;
        } catch(e) { inEl.innerHTML = '<div class="cp-empty">내부자 거래 정보를 불러올 수 없습니다.</div>'; }
    }

    // ========================================
    // AI Analysis Engine (단타 + 스윙)
    // ========================================
    let currentTradeStyle = 'day';
    function switchTradeStyle(style) {
        currentTradeStyle = style;
        document.querySelectorAll('.trade-style-tab').forEach(t => t.classList.toggle('active', t.dataset.tstyle === style));
        document.querySelectorAll('.trade-style-panel').forEach(p => p.classList.toggle('active', p.dataset.tstyle === style));
        if (stockData) { renderRRAnalysis(); _applyRRGate(); }
    }

    function renderAIAnalysis() {
        renderDayAnalysis();
        renderSwingAnalysis();
        renderDayIndicators();
        renderSwingIndicators();
        _applyRRGate();
    }

    function getAnalysisData() {
        const quotes = stockData.indicators.quote[0];
        const closes = quotes.close.filter(v => v != null);
        const volumes = quotes.volume.filter(v => v != null);
        const highs = quotes.high.filter(v => v != null);
        const lows = quotes.low.filter(v => v != null);
        const price = closes[closes.length - 1];
        const ma5 = calcSMA(closes, 5); const ma10 = calcSMA(closes, 10); const ma20 = calcSMA(closes, 20);
        const ma60 = calcSMA(closes, 60); const ma120 = calcSMA(closes, 120);
        const rsi = calcRSI(closes);
        const { macdLine, signalLine, histogram } = calcMACD(closes);
        const bb = calcBollingerBands(closes);
        const stoch = calcStochastic(highs, lows, closes);
        return { quotes, closes, volumes, highs, lows, price, ma5, ma10, ma20, ma60, ma120, rsi, macdLine, signalLine, histogram, bb, stoch };
    }

    function renderScoreCard(prefix, totalScore, details, type) {
        const isDay = type === 'day';
        let recommendation, recColor, summary;
        if (isDay) {
            if (totalScore >= 75) { recommendation = '강력 진입'; recColor = 'var(--green)'; summary = '단기 모멘텀이 매우 강합니다. 거래량 동반 상승으로 빠른 수익 기회가 있습니다.'; }
            else if (totalScore >= 60) { recommendation = '진입 가능'; recColor = 'var(--green)'; summary = '단기 지표가 긍정적입니다. 분봉 흐름을 확인하고 타이트한 손절로 진입하세요.'; }
            else if (totalScore >= 45) { recommendation = '관망'; recColor = 'var(--yellow)'; summary = '단기 방향성이 불확실합니다. 명확한 돌파 또는 지지 확인 후 진입하세요.'; }
            else if (totalScore >= 30) { recommendation = '위험'; recColor = 'var(--red)'; summary = '단기 하락 모멘텀이 우세합니다. 반등 확인 전까지 매수를 자제하세요.'; }
            else { recommendation = '매수 금지'; recColor = 'var(--red)'; summary = '단기 급락 위험이 높습니다. 거래량 감소와 함께 하락 추세가 강화되고 있습니다.'; }
        } else {
            if (totalScore >= 75) { recommendation = '적극 매수'; recColor = 'var(--green)'; summary = '중기 추세가 강한 상승세이며, 눌림목 매수 또는 분할 진입에 적합합니다.'; }
            else if (totalScore >= 60) { recommendation = '매수 고려'; recColor = 'var(--green)'; summary = '추세 전환 초기 또는 상승 추세 지속 중입니다. 분할 매수로 진입하세요.'; }
            else if (totalScore >= 45) { recommendation = '관망'; recColor = 'var(--yellow)'; summary = '추세가 혼조세입니다. 이동평균선 정배열이나 돌파 확인 후 진입하세요.'; }
            else if (totalScore >= 30) { recommendation = '매도 고려'; recColor = 'var(--red)'; summary = '중기 하락 추세가 형성 중입니다. 보유 중이라면 비중 축소를 고려하세요.'; }
            else { recommendation = '강력 매도'; recColor = 'var(--red)'; summary = '이동평균선 역배열과 함께 하락 추세가 뚜렷합니다. 손절이 필요합니다.'; }
        }
        const el = (id) => document.getElementById(id);
        const circle = el(prefix + 'ScoreCircle');
        if (circle) { circle.style.setProperty('--score', totalScore); circle.style.setProperty('--score-color', recColor); }
        const numEl = el(prefix + 'ScoreNumber'); if (numEl) { numEl.textContent = totalScore; numEl.style.color = recColor; }
        const recEl = el(prefix + 'Recommendation'); if (recEl) { recEl.textContent = recommendation; recEl.style.color = recColor; }
        const sumEl = el(prefix + 'Summary'); if (sumEl) { sumEl.textContent = summary; }
        const detEl = el(prefix + 'Details');
        if (detEl) {
            detEl.innerHTML = details.map(d => `
                <div class="ai-detail-item">
                    <div class="ai-detail-title">
                        <span style="color:${d.color}">${d.title}</span>
                        <span style="font-size:12px;color:var(--text3);font-weight:400;">${d.score}점</span>
                    </div>
                    <div class="ai-detail-text">${d.text}</div>
                    <div class="ai-bar"><div class="ai-bar-fill" style="width:${d.score}%;background:${d.color}"></div></div>
                </div>
            `).join('');
        }
    }

    function renderDayAnalysis() {
        const d = getAnalysisData();
        const { closes, price, volumes, ma5, ma10, ma20, rsi, macdLine, signalLine, histogram, bb, stoch } = d;
        const scores = []; const details = [];
        const c = v => v >= 60 ? 'var(--green)' : v <= 40 ? 'var(--red)' : 'var(--yellow)';

        // 1. 단기 모멘텀 (MA5 vs MA10) - 20%
        let s1 = 50, t1 = '';
        const lma5 = ma5.filter(v=>v!=null).pop(); const lma10 = ma10.filter(v=>v!=null).pop();
        const pma5 = ma5.filter(v=>v!=null).slice(-2)[0]; const pma10 = ma10.filter(v=>v!=null).slice(-2)[0];
        const golden5_10 = pma5 && pma10 && pma5 <= pma10 && lma5 > lma10;
        const dead5_10 = pma5 && pma10 && pma5 >= pma10 && lma5 < lma10;
        if (golden5_10) { s1 = 90; t1 = 'MA5가 MA10을 상향 돌파(골든크로스). 단기 강한 상승 모멘텀.'; }
        else if (dead5_10) { s1 = 15; t1 = 'MA5가 MA10을 하향 돌파(데드크로스). 단기 급락 위험.'; }
        else if (price > lma5 && lma5 > lma10) { s1 = 75; t1 = '주가 > MA5 > MA10 정배열. 단기 상승 흐름 유지.'; }
        else if (price < lma5 && lma5 < lma10) { s1 = 20; t1 = '주가 < MA5 < MA10 역배열. 단기 하락 추세.'; }
        else { s1 = 50; t1 = '단기 이평선 혼조세. 방향성 불확실.'; }
        scores.push({ w: .20, s: s1 }); details.push({ title: '단기 모멘텀 (MA5/10)', color: c(s1), score: s1, text: t1 });

        // 2. RSI 단타 적합도 - 20%
        const lastRSI = rsi.filter(v=>v!=null).pop() || 50;
        const prevRSIs = rsi.filter(v=>v!=null).slice(-5);
        const rsiDir = prevRSIs.length >= 3 ? prevRSIs[prevRSIs.length-1] - prevRSIs[prevRSIs.length-3] : 0;
        let s2 = 50, t2 = '';
        if (lastRSI >= 75) { s2 = 20; t2 = `RSI ${lastRSI.toFixed(1)} 극단적 과매수. 단타 진입 시 고점 물릴 위험 큼.`; }
        else if (lastRSI >= 60 && rsiDir > 0) { s2 = 80; t2 = `RSI ${lastRSI.toFixed(1)} 상승 중. 매수 모멘텀 강해 단타 유리.`; }
        else if (lastRSI >= 50 && rsiDir > 0) { s2 = 70; t2 = `RSI ${lastRSI.toFixed(1)} 중립~강세 전환 중. 돌파 시 단타 적합.`; }
        else if (lastRSI <= 30) { s2 = 65; t2 = `RSI ${lastRSI.toFixed(1)} 과매도 반등 구간. 기술적 반등 단타 기회.`; }
        else if (lastRSI < 40 && rsiDir < 0) { s2 = 25; t2 = `RSI ${lastRSI.toFixed(1)} 약세 지속. 반등 확인 전 단타 자제.`; }
        else { s2 = 45; t2 = `RSI ${lastRSI.toFixed(1)} 중립. 방향성 확인 필요.`; }
        scores.push({ w: .20, s: s2 }); details.push({ title: 'RSI 단타 적합도', color: c(s2), score: s2, text: t2 });

        // 3. 거래량 급변 (단타 핵심) - 25%
        let s3 = 50, t3 = '';
        if (volumes.length >= 20) {
            const curVol = volumes[volumes.length-1] || 0;
            const avgVol20 = volumes.slice(-20).reduce((a,b)=>a+b,0)/20;
            const volSpike = curVol / avgVol20;
            const isUp = closes[closes.length-1] >= (closes[closes.length-2] || closes[closes.length-1]);
            if (volSpike >= 2.5 && isUp) { s3 = 95; t3 = `거래량 ${Math.round(volSpike*100)}% 폭발적 증가 + 상승! 세력 매집 가능성. 빠른 단타 기회.`; }
            else if (volSpike >= 1.5 && isUp) { s3 = 78; t3 = `거래량 ${Math.round(volSpike*100)}% 증가 + 상승. 매수세 유입 중 단타 유리.`; }
            else if (volSpike >= 2.0 && !isUp) { s3 = 15; t3 = `거래량 ${Math.round(volSpike*100)}% 급증 + 하락! 투매성 매도. 단타 금지.`; }
            else if (volSpike >= 1.5 && !isUp) { s3 = 30; t3 = '거래량 증가 + 하락. 매도세 우세. 단타 위험.'; }
            else if (volSpike < 0.5) { s3 = 35; t3 = `거래량 극감(${Math.round(volSpike*100)}%). 유동성 부족. 단타 부적합.`; }
            else { s3 = 50; t3 = '거래량 평균 수준. 뚜렷한 단타 신호 없음.'; }
        }
        scores.push({ w: .25, s: s3 }); details.push({ title: '거래량 급변 분석', color: c(s3), score: s3, text: t3 });

        // 4. Stochastic (단타 과열) - 20%
        const lastK = stoch.kLine.filter(v=>v!=null).pop() || 50;
        const lastD = stoch.dLine.filter(v=>v!=null).pop() || 50;
        const prevK = stoch.kLine.filter(v=>v!=null).slice(-2)[0] || 50;
        let s4 = 50, t4 = '';
        if (lastK <= 20 && lastK > prevK) { s4 = 85; t4 = `Stochastic K ${lastK.toFixed(0)} 과매도에서 반등! 단타 매수 적기.`; }
        else if (lastK <= 20) { s4 = 60; t4 = `Stochastic K ${lastK.toFixed(0)} 과매도 구간. 반등 신호 대기.`; }
        else if (lastK >= 80 && lastK < prevK) { s4 = 20; t4 = `Stochastic K ${lastK.toFixed(0)} 과매수에서 하락 전환! 단타 매도.`; }
        else if (lastK >= 80) { s4 = 35; t4 = `Stochastic K ${lastK.toFixed(0)} 과매수. 추가 상승 제한적.`; }
        else if (lastK > lastD && lastK > prevK) { s4 = 70; t4 = `Stochastic K(${lastK.toFixed(0)}) > D(${lastD.toFixed(0)}) 상승 중.`; }
        else { s4 = 45; t4 = `Stochastic K ${lastK.toFixed(0)} 중립.`; }
        scores.push({ w: .20, s: s4 }); details.push({ title: 'Stochastic 과열도', color: c(s4), score: s4, text: t4 });

        // 5. 볼린저밴드 스퀴즈/확장 - 15%
        const lbbu = bb.upper.filter(v=>v!=null).pop(); const lbbl = bb.lower.filter(v=>v!=null).pop(); const lbbm = bb.middle.filter(v=>v!=null).pop();
        let s5 = 50, t5 = '';
        if (lbbu && lbbl && lbbm) {
            const bw = (lbbu - lbbl) / lbbm * 100;
            const bbPos = (price - lbbl) / (lbbu - lbbl);
            if (bw < 3) { s5 = 70; t5 = `밴드폭 ${bw.toFixed(1)}% 극도 좁음(스퀴즈). 큰 변동 예상!`; }
            else if (bbPos > 1) { s5 = 30; t5 = '상단 이탈! 과매수 극단. 되돌림 가능성 높음.'; }
            else if (bbPos < 0) { s5 = 65; t5 = '하단 이탈! 기술적 반등 단타 기회.'; }
            else if (bbPos >= 0.7 && bw > 5) { s5 = 60; t5 = '밴드 확장 + 상단 근접. 추세 가속 가능.'; }
            else { s5 = 50; t5 = '볼린저밴드 중앙 부근. 방향성 확인 필요.'; }
        }
        scores.push({ w: .15, s: s5 }); details.push({ title: '밴드 스퀴즈/확장', color: c(s5), score: s5, text: t5 });

        const total = Math.round(scores.reduce((sum, x) => sum + x.w * x.s, 0));
        renderScoreCard('day', total, details, 'day');
    }

    function renderSwingAnalysis() {
        const d = getAnalysisData();
        const { closes, price, volumes, ma5, ma20, ma60, ma120, rsi, macdLine, signalLine, histogram, bb } = d;
        const scores = []; const details = [];
        const c = v => v >= 60 ? 'var(--green)' : v <= 40 ? 'var(--red)' : 'var(--yellow)';

        // 1. 추세 (MA20/60/120 배열) - 25%
        let s1 = 50, t1 = '';
        const lma20 = ma20.filter(v=>v!=null).pop(); const lma60 = ma60.filter(v=>v!=null).pop(); const lma120 = ma120.filter(v=>v!=null).pop();
        const above20 = price > lma20; const above60 = lma20 > lma60; const above120 = lma60 > lma120;
        const aligned = [above20, above60, above120].filter(Boolean).length;
        if (aligned === 3) { s1 = 90; t1 = 'MA20>MA60>MA120 완벽 정배열. 스윙 매수 적합.'; }
        else if (aligned >= 2 && above20) { s1 = 70; t1 = '중기 이평선 정배열 진행 중. 추세 전환 초기 가능성.'; }
        else if (aligned >= 1) { s1 = 45; t1 = '이평선 혼조세. 추세 확인 후 스윙 진입.'; }
        else { s1 = 15; t1 = '역배열 상태. 하락 추세. 스윙 매수 부적합.'; }
        scores.push({ w: .25, s: s1 }); details.push({ title: '중기 추세 (MA20/60/120)', color: c(s1), score: s1, text: t1 });

        // 2. MACD 추세 - 25%
        const lastMACD = macdLine.filter(v=>v!=null).pop() || 0; const lastSig = signalLine.filter(v=>v!=null).pop() || 0;
        const lastHist = histogram.filter(v=>v!=null).pop() || 0;
        const prevHists = histogram.filter(v=>v!=null).slice(-5);
        const histDir = prevHists.length >= 3 ? prevHists[prevHists.length-1] - prevHists[prevHists.length-3] : 0;
        const ml = macdLine.filter(v=>v!=null); const sl = signalLine.filter(v=>v!=null);
        const macdGolden = ml.length >= 2 && sl.length >= 2 && (ml[ml.length-2]-sl[sl.length-2]) < 0 && (lastMACD-lastSig) >= 0;
        const macdDead = ml.length >= 2 && sl.length >= 2 && (ml[ml.length-2]-sl[sl.length-2]) > 0 && (lastMACD-lastSig) <= 0;
        let s2 = 50, t2 = '';
        if (macdGolden) { s2 = 90; t2 = 'MACD 골든크로스! 스윙 매수 강력 신호.'; }
        else if (macdDead) { s2 = 10; t2 = 'MACD 데드크로스! 스윙 매도 신호.'; }
        else if (lastMACD > lastSig && histDir > 0) { s2 = 78; t2 = 'MACD 매수세 확대. 상승 모멘텀 강화 중.'; }
        else if (lastMACD > lastSig) { s2 = 55; t2 = 'MACD 매수 구간이나 모멘텀 약화 중.'; }
        else if (lastMACD < lastSig && histDir < 0) { s2 = 20; t2 = 'MACD 매도세 강화. 하락 모멘텀 주의.'; }
        else { s2 = 40; t2 = 'MACD 매도 구간. 모멘텀 변화 관찰.'; }
        scores.push({ w: .25, s: s2 }); details.push({ title: 'MACD 추세 분석', color: c(s2), score: s2, text: t2 });

        // 3. RSI 중기 강도 - 20%
        const lastRSI = rsi.filter(v=>v!=null).pop() || 50;
        let s3 = 50, t3 = '';
        if (lastRSI >= 70) { s3 = 35; t3 = `RSI ${lastRSI.toFixed(1)} 과매수. 차익 실현 구간.`; }
        else if (lastRSI >= 55) { s3 = 75; t3 = `RSI ${lastRSI.toFixed(1)} 건강한 상승. 스윙 매수/보유 적합.`; }
        else if (lastRSI >= 40) { s3 = 55; t3 = `RSI ${lastRSI.toFixed(1)} 중립. 추세 방향 따라 판단.`; }
        else if (lastRSI >= 30) { s3 = 65; t3 = `RSI ${lastRSI.toFixed(1)} 저점 구간. 지지 확인 후 스윙 매수 기회.`; }
        else { s3 = 70; t3 = `RSI ${lastRSI.toFixed(1)} 과매도! 기술적 반등 스윙 기회.`; }
        scores.push({ w: .20, s: s3 }); details.push({ title: 'RSI 중기 강도', color: c(s3), score: s3, text: t3 });

        // 4. 볼린저밴드 위치 - 15%
        const lbbu = bb.upper.filter(v=>v!=null).pop(); const lbbl = bb.lower.filter(v=>v!=null).pop(); const lbbm = bb.middle.filter(v=>v!=null).pop();
        let s4 = 50, t4 = '';
        if (lbbu && lbbl && lbbm) {
            const bbPos = (price - lbbl) / (lbbu - lbbl);
            if (bbPos >= 0.3 && bbPos <= 0.6 && price > lbbm) { s4 = 70; t4 = '밴드 중앙~상단 안정적 상승. 스윙 보유 적합.'; }
            else if (bbPos < 0.2) { s4 = 65; t4 = '밴드 하단 근접. 지지 반등 스윙 매수 구간.'; }
            else if (bbPos > 0.9) { s4 = 30; t4 = '밴드 상단 과열. 차익 실현 고려.'; }
            else { s4 = 50; t4 = '밴드 중앙 부근. 방향성 확인 필요.'; }
        }
        scores.push({ w: .15, s: s4 }); details.push({ title: '볼린저밴드 위치', color: c(s4), score: s4, text: t4 });

        // 5. 거래량 추세 - 15%
        let s5 = 50, t5 = '';
        if (volumes.length >= 20) {
            const avgVol5 = volumes.slice(-5).reduce((a,b)=>a+b,0)/5;
            const avgVol20 = volumes.slice(-20).reduce((a,b)=>a+b,0)/20;
            const volTrend = avgVol5/avgVol20;
            const isUp = closes[closes.length-1] >= (closes[closes.length-6] || closes[closes.length-1]);
            if (volTrend >= 1.3 && isUp) { s5 = 80; t5 = '5일 거래량 증가 + 주가 상승. 기관/세력 매집 가능성.'; }
            else if (volTrend >= 1.3 && !isUp) { s5 = 25; t5 = '거래량 증가 + 하락. 매도세 유입.'; }
            else if (volTrend < 0.6 && isUp) { s5 = 60; t5 = '거래량 감소 + 소폭 상승. 조용한 매집 가능.'; }
            else if (volTrend < 0.6) { s5 = 40; t5 = '거래량 감소 + 하락. 관심 이탈.'; }
            else { s5 = 50; t5 = '거래량 평균 수준. 특별한 신호 없음.'; }
        }
        scores.push({ w: .15, s: s5 }); details.push({ title: '거래량 추세 분석', color: c(s5), score: s5, text: t5 });

        const total = Math.round(scores.reduce((sum, x) => sum + x.w * x.s, 0));
        renderScoreCard('swing', total, details, 'swing');
    }

    function renderDayIndicators() {
        const d = getAnalysisData();
        const { closes, price, volumes, ma5, ma10, rsi, stoch, bb } = d;
        const lastRSI = rsi.filter(v=>v!=null).pop() || 50;
        const lastK = stoch.kLine.filter(v=>v!=null).pop() || 50;
        const lastD = stoch.dLine.filter(v=>v!=null).pop() || 50;
        const lma5 = ma5.filter(v=>v!=null).pop(); const lma10 = ma10.filter(v=>v!=null).pop();
        const volNow = volumes[volumes.length-1] || 0;
        const avgVol20 = volumes.length >= 20 ? volumes.slice(-20).reduce((a,b)=>a+b,0)/20 : volNow;
        const volRatio = (volNow/avgVol20*100).toFixed(0);
        const chg1 = closes.length >= 2 ? ((closes[closes.length-1]-closes[closes.length-2])/closes[closes.length-2]*100).toFixed(2) : '0.00';
        const grid = document.getElementById('dayIndicatorGrid');
        if (!grid) return;
        grid.innerHTML = [
            { label: 'RSI(14)', value: lastRSI.toFixed(1), signal: lastRSI>=70?'매도':lastRSI<=30?'매수':'중립', color: lastRSI>=70?'var(--red)':lastRSI<=30?'var(--green)':'var(--yellow)' },
            { label: 'Stoch K', value: lastK.toFixed(1), signal: lastK>=80?'과매수':lastK<=20?'과매도':'중립', color: lastK>=80?'var(--red)':lastK<=20?'var(--green)':'var(--yellow)' },
            { label: 'Stoch D', value: lastD.toFixed(1), signal: lastK>lastD?'매수 우위':'매도 우위', color: lastK>lastD?'var(--green)':'var(--red)' },
            { label: 'MA5/MA10', value: lma5>lma10?'정배열':'역배열', signal: lma5>lma10?'상승':'하락', color: lma5>lma10?'var(--green)':'var(--red)' },
            { label: '거래량비', value: volRatio+'%', signal: volRatio>=150?'급증':volRatio<=50?'감소':'보통', color: volRatio>=150?'var(--cyan)':volRatio<=50?'var(--text3)':'var(--yellow)' },
            { label: '전일 대비', value: chg1+'%', signal: parseFloat(chg1)>=0?'상승':'하락', color: parseFloat(chg1)>=0?'var(--green)':'var(--red)' },
        ].map(i=>`<div class="indicator-item"><div class="indicator-label">${i.label}</div><div class="indicator-value" style="color:${i.color}">${i.value}</div><div class="indicator-signal" style="color:${i.color}">${i.signal}</div></div>`).join('');
    }

    function renderSwingIndicators() {
        const d = getAnalysisData();
        const { closes, price, volumes, ma20, ma60, ma120, rsi, macdLine, signalLine, histogram, bb } = d;
        const lastRSI = rsi.filter(v=>v!=null).pop() || 50;
        const lastMACD = macdLine.filter(v=>v!=null).pop() || 0; const lastSig = signalLine.filter(v=>v!=null).pop() || 0;
        const lastHist = histogram.filter(v=>v!=null).pop() || 0;
        const lma20 = ma20.filter(v=>v!=null).pop(); const lma60 = ma60.filter(v=>v!=null).pop(); const lma120 = ma120.filter(v=>v!=null).pop();
        const lbbu = bb.upper.filter(v=>v!=null).pop(); const lbbl = bb.lower.filter(v=>v!=null).pop();
        const bbPos = lbbu && lbbl ? ((price-lbbl)/(lbbu-lbbl)*100).toFixed(0) : '-';
        const avgVol5 = volumes.length >= 5 ? volumes.slice(-5).reduce((a,b)=>a+b,0)/5 : 0;
        const avgVol20 = volumes.length >= 20 ? volumes.slice(-20).reduce((a,b)=>a+b,0)/20 : avgVol5;
        const volTrend = avgVol20 > 0 ? (avgVol5/avgVol20*100).toFixed(0) : '-';
        const maAlign = (lma20>lma60 && lma60>lma120)?'정배열':(lma20<lma60 && lma60<lma120)?'역배열':'혼조';
        const grid = document.getElementById('swingIndicatorGrid');
        if (!grid) return;
        grid.innerHTML = [
            { label: 'MA 배열', value: maAlign, signal: maAlign==='정배열'?'상승 추세':maAlign==='역배열'?'하락 추세':'방향 불확실', color: maAlign==='정배열'?'var(--green)':maAlign==='역배열'?'var(--red)':'var(--yellow)' },
            { label: 'MACD', value: lastMACD.toFixed(2), signal: lastMACD>lastSig?'매수':'매도', color: lastMACD>lastSig?'var(--green)':'var(--red)' },
            { label: 'MACD Sig', value: lastSig.toFixed(2), signal: lastHist>0?'양(+)':'음(-)', color: lastHist>0?'var(--green)':'var(--red)' },
            { label: 'RSI(14)', value: lastRSI.toFixed(1), signal: lastRSI>=60?'강세':lastRSI<=40?'약세':'중립', color: lastRSI>=60?'var(--green)':lastRSI<=40?'var(--red)':'var(--yellow)' },
            { label: 'BB 위치', value: bbPos+'%', signal: bbPos>=80?'과열':bbPos<=20?'침체':'정상', color: bbPos>=80?'var(--red)':bbPos<=20?'var(--cyan)':'var(--yellow)' },
            { label: '거래량추세', value: volTrend+'%', signal: volTrend>=130?'증가':volTrend<=70?'감소':'보통', color: volTrend>=130?'var(--cyan)':volTrend<=70?'var(--text3)':'var(--yellow)' },
        ].map(i=>`<div class="indicator-item"><div class="indicator-label">${i.label}</div><div class="indicator-value" style="color:${i.color}">${i.value}</div><div class="indicator-signal" style="color:${i.color}">${i.signal}</div></div>`).join('');
    }


    // ========================================
    // Entry/Exit Timing (단타 + 스윙)
    // ========================================
    function renderEntryTiming() {
        renderDayEntry();
        renderSwingEntry();
        if (_isFallingKnife()) {
            ['dayEntry','swingEntry'].forEach(id => {
                const card = document.getElementById(id+'Card');
                if (card) card.className = 'card entry-card entry-danger';
            });
        }
    }
    function renderExitTiming() {
        renderDayExit();
        renderSwingExit();
    }

    // ========================================
    // 손익비(R/R) 분석 카드
    // ========================================
    function _isFallingKnife() {
        if (!stockData) return false;
        const closes = stockData.indicators.quote[0].close.filter(v => v != null);
        if (closes.length < 121) return false;
        const price = closes[closes.length - 1];
        const ma120 = calcSMA(closes, 120).filter(v => v != null).pop();
        const ma200 = calcSMA(closes, 200).filter(v => v != null).pop();
        const close5ago = closes.length >= 6 ? closes[closes.length - 6] : closes[0];
        return (ma120 && price < ma120 && (!ma200 || price < ma200) && price < close5ago);
    }

    function renderRRAnalysis() {
        const el = document.getElementById('rrAnalysis');
        if (!el || !stockData) return;
        const quotes  = stockData.indicators.quote[0];
        const closes  = quotes.close.filter(v => v != null);
        const highs   = quotes.high.filter(v => v != null);
        const lows    = quotes.low.filter(v => v != null);
        const volumes = quotes.volume.filter(v => v != null);
        if (closes.length < 21) { el.innerHTML = ''; return; }

        const isKR   = currentMarket === 'KR';
        const fmtP   = v => isKR ? Math.round(v).toLocaleString()+'원' : '$'+v.toFixed(2);
        const fmtPct = v => (v >= 0 ? '+' : '') + v.toFixed(1) + '%';
        const price  = closes[closes.length - 1];
        const isDay  = currentTradeStyle === 'day';
        const period = isDay ? 20 : 60;
        const label  = isDay ? '단타 20일' : '스윙 60일';

        // ATR-based Stop Loss (raw nullable arrays 사용)
        const atrArr = calcATR(quotes.high, quotes.low, quotes.close, 14);
        const atr    = atrArr.filter(v => v != null).pop() || price * 0.01;
        const sl     = price - atr * 1.5;

        // Volume Profile → TP1, TP2
        const profile = calcVolumeProfile(closes, volumes, period, 20);
        let res = findResistanceLevels(profile, price);
        if (!res.length) {
            res = [...highs.slice(-period)].filter(h => h > price*1.005).sort((a,b)=>a-b).slice(0,2);
        }
        const tp1 = res[0] || price * (isDay ? 1.025 : 1.05);
        const tp2 = res[1] || price * (isDay ? 1.05  : 1.10);

        // R/R
        const risk = price - sl, reward = tp1 - price;
        const rr   = risk > 0 ? reward / risk : 0;

        // Signal conditions
        const fallingKnife = _isFallingKnife();
        const ma20 = calcSMA(closes, 20).filter(v => v != null).pop();
        const ma60 = calcSMA(closes, 60).filter(v => v != null).pop();
        const inUptrend  = ma20 && ma60 && price > ma20 && ma20 > ma60;
        const nearSupport = (price - Math.min(...lows.slice(-20))) / price < 0.05;

        let action, actionClass, actionDesc;
        if (fallingKnife) {
            action='⛔ 매수 금지'; actionClass='rr-action-block';
            actionDesc='낙하하는 칼을 잡지 마세요. MA120·MA200 하회 + 하락 추세 감지.';
        } else if (rr < 1.5) {
            action='관망'; actionClass='rr-action-wait';
            actionDesc=`손익비 ${rr.toFixed(2)} — 진입 기준(1.5) 미달. 조건 개선 후 재검토.`;
        } else if (rr >= 2.0 && inUptrend) {
            action='적극 매수'; actionClass='rr-action-buy';
            actionDesc=`손익비 ${rr.toFixed(2)} + 상승 추세 확인. 우호적 진입 조건.`;
        } else {
            action='분할 매수'; actionClass='rr-action-partial';
            actionDesc=`손익비 ${rr.toFixed(2)}${nearSupport?' + 지지선 근접':''} — 분할 진입 고려.`;
        }
        const rrColor = rr >= 2.0 ? 'var(--green)' : rr >= 1.5 ? 'var(--yellow)' : 'var(--red)';
        const fkHtml = fallingKnife ? `<div class="rr-knife-warning">
            <span class="rr-knife-icon">⛔</span>
            <div><div class="rr-knife-title">낙하하는 칼 (Falling Knife) 경고</div>
            <div class="rr-knife-desc">MA120·MA200 동시 하회 + 5일 하락. 단기 RSI 과매도에도 매수 금지.</div></div>
        </div>` : '';

        el.innerHTML = `<div class="card rr-card">
            <div class="card-title">
                <span class="dot" style="background:var(--cyan)"></span>손익비 (R/R) 분석
                <span class="rr-basis-badge">${label}</span>
            </div>
            ${fkHtml}
            <div class="rr-action-row">
                <div class="rr-action-badge ${actionClass}">${action}</div>
                <div class="rr-action-desc">${actionDesc}</div>
            </div>
            <div class="rr-table">
                <div class="rr-row"><span class="rr-label">진입가 범위</span>
                    <span class="rr-value">${fmtP(price*0.995)} ~ ${fmtP(price*1.005)}</span></div>
                <div class="rr-row"><span class="rr-label">1차 목표가 (TP1)</span>
                    <span class="rr-value" style="color:var(--green)">${fmtP(tp1)}
                    <span class="rr-pct">${fmtPct((tp1-price)/price*100)}</span></span></div>
                <div class="rr-row"><span class="rr-label">2차 목표가 (TP2)</span>
                    <span class="rr-value" style="color:var(--green)">${fmtP(tp2)}
                    <span class="rr-pct">${fmtPct((tp2-price)/price*100)}</span></span></div>
                <div class="rr-row"><span class="rr-label">손절가 (SL · ATR×1.5)</span>
                    <span class="rr-value" style="color:var(--red)">${fmtP(sl)}
                    <span class="rr-pct">${fmtPct((sl-price)/price*100)}</span></span></div>
                <div class="rr-row"><span class="rr-label">ATR(14) 일평균 변동폭</span>
                    <span class="rr-value">${fmtP(atr)}</span></div>
                <div class="rr-row rr-row-rr"><span class="rr-label">손익비 (R/R)</span>
                    <span class="rr-value rr-ratio-value" style="color:${rrColor}">1 : ${rr.toFixed(2)}</span></div>
            </div>
            <div class="rr-legend">
                <span class="rr-legend-dot" style="background:var(--green)"></span><span>≥ 2.0 적극매수</span>
                <span class="rr-legend-dot" style="background:var(--yellow)"></span><span>1.5~2.0 분할매수</span>
                <span class="rr-legend-dot" style="background:var(--red)"></span><span>&lt; 1.5 관망</span>
            </div>
        </div>`;
    }

    // R/R Gate: 기술적 매수 추천이지만 R/R < 1.5이면 '관망'으로 강제 변환
    function _applyRRGate() {
        if (!stockData) return;
        const quotes  = stockData.indicators.quote[0];
        const closes  = quotes.close.filter(v => v != null);
        if (closes.length < 21) return;
        const price   = closes[closes.length - 1];
        const atrArr  = calcATR(quotes.high, quotes.low, quotes.close, 14);
        const atr     = atrArr.filter(v => v != null).pop() || price * 0.01;
        const sl      = price - atr * 1.5;
        const volumes = quotes.volume.filter(v => v != null);
        const period  = currentTradeStyle === 'day' ? 20 : 60;
        const profile = calcVolumeProfile(closes, volumes, period, 20);
        const res     = findResistanceLevels(profile, price);
        const tp1     = res[0] || price * (currentTradeStyle === 'day' ? 1.025 : 1.05);
        const risk = price - sl, reward = tp1 - price;
        const rr   = risk > 0 ? reward / risk : 0;
        if (rr >= 1.5) return;

        const prefix = currentTradeStyle === 'day' ? 'day' : 'swing';
        const recEl  = document.getElementById(prefix + 'Recommendation');
        const sumEl  = document.getElementById(prefix + 'Summary');
        if (recEl && !recEl.textContent.includes('매도')) {
            recEl.textContent = '관망 (R/R 미달)';
            recEl.style.color = 'var(--yellow)';
        }
        if (sumEl) {
            sumEl.textContent = `손익비 ${rr.toFixed(2)} — 기술적 지표와 무관하게 진입 기준(1.5) 미달로 관망 권장.`;
        }
    }

    // --- 공통 렌더 함수 ---
    function renderTimingCard(prefix, type, checks, passCount, totalChecks, strategyHtml) {
        const score = Math.round((passCount / totalChecks) * 100);
        const isEntry = type === 'entry';
        let verdict, verdictColor, verdictIcon, verdictClass, verdictDesc;
        if (isEntry) {
            if (passCount >= Math.ceil(totalChecks * 0.7)) {
                verdict = prefix === 'day' ? '단타 진입 적합' : '스윙 진입 적합';
                verdictColor = 'var(--green)';
                verdictIcon = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M8 12l3 3 5-5"/></svg>';
                verdictClass = 'entry-go';
                verdictDesc = prefix === 'day' ? '단타 진입 조건이 충족되었습니다. 타이트한 손절로 빠르게 진입하세요.' : '스윙 진입 조건이 충족되었습니다. 분할 매수로 진입하세요.';
            } else if (passCount >= Math.ceil(totalChecks * 0.4)) {
                verdict = '조건부 진입';
                verdictColor = 'var(--yellow)';
                verdictIcon = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M12 8v4M12 16h.01"/></svg>';
                verdictClass = 'entry-wait';
                verdictDesc = '일부 조건만 충족. 소량 진입하거나 추가 확인 후 진입하세요.';
            } else {
                verdict = '진입 대기 (관망)';
                verdictColor = 'var(--red)';
                verdictIcon = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6M9 9l6 6"/></svg>';
                verdictClass = 'entry-danger';
                verdictDesc = '진입 조건 미충족. 추세 전환 확인까지 대기하세요.';
            }
        } else {
            if (passCount >= Math.ceil(totalChecks * 0.7)) {
                verdict = prefix === 'day' ? '즉시 청산' : '즉시 매도';
                verdictColor = 'var(--red)';
                verdictIcon = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M8 8l8 8M16 8l-8 8"/></svg>';
                verdictClass = 'exit-sell';
                verdictDesc = prefix === 'day' ? '다수 청산 신호. 즉시 포지션을 정리하세요.' : '다수 매도 신호. 전량 또는 대부분 매도를 권장합니다.';
            } else if (passCount >= Math.ceil(totalChecks * 0.4)) {
                verdict = '부분 정리';
                verdictColor = 'var(--yellow)';
                verdictIcon = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M12 8v4M12 16h.01"/></svg>';
                verdictClass = 'exit-partial';
                verdictDesc = '일부 청산 신호. 물량 일부를 정리하고 추이를 지켜보세요.';
            } else {
                verdict = '보유 유지';
                verdictColor = 'var(--green)';
                verdictIcon = '<svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2.5"><circle cx="12" cy="12" r="10"/><path d="M8 12l3 3 5-5"/></svg>';
                verdictClass = 'exit-hold';
                verdictDesc = '매도 신호가 약합니다. 추세가 유지되고 있으니 보유하세요.';
            }
        }
        const elId = prefix + (isEntry ? 'Entry' : 'Exit');
        const card = document.getElementById(elId + 'Card');
        if (!card) return;
        card.className = `card ${isEntry?'entry':'exit'}-card ${verdictClass}`;
        const vEl = document.getElementById(elId + 'Verdict');
        if (vEl) vEl.innerHTML = `
            <div class="entry-icon">${verdictIcon}</div>
            <div class="entry-title" style="color:${verdictColor}">${verdict}</div>
            <div class="entry-subtitle">${verdictDesc}</div>
            <div class="entry-conditions-summary">
                <div class="entry-cond-count" style="color:${isEntry?'var(--green)':'var(--red)'}"><span class="num">${passCount}</span> ${isEntry?'충족':'신호'}</div>
                <div class="entry-cond-count" style="color:var(--text3)"><span class="num">${totalChecks-passCount}</span> ${isEntry?'미충족':'미해당'}</div>
                <div class="entry-cond-count" style="color:var(--cyan)"><span class="num">${totalChecks}</span> 전체</div>
            </div>`;
        const mColor = isEntry ? (score>=70?'#10b981':score>=40?'#f59e0b':'#ef4444') : (score>=70?'#ef4444':score>=40?'#f59e0b':'#10b981');
        const mEl = document.getElementById(elId + 'Meter');
        if (mEl) {
            mEl.innerHTML = `
                <div class="entry-meter-bar"><div class="entry-meter-fill" style="width:0%;background:linear-gradient(90deg,${mColor},${mColor}aa)"></div><div class="entry-meter-pointer" style="left:0%"></div></div>
                <div class="entry-meter-labels"><span>${isEntry?'매수 부적합':'보유 유지'}</span><span>조건부</span><span>${isEntry?'적극 매수':'즉시 매도'}</span></div>`;
            setTimeout(() => {
                const fill = mEl.querySelector('.entry-meter-fill');
                const pointer = mEl.querySelector('.entry-meter-pointer');
                if (fill) fill.style.width = score + '%';
                if (pointer) pointer.style.left = score + '%';
            }, 50);
        }
        const iconMap = { pass: '&#10003;', fail: '&#10007;', warn: '!' };
        const cEl = document.getElementById(elId + 'Checklist');
        if (cEl) cEl.innerHTML = checks.map(ck => `
            <div class="entry-check-item"><div class="entry-check-icon ${ck.status}">${iconMap[ck.status]}</div><div class="entry-check-text"><div class="entry-check-label">${ck.label}</div><div class="entry-check-desc">${ck.desc}</div></div></div>
        `).join('');
        const sEl = document.getElementById(elId + 'Strategy');
        if (sEl) sEl.innerHTML = strategyHtml;
    }

    // =====================
    // 단타 진입 시점 (과매도 기술적 반등)
    // =====================
    function renderDayEntry() {
        const d = getAnalysisData();
        const { closes, volumes, highs, lows, price, rsi, bb, stoch, histogram } = d;
        const isKR = currentMarket === 'KR';
        const fmtP = v => isKR ? Math.round(v).toLocaleString()+'원' : '$'+v.toFixed(2);
        const fmtPct = (v, base) => v && base
            ? ((v-base)/base*100 > 0 ? '+' : '') + ((v-base)/base*100).toFixed(1)+'%' : '';

        // ATR 계산 (분할 진입가 산출용)
        const _q = stockData.indicators.quote[0];
        const atrRaw = calcATR(_q.high, _q.low, _q.close);
        const atr = atrRaw.filter(v => v != null).pop() || 0;

        // 5단계 분할 진입가 (ATR 기반)
        const e1 = price;
        const e2 = price - atr * 0.3;
        const e3 = price - atr * 0.6;
        const e4 = price - atr * 1.0;
        const e5 = price - atr * 1.5;

        // 스칼라 추출 (모두 배열에서 마지막 유효값)
        const lastRSI  = rsi.filter(v=>v!=null).pop() || 50;
        const bbLower  = bb.lower.filter(v=>v!=null).pop();
        const bbMid    = bb.middle.filter(v=>v!=null).pop(); // TP1
        const lastK    = stoch.kLine.filter(v=>v!=null).pop() || 50;
        const prevK    = stoch.kLine.filter(v=>v!=null).slice(-2)[0] || 50;
        const histClean= histogram.filter(v=>v!=null);
        const histNow  = histClean[histClean.length-1] || 0;
        const histPrev = histClean[histClean.length-2] || 0;

        // OBV 패닉·다이버전스 계산
        const obvArr   = calcOBV(closes, volumes);
        const panicRes = _detectOBVPanic(obvArr, volumes, closes);
        const divRes   = detectBullishDivergence(closes, rsi, 40);

        // 목표가 계산
        const tp1 = bbMid; // BB 중심선 (MA20)
        const recentH = highs.slice(-20).filter(v=>v!=null);
        const recentL = lows.slice(-20).filter(v=>v!=null);
        const swingHigh = recentH.length ? Math.max(...recentH) : null;
        const swingLow  = recentL.length ? Math.min(...recentL) : null;
        const tp2 = (swingHigh && swingLow) ? swingLow + (swingHigh - swingLow) * 0.382 : null; // Fib 38.2%
        const sl  = lows.filter(v=>v!=null).slice(-1)[0] || null; // 진입봉 저점

        // 6개 체크
        const checks = []; let passCount = 0, totalChecks = 0;

        // A. BB 하단 이탈
        totalChecks++;
        if (bbLower && price < bbLower) {
            const pct = ((price-bbLower)/bbLower*100).toFixed(1);
            checks.push({ status:'pass', label:`BB 하단 이탈 (${pct}%)`, desc:'볼린저 밴드 하단 돌파. 극단적 낙폭으로 역추세 반등 구간 진입.' });
            passCount++;
        } else if (bbLower && price < bbLower * 1.02) {
            checks.push({ status:'warn', label:'BB 하단 근접', desc:'볼린저 하단 2% 이내. 이탈 여부 확인 필요.' });
        } else {
            checks.push({ status:'fail', label:'BB 하단 이탈 없음', desc:'아직 과매도 극단 영역 미진입.' });
        }

        // B. 극단적 RSI 과매도
        totalChecks++;
        if (lastRSI <= 20) {
            checks.push({ status:'pass', label:`RSI ${lastRSI.toFixed(1)} — 극단 과매도 (≤20)`, desc:'투매 극한. 역추세 반등 타이밍 최적 구간.' });
            passCount++;
        } else if (lastRSI <= 30) {
            checks.push({ status:'pass', label:`RSI ${lastRSI.toFixed(1)} — 과매도 (≤30)`, desc:'RSI 과매도 구간. 반등 신호 병행 확인 필요.' });
            passCount++;
        } else {
            checks.push({ status:'fail', label:`RSI ${lastRSI.toFixed(1)} — 과매도 미달`, desc:'RSI 30 초과. 역추세 단타 조건 미충족.' });
        }

        // C. 패닉 투매 OBV
        totalChecks++;
        if (panicRes.panicSell) {
            checks.push({ status:'pass', label:'패닉 투매 확인 (OBV)', desc:'OBV 하락 + 비정상 거래량 스파이크 동시 감지. 세력 바닥 매집 가능성.' });
            passCount++;
        } else {
            const parts = [];
            if (!panicRes.obvDeclining) parts.push('OBV 하락 미확인');
            if (!panicRes.volSpike) parts.push('거래량 스파이크 없음');
            checks.push({ status:'warn', label:'패닉 투매 미확인', desc: parts.join(' · ') || '투매 조건 불완전' });
        }

        // D. 상승 다이버전스 (★ 가장 강한 신호)
        totalChecks++;
        if (divRes.detected) {
            checks.push({ status:'pass', label:`★ RSI 상승 다이버전스 (+${divRes.rsiDiff.toFixed(1)}pt)`, desc:'가격 Lower Low + RSI Higher Low 패턴 감지. 역추세 단타 최고 승률 신호.' });
            passCount++;
        } else {
            checks.push({ status:'warn', label:'다이버전스 미감지', desc:'최근 40봉 내 상승 다이버전스 없음. 반등 신뢰도 낮음.' });
        }

        // E. Stochastic 과매도 반등
        totalChecks++;
        if (lastK <= 25 && lastK > prevK) {
            checks.push({ status:'pass', label:`Stochastic K ${lastK.toFixed(0)} 반등 전환`, desc:'극단 과매도에서 K 상승 전환. 단기 반등 타이밍.' });
            passCount++;
        } else if (lastK <= 25) {
            checks.push({ status:'warn', label:`Stochastic K ${lastK.toFixed(0)} — 방향 미전환`, desc:'과매도 구간이나 K 반등 미확인. 다음 캔들 확인 후 진입.' });
        } else {
            checks.push({ status:'fail', label:`Stochastic K ${lastK.toFixed(0)} — 과매도 아님`, desc:'과매도 영역(K≤25) 미진입.' });
        }

        // F. MACD 히스토그램 반전
        totalChecks++;
        if (histNow < 0 && histNow > histPrev) {
            checks.push({ status:'pass', label:'MACD 히스토그램 반전', desc:`음수 구간에서 상승 반전 (${histPrev.toFixed(3)}→${histNow.toFixed(3)}). 매도 압력 약화.` });
            passCount++;
        } else if (histNow < 0) {
            checks.push({ status:'warn', label:'MACD 음수 (반전 대기)', desc:`히스토그램 음수 지속(${histNow.toFixed(3)}). 방향 전환 미확인.` });
        } else {
            checks.push({ status:'fail', label:'MACD 양수 — 역추세 구간 아님', desc:'과매도 환경이 아닌 상태.' });
        }

        // 다이버전스 배지 + 전략 HTML
        const divBadge = divRes.detected
            ? `<div class="rr-knife-warning" style="border-color:var(--green);background:rgba(34,197,94,.08);margin-bottom:8px;">
                   <span style="font-size:18px;line-height:1">📈</span>
                   <div>
                     <div class="rr-knife-title" style="color:var(--green)">RSI 상승 다이버전스 감지 — 강한 매수 신호</div>
                     <div class="rr-knife-desc">가격 Lower Low + RSI Higher Low 패턴. 역추세 단타 최고 승률 패턴.</div>
                   </div>
               </div>`
            : '';

        const stratHtml = `
            ${divBadge}
            <div class="entry-strategy-title" style="color:var(--cyan)">과매도 반등 전략 (역추세 단타)</div>
            <div class="entry-strategy-row">
                <span class="entry-strategy-label">손절가 (진입봉 저점)</span>
                <span class="entry-strategy-value" style="color:var(--red)">${sl ? fmtP(sl) : 'N/A'} <small style="color:var(--text2)">${fmtPct(sl,price)}</small></span>
            </div>
            <div class="entry-strategy-row">
                <span class="entry-strategy-label">1차 목표 (BB 중심선)</span>
                <span class="entry-strategy-value" style="color:var(--green)">${tp1 ? fmtP(tp1) : 'N/A'} <small style="color:var(--text2)">${fmtPct(tp1,price)}</small></span>
            </div>
            <div class="entry-strategy-row">
                <span class="entry-strategy-label">2차 목표 (Fib 38.2%)</span>
                <span class="entry-strategy-value" style="color:var(--green)">${tp2 ? fmtP(tp2) : 'N/A'} <small style="color:var(--text2)">${fmtPct(tp2,price)}</small></span>
            </div>
            <div class="entry-strategy-row">
                <span class="entry-strategy-label">보유 기간</span>
                <span class="entry-strategy-value">당일~1일 (빠른 익절)</span>
            </div>`;

        // 분할 매수 계산기에 데이터 전달
        window._sc = { prices: [e1, e2, e3, e4, e5], tp1, tp2, sl, isKR };
        renderTimingCard('day', 'entry', checks, passCount, totalChecks, stratHtml);
        renderSplitCalc();
    }

    // =====================
    // 분할 매수 계산기
    // =====================
    function renderSplitCalc() {
        const wrap = document.getElementById('splitCalcWrap');
        if (!wrap) return;
        const sc = window._sc;
        if (!sc) { wrap.innerHTML = ''; return; }
        const isKR = sc.isKR;
        const unit = isKR ? '원' : 'USD';
        const ph   = isKR ? '예: 1000000' : 'e.g. 10000';
        wrap.innerHTML = `
        <div class="card">
            <div class="card-title">
                <span class="dot" style="background:var(--yellow)"></span>분할 매수 계산기
                <span style="font-size:11px;color:var(--text3);margin-left:auto;font-weight:500;">ATR 기반 5단계 자동 계산</span>
            </div>
            <div class="sc-input-grid">
                <div class="sc-input-group">
                    <label>총 투자 예산 (${unit})</label>
                    <input type="number" id="calcBudget" placeholder="${ph}" oninput="_calcSplit()" min="0">
                </div>
                <div class="sc-input-group">
                    <label>1차 투자금액 (${unit})</label>
                    <input type="number" id="calcFirst" placeholder="${ph}" oninput="_calcSplit()" min="0">
                </div>
            </div>
            <div class="sc-input-group" style="margin-bottom:14px;">
                <label>비중 방식</label>
                <select id="calcMode" onchange="_calcSplit()">
                    <option value="equal">균등 배분 (20% × 5)</option>
                    <option value="pyramid">역피라미드 — 하락할수록 더 많이 (10·15·20·25·30%)</option>
                    <option value="front">전방 집중 — 지금 더 많이 (30·25·20·15·10%)</option>
                </select>
            </div>
            <div style="overflow-x:auto;">
                <table class="sc-tbl">
                    <thead>
                        <tr>
                            <th>차수</th>
                            <th>진입가</th>
                            <th>투자금액</th>
                            <th>수량</th>
                            <th>누적투자</th>
                            <th>평균매수가</th>
                        </tr>
                    </thead>
                    <tbody id="calcTableBody">
                        <tr><td colspan="6" style="text-align:center;color:var(--text3);padding:20px;font-size:13px;">💡 총 예산을 입력하면 자동 계산됩니다</td></tr>
                    </tbody>
                </table>
            </div>
            <div id="calcSummary"></div>
        </div>`;
    }

    function _calcSplit() {
        const sc = window._sc;
        if (!sc) return;
        const budget   = parseFloat(document.getElementById('calcBudget').value) || 0;
        const firstAmt = parseFloat(document.getElementById('calcFirst').value)  || 0;
        const mode     = document.getElementById('calcMode').value;

        if (!budget) {
            document.getElementById('calcTableBody').innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--text3);padding:20px;font-size:13px;">💡 총 예산을 입력하면 자동 계산됩니다</td></tr>';
            document.getElementById('calcSummary').innerHTML = '';
            return;
        }

        const isKR  = sc.isKR;
        const fmtP  = v => isKR ? Math.round(v).toLocaleString()+'원' : '$'+v.toFixed(2);
        const fmtA  = v => isKR ? Math.round(v).toLocaleString()+'원' : '$'+(v<1000 ? v.toFixed(2) : Math.round(v).toLocaleString());
        const fmtSh = v => isKR ? Math.round(v).toLocaleString()+'주' : (v>=1 ? v.toFixed(2) : v.toFixed(4))+'주';

        // Allocation weights
        const allW = { equal:[20,20,20,20,20], pyramid:[10,15,20,25,30], front:[30,25,20,15,10] };
        const remW = { equal:[25,25,25,25],     pyramid:[15,20,30,35],   front:[35,30,20,15]   };

        let amounts;
        if (firstAmt > 0) {
            const rem  = Math.max(0, budget - firstAmt);
            const rw   = remW[mode];
            const rwS  = rw.reduce((a,b)=>a+b,0);
            amounts    = [firstAmt, ...rw.map(w => rem * w / rwS)];
        } else {
            amounts = allW[mode].map(w => budget * w / 100);
        }

        let cumShares = 0, cumInvested = 0;
        const rows = sc.prices.map((price, i) => {
            const amt    = amounts[i];
            const shares = price > 0 ? amt / price : 0;
            cumShares   += shares;
            cumInvested += amt;
            return { price, amt, shares, cumInvested, avgP: cumShares > 0 ? cumInvested / cumShares : 0 };
        });

        const badges = [
            'background:rgba(34,197,94,.22);color:var(--green)',
            'background:rgba(34,197,94,.14);color:var(--green)',
            'background:rgba(234,179,8,.18);color:var(--yellow)',
            'background:rgba(234,179,8,.12);color:var(--yellow)',
            'background:rgba(239,68,68,.18);color:var(--red)'
        ];

        document.getElementById('calcTableBody').innerHTML = rows.map((r, i) =>
            `<tr>
                <td><span style="display:inline-block;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;${badges[i]}">${i+1}차</span></td>
                <td>${fmtP(r.price)}</td>
                <td style="font-weight:600">${fmtA(r.amt)}</td>
                <td style="color:var(--text2)">${fmtSh(r.shares)}</td>
                <td style="color:var(--text3);font-size:12px">${fmtA(r.cumInvested)}</td>
                <td style="font-weight:800;color:var(--cyan)">${fmtP(r.avgP)}</td>
            </tr>`
        ).join('');

        // Summary
        const finalAvg = rows[rows.length-1].avgP;
        const totalSh  = cumShares;
        const tp1      = sc.tp1;
        const slPrice  = sc.sl;

        let html = `<div class="sc-summary">
            <div class="sc-sum-item">
                <div class="sc-sum-label">총 투자금액</div>
                <div class="sc-sum-val">${fmtA(budget)}</div>
            </div>
            <div class="sc-sum-item">
                <div class="sc-sum-label">전량 매수시 평균가</div>
                <div class="sc-sum-val" style="color:var(--cyan)">${fmtP(finalAvg)}</div>
            </div>`;

        if (tp1 && tp1 > finalAvg) {
            const profit = (tp1 - finalAvg) * totalSh;
            const pct    = (tp1 - finalAvg) / finalAvg * 100;
            html += `<div class="sc-sum-item" style="border:1px solid rgba(34,197,94,.25);background:rgba(34,197,94,.05);">
                <div class="sc-sum-label">TP1 (${fmtP(tp1)}) 도달시 수익</div>
                <div class="sc-sum-val" style="color:var(--green)">+${fmtA(profit)} <small style="font-size:11px">(+${pct.toFixed(1)}%)</small></div>
            </div>`;
        }
        if (slPrice && slPrice < finalAvg) {
            const loss = (slPrice - finalAvg) * totalSh;
            const pct  = (slPrice - finalAvg) / finalAvg * 100;
            html += `<div class="sc-sum-item" style="border:1px solid rgba(239,68,68,.25);background:rgba(239,68,68,.05);">
                <div class="sc-sum-label">손절 (${fmtP(slPrice)}) 도달시 손실</div>
                <div class="sc-sum-val" style="color:var(--red)">${fmtA(loss)} <small style="font-size:11px">(${pct.toFixed(1)}%)</small></div>
            </div>`;
        }
        html += `</div>`;

        if (tp1 && slPrice && tp1 > finalAvg && slPrice < finalAvg) {
            const rr  = (tp1 - finalAvg) / (finalAvg - slPrice);
            const col = rr >= 2 ? 'var(--green)' : rr >= 1.5 ? 'var(--yellow)' : 'var(--red)';
            html += `<div style="text-align:center;margin-top:10px;padding:9px;background:var(--bg3);border-radius:var(--r2);font-size:13px;color:var(--text2);">
                평균매수가 기준 손익비 <span style="font-weight:800;font-size:16px;color:${col};margin-left:4px;">1 : ${rr.toFixed(2)}</span>
            </div>`;
        }
        document.getElementById('calcSummary').innerHTML = html;
    }

    // =====================
    // 스윙 진입 시점
    // =====================
    function renderSwingEntry() {
        const d = getAnalysisData();
        const { closes, volumes, highs, lows, price, ma5, ma20, ma60, ma120, rsi, macdLine, signalLine, histogram, bb } = d;
        const isKR = currentMarket === 'KR';
        const fmtP = v => isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2);
        const checks = []; let passCount = 0; let totalChecks = 0;

        // 1. MA 정배열 (중기)
        totalChecks++;
        const lma20 = ma20.filter(v=>v!=null).pop(); const lma60 = ma60.filter(v=>v!=null).pop();
        const lma120 = ma120.filter(v=>v!=null).pop();
        const pma20 = ma20.filter(v=>v!=null).slice(-2)[0]; const pma60 = ma60.filter(v=>v!=null).slice(-2)[0];
        const golden20_60 = pma20 && pma60 && pma20 <= pma60 && lma20 > lma60;
        if (lma20 > lma60 && lma60 > lma120) { checks.push({ status:'pass', label:'MA20>60>120 정배열', desc:'중기 이평선 완벽 정배열. 스윙 매수 적합.' }); passCount++; }
        else if (golden20_60) { checks.push({ status:'pass', label:'MA20/60 골든크로스', desc:'MA20이 MA60 상향 돌파. 추세 전환 신호.' }); passCount++; }
        else if (lma20 > lma60) { checks.push({ status:'warn', label:'부분 정배열', desc:'MA20>MA60이나 MA120 아래. 추세 확인 필요.' }); }
        else { checks.push({ status:'fail', label:'이평선 역배열', desc:'하락 추세. 스윙 매수 부적합.' }); }

        // 2. MACD 골든크로스/매수세
        totalChecks++;
        const lastMACD = macdLine.filter(v=>v!=null).pop()||0; const lastSig = signalLine.filter(v=>v!=null).pop()||0;
        const hists = histogram.filter(v=>v!=null); const lastHist = hists.pop()||0;
        const histUp = hists.length >= 3 && hists[hists.length-1] > hists[hists.length-3];
        const ml = macdLine.filter(v=>v!=null); const slArr = signalLine.filter(v=>v!=null);
        const macdGolden = ml.length>=2&&slArr.length>=2&&(ml[ml.length-2]-slArr[slArr.length-2])<0&&(lastMACD-lastSig)>=0;
        if (macdGolden) { checks.push({ status:'pass', label:'MACD 골든크로스!', desc:'강력한 스윙 매수 신호.' }); passCount++; }
        else if (lastMACD > lastSig && histUp) { checks.push({ status:'pass', label:'MACD 매수세 확대', desc:'히스토그램 확대. 상승 모멘텀 강화.' }); passCount++; }
        else if (lastMACD > lastSig) { checks.push({ status:'warn', label:'MACD 매수 구간', desc:'매수 신호이나 모멘텀 약화 주의.' }); }
        else { checks.push({ status:'fail', label:'MACD 매도 구간', desc:'매도세 우위. 진입 자제.' }); }

        // 3. RSI 적합 구간
        totalChecks++;
        const lastRSI = rsi.filter(v=>v!=null).pop()||50;
        if (lastRSI >= 40 && lastRSI <= 60) { checks.push({ status:'pass', label:`RSI ${lastRSI.toFixed(1)} 적정`, desc:'과매수/과매도 아닌 건강한 구간. 스윙 진입 적합.' }); passCount++; }
        else if (lastRSI < 35) { checks.push({ status:'pass', label:`RSI ${lastRSI.toFixed(1)} 과매도 반등`, desc:'과매도 구간. 지지 확인 후 스윙 매수.' }); passCount++; }
        else if (lastRSI >= 70) { checks.push({ status:'fail', label:`RSI ${lastRSI.toFixed(1)} 과매수`, desc:'과매수. 차익 실현 구간.' }); }
        else { checks.push({ status:'warn', label:`RSI ${lastRSI.toFixed(1)}`, desc:'중립 구간.' }); }

        // 4. 거래량 추세
        totalChecks++;
        if (volumes.length >= 20) {
            const avg5 = volumes.slice(-5).reduce((a,b)=>a+b,0)/5;
            const avg20 = volumes.slice(-20).reduce((a,b)=>a+b,0)/20;
            const vt = avg5/avg20; const isUp = closes[closes.length-1] >= (closes[closes.length-6]||closes[closes.length-1]);
            if (vt >= 1.3 && isUp) { checks.push({ status:'pass', label:'거래량 증가+상승', desc:'매집 가능성. 스윙 매수 유리.' }); passCount++; }
            else if (vt >= 1.3 && !isUp) { checks.push({ status:'fail', label:'거래량 증가+하락', desc:'매도세 유입. 진입 위험.' }); }
            else { checks.push({ status:'warn', label:'거래량 보통', desc:'특별한 신호 없음.' }); }
        }

        // 5. 지지선 근접
        totalChecks++;
        const support = Math.min(...lows.slice(-20)); const resistance = Math.max(...highs.slice(-20));
        const distSupport = (price-support)/support*100;
        if (distSupport <= 5) { checks.push({ status:'pass', label:`지지선 근처 ${fmtP(support)}`, desc:`저점 대비 ${distSupport.toFixed(1)}% 위. 지지 매수 구간.` }); passCount++; }
        else if ((resistance-price)/price*100 <= 2) { checks.push({ status:'fail', label:'저항선 근처', desc:'돌파 확인 전 진입 위험.' }); }
        else { checks.push({ status:'warn', label:'지지/저항 중간', desc:`${fmtP(support)} ~ ${fmtP(resistance)} 사이.` }); }

        // 6. 저점 상승 패턴
        totalChecks++;
        const r5low = lows.slice(-5).length ? Math.min(...lows.slice(-5)) : price;
        const p5low = lows.slice(-10,-5).length ? Math.min(...lows.slice(-10,-5)) : price;
        if (r5low > p5low && price > lma20) { checks.push({ status:'pass', label:'저점 상승+MA20 위', desc:'상승 추세 전환 확인.' }); passCount++; }
        else if (r5low > p5low) { checks.push({ status:'warn', label:'저점 상승 중', desc:'저점 높아지나 이평선 아래.' }); }
        else { checks.push({ status:'fail', label:'저점 하락', desc:'하락 추세 지속.' }); }

        const sl = price * 0.93; const t1 = price * 1.05; const t2 = price * 1.10;
        const rr = ((t2-price)/(price-sl)).toFixed(1);
        const stratHtml = `
            <div class="entry-strategy-title" style="color:#8b5cf6">스윙 진입 전략</div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">진입가</span><span class="entry-strategy-value">${fmtP(price)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">손절 (-7%)</span><span class="entry-strategy-value" style="color:var(--red)">${fmtP(sl)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">1차 익절 (+5%)</span><span class="entry-strategy-value" style="color:var(--green)">${fmtP(t1)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">2차 익절 (+10%)</span><span class="entry-strategy-value" style="color:var(--green)">${fmtP(t2)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">손익비</span><span class="entry-strategy-value" style="color:var(--cyan)">1 : ${rr}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">보유 기간</span><span class="entry-strategy-value">2~10일</span></div>`;
        renderTimingCard('swing', 'entry', checks, passCount, totalChecks, stratHtml);
    }

    // =====================
    // 단타 매도 시점
    // =====================
    function renderDayExit() {
        const d = getAnalysisData();
        const { closes, volumes, highs, lows, price, ma5, ma10, rsi, stoch, bb } = d;
        const isKR = currentMarket === 'KR';
        const fmtP = v => isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2);
        const checks = []; let sellCount = 0; let totalChecks = 0;

        // 1. Stochastic 과매수 하락
        totalChecks++;
        const lastK = stoch.kLine.filter(v=>v!=null).pop()||50;
        const prevK = stoch.kLine.filter(v=>v!=null).slice(-2)[0]||50;
        const lastD = stoch.dLine.filter(v=>v!=null).pop()||50;
        if (lastK >= 80 && lastK < prevK) { checks.push({ status:'fail', label:'Stochastic 과매수 하락', desc:`K ${lastK.toFixed(0)} 과매수에서 하락 전환! 단타 매도.` }); sellCount++; }
        else if (lastK >= 80 && lastK < lastD) { checks.push({ status:'fail', label:'Stochastic K<D 교차', desc:'과매수 영역에서 데드크로스.' }); sellCount++; }
        else if (lastK >= 75) { checks.push({ status:'warn', label:'Stochastic 과매수 주의', desc:`K ${lastK.toFixed(0)} 과매수 근접.` }); }
        else { checks.push({ status:'pass', label:'Stochastic 정상', desc:`K ${lastK.toFixed(0)} 과매수 아님.` }); }

        // 2. RSI 과매수
        totalChecks++;
        const lastRSI = rsi.filter(v=>v!=null).pop()||50;
        const prevRSIs = rsi.filter(v=>v!=null).slice(-5);
        const rsiFall = prevRSIs.length>=3 && prevRSIs[prevRSIs.length-1] < prevRSIs[prevRSIs.length-3];
        if (lastRSI >= 75) { checks.push({ status:'fail', label:`RSI ${lastRSI.toFixed(1)} 극과매수`, desc:'즉시 청산 권장.' }); sellCount++; }
        else if (lastRSI >= 65 && rsiFall) { checks.push({ status:'fail', label:'RSI 과매수 꺾임', desc:'과매수에서 하락 시작. 청산 시점.' }); sellCount++; }
        else if (lastRSI >= 65) { checks.push({ status:'warn', label:'RSI 과매수 주의', desc:`${lastRSI.toFixed(1)}. 추가 상승 제한적.` }); }
        else { checks.push({ status:'pass', label:'RSI 정상', desc:`${lastRSI.toFixed(1)} 과매수 아님.` }); }

        // 3. MA5 < MA10 전환
        totalChecks++;
        const lma5 = ma5.filter(v=>v!=null).pop(); const lma10 = ma10.filter(v=>v!=null).pop();
        const pma5 = ma5.filter(v=>v!=null).slice(-2)[0]; const pma10 = ma10.filter(v=>v!=null).slice(-2)[0];
        const deadCross = pma5 && pma10 && pma5 >= pma10 && lma5 < lma10;
        if (deadCross) { checks.push({ status:'fail', label:'MA5/10 데드크로스', desc:'단기 이평선 하향 돌파. 즉시 청산.' }); sellCount++; }
        else if (lma5 < lma10) { checks.push({ status:'fail', label:'단기 이평선 역배열', desc:'MA5 < MA10. 하락 추세.' }); sellCount++; }
        else { checks.push({ status:'pass', label:'단기 이평선 정배열', desc:'상승 추세 유지 중.' }); }

        // 4. 거래량 급증 + 하락
        totalChecks++;
        if (volumes.length >= 20) {
            const curVol = volumes[volumes.length-1]||0;
            const avg20 = volumes.slice(-20).reduce((a,b)=>a+b,0)/20;
            const vr = curVol/avg20; const isDown = closes[closes.length-1] < (closes[closes.length-2]||closes[closes.length-1]);
            if (vr >= 2.0 && isDown) { checks.push({ status:'fail', label:'거래량 폭증+하락', desc:`${Math.round(vr*100)}% 거래량 급증 + 하락. 투매. 즉시 청산.` }); sellCount++; }
            else if (vr >= 1.5 && isDown) { checks.push({ status:'fail', label:'거래량 증가+하락', desc:'매도세 유입. 청산 고려.' }); sellCount++; }
            else { checks.push({ status:'pass', label:'거래량 정상', desc:'특별한 매도 신호 없음.' }); }
        }

        // 5. BB 상단 이탈
        totalChecks++;
        const lbbu = bb.upper.filter(v=>v!=null).pop(); const lbbl = bb.lower.filter(v=>v!=null).pop();
        if (lbbu && lbbl) {
            const bbPos = (price-lbbl)/(lbbu-lbbl);
            if (price > lbbu) { checks.push({ status:'fail', label:'BB 상단 이탈', desc:'과매수 극단. 되돌림 매도.' }); sellCount++; }
            else if (bbPos > 0.9) { checks.push({ status:'warn', label:'BB 상단 근접', desc:'차익 실현 고려.' }); }
            else { checks.push({ status:'pass', label:'BB 정상 범위', desc:'밴드 내 위치.' }); }
        }

        // 6. 목표 수익률 도달
        totalChecks++;
        const prevClose = closes[closes.length-2]||price;
        const dayReturn = (price-prevClose)/prevClose*100;
        if (dayReturn >= 5) { checks.push({ status:'fail', label:`+${dayReturn.toFixed(1)}% 급등`, desc:'단타 목표 수익 초과. 익절 시점.' }); sellCount++; }
        else if (dayReturn >= 3) { checks.push({ status:'warn', label:`+${dayReturn.toFixed(1)}% 상승`, desc:'목표 수익 근접. 부분 익절 고려.' }); }
        else if (dayReturn <= -3) { checks.push({ status:'fail', label:`${dayReturn.toFixed(1)}% 급락`, desc:'손절 라인 도달. 즉시 청산.' }); sellCount++; }
        else { checks.push({ status:'pass', label:`${dayReturn>=0?'+':''}${dayReturn.toFixed(1)}%`, desc:'정상 범위.' }); }

        const trailStop = price * 0.98; const prof1 = price * 1.02;
        const stratHtml = `
            <div class="entry-strategy-title" style="color:var(--red)">단타 매도 전략</div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">트레일링 스탑 (-2%)</span><span class="entry-strategy-value" style="color:var(--red)">${fmtP(trailStop)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">익절가 (+2%)</span><span class="entry-strategy-value" style="color:var(--green)">${fmtP(prof1)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">당일 수익률</span><span class="entry-strategy-value" style="color:${dayReturn>=0?'var(--green)':'var(--red)'}">${dayReturn>=0?'+':''}${dayReturn.toFixed(2)}%</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">청산 원칙</span><span class="entry-strategy-value" style="font-size:12px">당일 청산 원칙. 오버나잇 금지.</span></div>`;
        renderTimingCard('day', 'exit', checks, sellCount, totalChecks, stratHtml);
    }

    // =====================
    // 스윙 매도 시점
    // =====================
    function renderSwingExit() {
        const d = getAnalysisData();
        const { closes, volumes, highs, lows, price, ma5, ma20, ma60, ma120, rsi, macdLine, signalLine, histogram, bb, stoch } = d;
        const isKR = currentMarket === 'KR';
        const fmtP = v => isKR ? Math.round(v).toLocaleString() + '원' : '$' + v.toFixed(2);

        const checks = [];
        let sellCount = 0;
        let totalChecks = 0;
        const lastRSI = rsi.filter(v=>v!=null).pop()||50;
        const lastMACD = macdLine.filter(v=>v!=null).pop()||0; const lastSig = signalLine.filter(v=>v!=null).pop()||0;
        const hists = histogram.filter(v=>v!=null); const histDir = hists.length>=3 ? hists[hists.length-1]-hists[hists.length-3] : 0;

        // 1. MACD 데드크로스/매도세
        totalChecks++;
        const ml = macdLine.filter(v=>v!=null); const sll = signalLine.filter(v=>v!=null);
        const macdDead = ml.length>=2&&sll.length>=2&&(ml[ml.length-2]-sll[sll.length-2])>0&&(lastMACD-lastSig)<=0;
        if (macdDead) { checks.push({ status:'fail', label:'MACD 데드크로스!', desc:'스윙 매도 강력 신호.' }); sellCount++; }
        else if (lastMACD < lastSig && histDir < 0) { checks.push({ status:'fail', label:'MACD 매도세 강화', desc:'히스토그램 확대 하락. 매도 모멘텀 강화.' }); sellCount++; }
        else if (lastMACD > lastSig && histDir < 0) { checks.push({ status:'warn', label:'MACD 모멘텀 약화', desc:'매수세 약화 중. 매도 대비.' }); }
        else { checks.push({ status:'pass', label:'MACD 매수세 유지', desc:'상승 추세 유지.' }); }

        // 2. 이평선 역배열 전환
        totalChecks++;
        const lma20 = ma20.filter(v=>v!=null).pop(); const lma60 = ma60.filter(v=>v!=null).pop();
        const pma20 = ma20.filter(v=>v!=null).slice(-2)[0]; const pma60 = ma60.filter(v=>v!=null).slice(-2)[0];
        const deathCross20_60 = pma20 && pma60 && pma20 >= pma60 && lma20 < lma60;
        if (lma20 < lma60 && lma60 < (ma120.filter(v=>v!=null).pop()||Infinity)) { checks.push({ status:'fail', label:'중기 이평선 역배열', desc:'MA20<MA60<MA120. 하락 추세 확정. 매도 권장.' }); sellCount++; }
        else if (deathCross20_60) { checks.push({ status:'fail', label:'MA20/60 데드크로스', desc:'중기 하락 전환 신호.' }); sellCount++; }
        else if (lma20 < lma60) { checks.push({ status:'warn', label:'MA20 < MA60', desc:'중기 추세 약화.' }); }
        else { checks.push({ status:'pass', label:'이평선 정배열', desc:'상승 추세 유지.' }); }

        // 3. RSI 과매수
        totalChecks++;
        const prevRSIs = rsi.filter(v=>v!=null).slice(-5);
        const rsiDown = prevRSIs.length>=3 && prevRSIs[prevRSIs.length-1] < prevRSIs[prevRSIs.length-3];
        if (lastRSI >= 75) { checks.push({ status:'fail', label:`RSI ${lastRSI.toFixed(1)} 극과매수`, desc:'즉시 일부 매도 권장.' }); sellCount++; }
        else if (lastRSI >= 65 && rsiDown) { checks.push({ status:'fail', label:'RSI 과매수 꺾임', desc:'과매수에서 하락 시작. 차익 실현.' }); sellCount++; }
        else if (lastRSI >= 65) { checks.push({ status:'warn', label:'RSI 과매수 주의', desc:'추가 상승 제한적.' }); }
        else { checks.push({ status:'pass', label:'RSI 정상', desc:'과매수 아님. 보유 유지.' }); }

        // 4. 볼린저밴드 상단
        totalChecks++;
        const lbbu = bb.upper.filter(v=>v!=null).pop(); const lbbl = bb.lower.filter(v=>v!=null).pop();
        if (lbbu && lbbl) {
            const bbPos = (price-lbbl)/(lbbu-lbbl);
            if (price > lbbu) { checks.push({ status:'fail', label:'BB 상단 이탈', desc:'과매수 극단. 되돌림 매도.' }); sellCount++; }
            else if (bbPos > 0.85) { checks.push({ status:'warn', label:'BB 상단 근접', desc:'차익 실현 고려.' }); }
            else { checks.push({ status:'pass', label:'BB 정상 범위', desc:'밴드 내 위치.' }); }
        }

        // 5. 거래량 급증+하락
        totalChecks++;
        if (volumes.length >= 20) {
            const avg3 = volumes.slice(-3).reduce((a,b)=>a+b,0)/3;
            const avg20 = volumes.slice(-20).reduce((a,b)=>a+b,0)/20;
            const vr = avg3/avg20; const isDown = closes[closes.length-1] < (closes[closes.length-4]||closes[closes.length-1]);
            if (vr >= 2.0 && isDown) { checks.push({ status:'fail', label:'폭발적 거래량+급락', desc:`${Math.round(vr*100)}% 급증. 매도 물량 폭주.` }); sellCount++; }
            else if (vr >= 1.5 && isDown) { checks.push({ status:'fail', label:'거래량 증가+하락', desc:'매도세 유입.' }); sellCount++; }
            else { checks.push({ status:'pass', label:'거래량 정상', desc:'특별한 매도 신호 없음.' }); }
        }

        // 6. 고점 대비 하락률
        totalChecks++;
        const peakPrice = Math.max(...highs.slice(-20));
        const drawdown = (peakPrice-price)/peakPrice*100;
        if (drawdown >= 10) { checks.push({ status:'fail', label:`고점 대비 -${drawdown.toFixed(1)}%`, desc:`${fmtP(peakPrice)}에서 ${drawdown.toFixed(1)}% 하락. 손절 고려.` }); sellCount++; }
        else if (drawdown >= 5) { checks.push({ status:'warn', label:`-${drawdown.toFixed(1)}% 조정`, desc:'반등 실패 시 매도.' }); }
        else { checks.push({ status:'pass', label:'고점 부근', desc:'상승 추세 유지.' }); }

        // 7. Stochastic 과매수
        totalChecks++;
        const lastK = stoch.kLine.filter(v=>v!=null).pop()||50; const lastD = stoch.dLine.filter(v=>v!=null).pop()||50;
        const prevKs = stoch.kLine.filter(v=>v!=null).slice(-3);
        const stochFall = prevKs.length>=2 && prevKs[prevKs.length-1] < prevKs[prevKs.length-2];
        if (lastK >= 80 && lastK < lastD) { checks.push({ status:'fail', label:'Stochastic 데드크로스', desc:`K(${lastK.toFixed(0)})<D(${lastD.toFixed(0)}) 과매수 하락.` }); sellCount++; }
        else if (lastK >= 80 && stochFall) { checks.push({ status:'fail', label:'Stochastic 과매수 꺾임', desc:`${lastK.toFixed(0)}에서 하락 시작.` }); sellCount++; }
        else if (lastK >= 75) { checks.push({ status:'warn', label:'Stochastic 과매수 주의', desc:`K ${lastK.toFixed(0)} 과매수.` }); }
        else { checks.push({ status:'pass', label:'Stochastic 정상', desc:`K ${lastK.toFixed(0)}.` }); }

        const trailStop = price * 0.93; const prof1 = price * 1.05; const prof2 = price * 1.10;
        const stratHtml = `
            <div class="entry-strategy-title" style="color:var(--red)">스윙 매도 전략</div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">트레일링 스탑 (-7%)</span><span class="entry-strategy-value" style="color:var(--red)">${fmtP(trailStop)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">1차 익절 (+5%)</span><span class="entry-strategy-value" style="color:var(--green)">${fmtP(prof1)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">2차 익절 (+10%)</span><span class="entry-strategy-value" style="color:var(--green)">${fmtP(prof2)}</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">고점 대비</span><span class="entry-strategy-value" style="color:${drawdown>=5?'var(--red)':'var(--text)'}">${drawdown>0?'-':''}${drawdown.toFixed(1)}%</span></div>
            <div class="entry-strategy-row"><span class="entry-strategy-label">매도 원칙</span><span class="entry-strategy-value" style="font-size:12px">50% 익절 후 나머지 트레일링 스탑.</span></div>`;
        renderTimingCard('swing', 'exit', checks, sellCount, totalChecks, stratHtml);
    }

    // ========================================
    // Utility Functions
    // ========================================
    function showLoading(text) {
        document.getElementById('loadingText').textContent = text || '데이터를 불러오는 중...';
        document.getElementById('loadingOverlay').classList.add('active');
    }

    function hideLoading() {
        document.getElementById('loadingOverlay').classList.remove('active');
    }

    function showToast(msg) {
        const toast = document.getElementById('toast');
        toast.textContent = msg;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3500);
    }

    // Keyboard shortcut
    document.addEventListener('keydown', (e) => {
        if (e.key === '/' && document.activeElement.tagName !== 'INPUT') {
            e.preventDefault();
            document.getElementById('searchInput').focus();
        }
    });

    // 페이지 로드 시 기본 봉 타입(일봉)에 맞게 기간 버튼 초기화
    (function initRangeButtons() {
        const config = INTERVAL_RANGES[currentInterval];
        document.querySelectorAll('.range-btn').forEach(b => {
            const r = b.dataset.range;
            b.style.display = config.allowed.includes(r) ? '' : 'none';
        });
    })();

    // ========================================
    // Theme Toggle (다크/라이트 모드)
    // ========================================
    const THEME_LS = 'stockai_theme';

    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        const icon = document.getElementById('themeIcon');
        const label = document.getElementById('themeLabel');
        const sw = document.getElementById('themeSwitch');
        const headerBtn = document.getElementById('themeHeaderBtn');
        if (theme === 'light') {
            icon.innerHTML = '&#9728;';
            label.textContent = '라이트 모드';
            sw.className = 'theme-switch light';
            if (headerBtn) headerBtn.innerHTML = '&#9728;';
        } else {
            icon.innerHTML = '&#9790;';
            label.textContent = '다크 모드';
            sw.className = 'theme-switch dark';
            if (headerBtn) headerBtn.innerHTML = '&#9790;';
        }
        // Lightweight Charts 배경 업데이트
        if (lwChart) {
            const bgColor = theme === 'light' ? '#ffffff' : '#111620';
            const textColor = theme === 'light' ? '#4a5568' : '#94a3b8';
            const gridColor = theme === 'light' ? 'rgba(0,0,0,0.06)' : 'rgba(45,58,77,0.2)';
            lwChart.applyOptions({
                layout: { background: { type: 'solid', color: bgColor }, textColor },
                grid: { vertLines: { color: gridColor }, horzLines: { color: gridColor } },
            });
        }
    }

    function toggleTheme() {
        const current = document.documentElement.getAttribute('data-theme') || 'dark';
        const next = current === 'dark' ? 'light' : 'dark';
        localStorage.setItem(THEME_LS, next);
        applyTheme(next);
    }

    // 페이지 로드 시 저장된 테마 적용
    (function initTheme() {
        const saved = localStorage.getItem(THEME_LS) || 'dark';
        applyTheme(saved);
    })();

    // ========================================
    // 옵션현황 (Options Chain)
    // ========================================
    let _optionsSymbol = '';
    let _optionsAllCalls = [];
    let _optionsAllPuts = [];
    let _optionsCurrentPrice = 0;
    let _optionsFilter = 'all';
    let _optionsStrikeRange = 'all'; // 'all' | '5' | '10' | '20'
    let _optionsVolOnly = false;
    let _optionsSortCol = null;      // null | 'strike' | 'volume' | 'oi' | 'iv'
    let _optionsSortDir = 'asc';
    let _optionsExpDates = [];

    async function renderOptionsTab(symbol) {
        const emptyEl   = document.getElementById('optionsEmpty');
        const contentEl = document.getElementById('optionsContent');
        const expBar    = document.getElementById('optionsExpBar');
        const summaryEl = document.getElementById('optionsSummary');
        const gridEl    = document.getElementById('optionsChainGrid');
        if (!emptyEl) return;

        // 이미 같은 종목이면 재조회 생략
        if (_optionsSymbol === symbol && _optionsAllCalls.length) return;

        // 새 종목: 필터·정렬 상태 초기화
        _optionsFilter      = 'all';
        _optionsStrikeRange = 'all';
        _optionsVolOnly     = false;
        _optionsSortCol     = null;
        _optionsSortDir     = 'asc';
        document.querySelectorAll('.options-filter-btn').forEach(b => b.classList.remove('active'));
        const allBtn = document.getElementById('optITMBtn_all'); if (allBtn) allBtn.classList.add('active');
        const rangeBtn = document.querySelector('.opt-range-btn[data-r="all"]'); if (rangeBtn) rangeBtn.classList.add('active');

        emptyEl.style.display = 'none';
        contentEl.style.display = 'block';
        expBar.innerHTML  = '';
        summaryEl.innerHTML = '';
        gridEl.innerHTML  = '<div class="options-loading"><div class="spinner" style="width:20px;height:20px;border-width:2px;"></div>옵션 데이터 로딩 중...</div>';

        try {
            const res  = await fetch(`${API_BASE}/api/options/${encodeURIComponent(symbol)}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const chain = data?.optionChain?.result?.[0];
            if (!chain) throw new Error('옵션 데이터 없음');

            _optionsSymbol       = symbol;
            _optionsExpDates     = chain.expirationDates || [];
            _optionsCurrentPrice = chain.quote?.regularMarketPrice || stockData?.meta?.regularMarketPrice || 0;

            // 만기일 버튼 렌더
            expBar.innerHTML = _optionsExpDates.slice(0, 12).map((ts, i) => {
                const d = new Date(ts * 1000);
                const label = d.toLocaleDateString('ko-KR', { month:'2-digit', day:'2-digit', year:'2-digit' });
                return `<button class="options-exp-btn${i===0?' active':''}" onclick="loadOptionsDate(${ts})">${label}</button>`;
            }).join('');

            // 첫 번째 만기일 데이터 렌더
            const opt = chain.options?.[0];
            if (!opt) throw new Error('옵션 체인 없음');
            _optionsAllCalls = opt.calls || [];
            _optionsAllPuts  = opt.puts  || [];

            const firstTs = _optionsExpDates[0];
            if (firstTs) {
                const d = new Date(firstTs * 1000);
                document.getElementById('optionsCurrentExp').textContent =
                    `만기: ${d.toLocaleDateString('ko-KR', { year:'numeric', month:'long', day:'numeric' })}`;
            }
            renderOptionsChain();
            renderOptionsSummary();

        } catch(e) {
            gridEl.innerHTML = `<div class="options-loading" style="color:var(--red)">⚠ ${e.message}</div>`;
        }
    }

    async function loadOptionsDate(ts) {
        // 만기일 버튼 active 교체
        document.querySelectorAll('.options-exp-btn').forEach(b => {
            b.classList.toggle('active', b.onclick?.toString().includes(ts));
        });
        const d = new Date(ts * 1000);
        document.getElementById('optionsCurrentExp').textContent =
            `만기: ${d.toLocaleDateString('ko-KR', { year:'numeric', month:'long', day:'numeric' })}`;

        const gridEl = document.getElementById('optionsChainGrid');
        gridEl.innerHTML = '<div class="options-loading"><div class="spinner" style="width:18px;height:18px;border-width:2px;"></div>로딩 중...</div>';

        try {
            const res  = await fetch(`${API_BASE}/api/options/${encodeURIComponent(_optionsSymbol)}?date=${ts}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const opt  = data?.optionChain?.result?.[0]?.options?.[0];
            if (!opt) throw new Error('데이터 없음');
            _optionsAllCalls = opt.calls || [];
            _optionsAllPuts  = opt.puts  || [];
            renderOptionsChain();
            renderOptionsSummary();
        } catch(e) {
            gridEl.innerHTML = `<div class="options-loading" style="color:var(--red)">⚠ ${e.message}</div>`;
        }
    }

    function setOptionsFilter(f) {
        _optionsFilter = f;
        ['all','itm','otm'].forEach(v => {
            const el = document.getElementById(`optITMBtn_${v}`);
            if (el) el.classList.toggle('active', v === f);
        });
        renderOptionsChain();
    }

    function setOptionsStrikeRange(r) {
        _optionsStrikeRange = r;
        document.querySelectorAll('.opt-range-btn').forEach(b => {
            b.classList.toggle('active', b.dataset.r === r);
        });
        renderOptionsChain();
    }

    function toggleOptionsVolFilter() {
        _optionsVolOnly = !_optionsVolOnly;
        const btn = document.getElementById('optionsVolBtn');
        if (btn) btn.classList.toggle('active', _optionsVolOnly);
        renderOptionsChain();
    }

    function sortOptionsBy(col) {
        if (_optionsSortCol === col) {
            _optionsSortDir = _optionsSortDir === 'asc' ? 'desc' : 'asc';
        } else {
            _optionsSortCol = col;
            _optionsSortDir = col === 'strike' ? 'asc' : 'desc';
        }
        renderOptionsChain();
    }

    function renderOptionsSummary() {
        const summaryEl = document.getElementById('optionsSummary');
        const totalCallOI = _optionsAllCalls.reduce((s, o) => s + (o.openInterest || 0), 0);
        const totalPutOI  = _optionsAllPuts.reduce((s, o)  => s + (o.openInterest || 0), 0);
        const totalCallVol = _optionsAllCalls.reduce((s, o) => s + (o.volume || 0), 0);
        const totalPutVol  = _optionsAllPuts.reduce((s, o)  => s + (o.volume || 0), 0);
        const pcr = totalCallOI > 0 ? (totalPutOI / totalCallOI).toFixed(2) : '-';
        const pcrNum = parseFloat(pcr);
        const pcrColor = pcrNum >= 1 ? 'var(--red)' : 'var(--green)';
        const callPct = totalCallOI + totalPutOI > 0 ? (totalCallOI / (totalCallOI + totalPutOI) * 100).toFixed(0) : 50;
        const putPct  = 100 - callPct;
        const fmtK = v => v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(0)+'K' : v;

        summaryEl.innerHTML = `
            <div class="options-stat">
                <div class="options-stat-label">PUT/CALL RATIO</div>
                <div class="options-stat-val" style="color:${pcrColor}">${pcr}</div>
                <div class="options-pcr-bar">
                    <div class="options-pcr-fill-c" style="width:${callPct}%"></div>
                    <div class="options-pcr-fill-p" style="width:${putPct}%"></div>
                </div>
            </div>
            <div class="options-stat">
                <div class="options-stat-label">콜 미결제약정</div>
                <div class="options-stat-val" style="color:var(--green)">${fmtK(totalCallOI)}</div>
            </div>
            <div class="options-stat">
                <div class="options-stat-label">풋 미결제약정</div>
                <div class="options-stat-val" style="color:var(--red)">${fmtK(totalPutOI)}</div>
            </div>
            <div class="options-stat">
                <div class="options-stat-label">콜/풋 거래량</div>
                <div class="options-stat-val" style="font-size:14px;">
                    <span style="color:var(--green)">${fmtK(totalCallVol)}</span>
                    <span style="color:var(--text3);font-size:12px;"> / </span>
                    <span style="color:var(--red)">${fmtK(totalPutVol)}</span>
                </div>
            </div>`;
        renderOptionsAnalysis();
    }

    function renderOptionsAnalysis() {
        const el = document.getElementById('optionsAnalysis');
        if (!el) return;
        const calls = _optionsAllCalls;
        const puts  = _optionsAllPuts;
        const price = _optionsCurrentPrice;
        if (!calls.length && !puts.length) { el.innerHTML = ''; return; }

        // ─── 기본 지표 계산 ───
        const totalCallOI  = calls.reduce((s, o) => s + (o.openInterest || 0), 0);
        const totalPutOI   = puts.reduce((s, o)  => s + (o.openInterest || 0), 0);
        const totalCallVol = calls.reduce((s, o) => s + (o.volume || 0), 0);
        const totalPutVol  = puts.reduce((s, o)  => s + (o.volume || 0), 0);
        const pcrOI  = totalCallOI  > 0 ? totalPutOI  / totalCallOI  : null;
        const pcrVol = totalCallVol > 0 ? totalPutVol / totalCallVol : null;

        // ─── Max Pain 계산 ───
        const allStrikes = [...new Set([...calls.map(o => o.strike), ...puts.map(o => o.strike)])].sort((a,b) => a - b);
        let maxPain = null;
        if (allStrikes.length) {
            let minPain = Infinity;
            for (const p of allStrikes) {
                let pain = 0;
                for (const c of calls) pain += Math.max(0, p - c.strike) * (c.openInterest || 0);
                for (const u of puts)  pain += Math.max(0, u.strike - p) * (u.openInterest || 0);
                if (pain < minPain) { minPain = pain; maxPain = p; }
            }
        }

        // ─── 콜 월 / 풋 월 ───
        const callWall = calls.reduce((b, o) => (!b || (o.openInterest||0) > (b.openInterest||0)) ? o : b, null);
        const putWall  = puts.reduce((b, o)  => (!b || (o.openInterest||0) > (b.openInterest||0)) ? o : b, null);

        // ─── IV 스큐 (OTM 풋 IV / OTM 콜 IV) ───
        const otmCalls = calls.filter(o => !o.inTheMoney && (o.impliedVolatility||0) > 0);
        const otmPuts  = puts.filter(o  => !o.inTheMoney && (o.impliedVolatility||0) > 0);
        const avgCallIV = otmCalls.length ? otmCalls.reduce((s,o) => s + o.impliedVolatility, 0) / otmCalls.length : null;
        const avgPutIV  = otmPuts.length  ? otmPuts.reduce((s,o)  => s + o.impliedVolatility, 0) / otmPuts.length  : null;
        const ivSkew = (avgCallIV && avgPutIV) ? avgPutIV / avgCallIV : null;

        // ─── 시그널 & 스코어링 ───
        let bullScore = 0, bearScore = 0;
        const signals = [];

        // PCR(OI) 시그널
        if (pcrOI !== null) {
            if      (pcrOI < 0.5)  { bullScore += 3; signals.push({t:'bull', m:`PCR(OI) <strong>${pcrOI.toFixed(2)}</strong> — 강한 콜 우세, 시장 낙관론`}); }
            else if (pcrOI < 0.7)  { bullScore += 2; signals.push({t:'bull', m:`PCR(OI) <strong>${pcrOI.toFixed(2)}</strong> — 콜 우세, 상승 기대 높음`}); }
            else if (pcrOI < 1.0)  { bullScore += 1; signals.push({t:'neutral', m:`PCR(OI) <strong>${pcrOI.toFixed(2)}</strong> — 콜 소폭 우세, 중립에 가까운 상승`}); }
            else if (pcrOI < 1.3)  { bearScore += 1; signals.push({t:'neutral', m:`PCR(OI) <strong>${pcrOI.toFixed(2)}</strong> — 풋 소폭 우세, 중립에 가까운 하락`}); }
            else if (pcrOI < 1.7)  { bearScore += 2; signals.push({t:'bear',    m:`PCR(OI) <strong>${pcrOI.toFixed(2)}</strong> — 풋 우세, 하락 헤지 증가`}); }
            else                   { bearScore += 3; signals.push({t:'bear',    m:`PCR(OI) <strong>${pcrOI.toFixed(2)}</strong> — 강한 풋 우세, 하락 방어 심화`}); }
        }

        // 거래량 시그널
        if (pcrVol !== null) {
            if      (pcrVol < 0.7) { bullScore += 2; signals.push({t:'bull',    m:`콜 거래량 우세 (<strong>${totalCallVol.toLocaleString()} vs ${totalPutVol.toLocaleString()}</strong>) — 매수 모멘텀`}); }
            else if (pcrVol > 1.4) { bearScore += 2; signals.push({t:'bear',    m:`풋 거래량 우세 (<strong>${totalPutVol.toLocaleString()} vs ${totalCallVol.toLocaleString()}</strong>) — 하락 베팅 증가`}); }
            else                   {                  signals.push({t:'neutral', m:`콜/풋 거래량 균형 (<strong>${totalCallVol.toLocaleString()} / ${totalPutVol.toLocaleString()}</strong>) — 방향성 중립`}); }
        }

        // Max Pain 시그널
        if (maxPain !== null && price) {
            const diffPct = (price - maxPain) / maxPain * 100;
            if      (diffPct >  3) { bearScore += 1; signals.push({t:'bear',    m:`맥스 페인 <strong>$${maxPain}</strong> — 현재가 ${diffPct.toFixed(1)}% 위, 만기 시 하방 압력 가능`}); }
            else if (diffPct < -3) { bullScore += 1; signals.push({t:'bull',    m:`맥스 페인 <strong>$${maxPain}</strong> — 현재가 ${Math.abs(diffPct).toFixed(1)}% 아래, 만기 시 상방 압력 가능`}); }
            else                   {                  signals.push({t:'neutral', m:`맥스 페인 <strong>$${maxPain}</strong> — 현재가 근접, 균형 상태`}); }
        }

        // IV 스큐 시그널
        if (ivSkew !== null) {
            if      (ivSkew > 1.2) { bearScore += 1; signals.push({t:'bear', m:`풋 IV 스큐 <strong>${ivSkew.toFixed(2)}x</strong> — OTM 풋 변동성 높음, 하락 리스크 경계`}); }
            else if (ivSkew < 0.8) { bullScore += 1; signals.push({t:'bull', m:`콜 IV 스큐 <strong>${(1/ivSkew).toFixed(2)}x</strong> — OTM 콜 변동성 높음, 상승 기대 반영`}); }
        }

        // ─── 종합 판단 ───
        const gap = bullScore - bearScore;
        let verdictText, verdictClass;
        if      (gap >= 4)  { verdictText = '🚀 강한 매수'; verdictClass = 'strong-bull'; }
        else if (gap >= 2)  { verdictText = '📈 매수 우세'; verdictClass = 'bull'; }
        else if (gap <= -4) { verdictText = '🔻 강한 매도'; verdictClass = 'strong-bear'; }
        else if (gap <= -2) { verdictText = '📉 매도 우세'; verdictClass = 'bear'; }
        else                { verdictText = '⚖️ 중립';     verdictClass = 'neutral'; }

        const icon = t => t === 'bull' ? '🟢' : t === 'bear' ? '🔴' : '🟡';
        const fmtOI = v => v ? v.toLocaleString() : '-';

        el.innerHTML = `
        <div class="options-analysis">
            <div class="options-anal-header">
                <div class="options-anal-title">옵션 시장 분석</div>
                <div class="options-anal-verdict ${verdictClass}">${verdictText}</div>
            </div>
            <div class="options-anal-section-title">주요 가격 레벨</div>
            <div class="options-anal-grid">
                <div class="options-anal-item">
                    <div class="options-anal-item-label">맥스 페인</div>
                    <div class="options-anal-item-val">${maxPain != null ? '$' + maxPain.toFixed(0) : '-'}</div>
                    <div class="options-anal-item-sub">만기 시 옵션 매도자 최대 이익 구간</div>
                </div>
                <div class="options-anal-item">
                    <div class="options-anal-item-label">IV 스큐 (풋/콜)</div>
                    <div class="options-anal-item-val" style="color:${ivSkew > 1.15 ? 'var(--red)' : ivSkew < 0.85 ? 'var(--green)' : 'var(--text)'}">${ivSkew != null ? ivSkew.toFixed(2) + 'x' : '-'}</div>
                    <div class="options-anal-item-sub">${ivSkew > 1.15 ? '풋 IV 높음 → 하락 경계' : ivSkew != null && ivSkew < 0.85 ? '콜 IV 높음 → 상승 기대' : '균형'}</div>
                </div>
                <div class="options-anal-item">
                    <div class="options-anal-item-label">콜 월 (저항선)</div>
                    <div class="options-anal-item-val" style="color:var(--green)">${callWall ? '$' + callWall.strike : '-'}</div>
                    <div class="options-anal-item-sub">OI ${fmtOI(callWall?.openInterest)} — 강한 저항 예상</div>
                </div>
                <div class="options-anal-item">
                    <div class="options-anal-item-label">풋 월 (지지선)</div>
                    <div class="options-anal-item-val" style="color:var(--red)">${putWall ? '$' + putWall.strike : '-'}</div>
                    <div class="options-anal-item-sub">OI ${fmtOI(putWall?.openInterest)} — 강한 지지 예상</div>
                </div>
            </div>
            <div class="options-anal-divider"></div>
            <div class="options-anal-section-title">시그널 분석</div>
            <div class="options-signals">
                ${signals.map(s => `
                <div class="options-signal-row">
                    <span class="options-signal-icon">${icon(s.t)}</span>
                    <span class="options-signal-text">${s.m}</span>
                </div>`).join('')}
            </div>
        </div>`;
    }

    function renderOptionsChain() {
        const gridEl = document.getElementById('optionsChainGrid');
        const price  = _optionsCurrentPrice;
        const fmtK = v => v == null ? '-' : v >= 1e6 ? (v/1e6).toFixed(1)+'M' : v >= 1e3 ? (v/1e3).toFixed(0)+'K' : v;
        const fmtP = v => v == null ? '-' : '$' + Number(v).toFixed(2);
        const fmtIV = v => v == null ? '-' : (v * 100).toFixed(1) + '%';
        const fmtChg = v => {
            if (v == null) return '-';
            const s = (v >= 0 ? '+' : '') + v.toFixed(2);
            return `<span class="${v >= 0 ? 'opt-up' : 'opt-down'}">${s}</span>`;
        };

        const filterFn = (list) => {
            let result = list;
            // ITM / OTM 필터
            if (_optionsFilter === 'itm') result = result.filter(o => o.inTheMoney);
            else if (_optionsFilter === 'otm') result = result.filter(o => !o.inTheMoney);
            // 행사가 범위 필터 (ATM 기준 ±%)
            if (_optionsStrikeRange !== 'all' && price) {
                const pct = Number(_optionsStrikeRange) / 100;
                result = result.filter(o => o.strike >= price * (1 - pct) && o.strike <= price * (1 + pct));
            }
            // 거래량 > 0 필터
            if (_optionsVolOnly) result = result.filter(o => (o.volume || 0) > 0);
            // 정렬
            if (_optionsSortCol) {
                const keyMap = { strike: 'strike', volume: 'volume', oi: 'openInterest', iv: 'impliedVolatility' };
                const key = keyMap[_optionsSortCol];
                result = [...result].sort((a, b) => {
                    const va = a[key] ?? 0, vb = b[key] ?? 0;
                    return _optionsSortDir === 'asc' ? va - vb : vb - va;
                });
            }
            return result;
        };

        const calls = filterFn(_optionsAllCalls);
        const puts  = filterFn(_optionsAllPuts);

        const sortIcon = col => {
            if (_optionsSortCol !== col) return `<span class="opt-sort-icon">⇅</span>`;
            return _optionsSortDir === 'asc'
                ? `<span class="opt-sort-icon active">↑</span>`
                : `<span class="opt-sort-icon active">↓</span>`;
        };

        const makeTable = (list, type) => {
            if (!list.length) return '<div style="padding:24px;text-align:center;color:var(--text3);font-size:13px;">데이터 없음</div>';
            const itmClass = type === 'call' ? 'itm-call' : 'itm-put';
            const rows = list.map(o => {
                const itmBadge = o.inTheMoney ? `<span class="opt-itm-badge ${type}">ITM</span>` : '';
                return `<tr class="${o.inTheMoney ? itmClass : ''}">
                    <td><span class="opt-strike">${fmtP(o.strike)}</span>${itmBadge}</td>
                    <td>${fmtP(o.lastPrice)}</td>
                    <td>${fmtChg(o.change)}</td>
                    <td>${fmtP(o.bid)} / ${fmtP(o.ask)}</td>
                    <td class="opt-vol">${fmtK(o.volume)}</td>
                    <td>${fmtK(o.openInterest)}</td>
                    <td class="opt-iv">${fmtIV(o.impliedVolatility)}</td>
                </tr>`;
            }).join('');

            return `<div style="overflow-x:auto;"><table class="opt-tbl">
                <thead><tr>
                    <th class="opt-th-sort" onclick="sortOptionsBy('strike')">행사가 ${sortIcon('strike')}</th>
                    <th>최종가</th><th>변동</th><th>매수/매도</th>
                    <th class="opt-th-sort" onclick="sortOptionsBy('volume')">거래량 ${sortIcon('volume')}</th>
                    <th class="opt-th-sort" onclick="sortOptionsBy('oi')">미결제 ${sortIcon('oi')}</th>
                    <th class="opt-th-sort" onclick="sortOptionsBy('iv')">IV ${sortIcon('iv')}</th>
                </tr></thead>
                <tbody>${rows}</tbody>
            </table></div>`;
        };

        const callCount = calls.filter(o => o.inTheMoney).length;
        const putCount  = puts.filter(o => o.inTheMoney).length;

        gridEl.innerHTML = `
            <div class="options-card">
                <div class="options-card-hd">
                    <span class="options-card-title call">▲ 콜 옵션 (CALL)</span>
                    <span class="options-card-sub">ITM ${callCount}개 / 총 ${calls.length}개</span>
                </div>
                ${makeTable(calls, 'call')}
            </div>
            <div class="options-card">
                <div class="options-card-hd">
                    <span class="options-card-title put">▼ 풋 옵션 (PUT)</span>
                    <span class="options-card-sub">ITM ${putCount}개 / 총 ${puts.length}개</span>
                </div>
                ${makeTable(puts, 'put')}
            </div>`;
    }

    // ========================================
    // PWA 설치
    // ========================================
    let _pwaPrompt = null;

    window.addEventListener('beforeinstallprompt', e => {
        e.preventDefault();
        _pwaPrompt = e;
        const btn = document.getElementById('pwaInstallBtn');
        if (btn) btn.classList.add('visible');
    });

    window.addEventListener('appinstalled', () => {
        _pwaPrompt = null;
        const btn = document.getElementById('pwaInstallBtn');
        if (btn) btn.classList.remove('visible');
        showToast('✅ StockAI가 앱으로 설치되었습니다!');
    });

    async function pwaInstall() {
        if (!_pwaPrompt) {
            showToast('이미 설치되어 있거나 이 브라우저는 설치를 지원하지 않습니다.');
            return;
        }
        _pwaPrompt.prompt();
        const { outcome } = await _pwaPrompt.userChoice;
        if (outcome === 'accepted') {
            _pwaPrompt = null;
            const btn = document.getElementById('pwaInstallBtn');
            if (btn) btn.classList.remove('visible');
        }
    }

    // 서비스 워커 등록
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').catch(() => {});
        });
    }

    // onclick 핸들러 함수를 window에 명시적 노출 (스코프 안전장치)
    Object.assign(window, {
        closeSideNav, toggleSideNav, openSideNav, goHome,
        setMarket, searchStock, setChartInterval, setPeriod,
        quickSearch, toggleFavorite, switchTab, toggleChartFullscreen,
        favSearch, removeFavorite, setTop100Filter,
        saveAiKey, setAiPrompt, runAiIndicator,
        switchAiTab, toggleAiLine, removeAiLine, clearAllAiLines,
        setDrawTool, setDrawColor, setDrawWidth, undoDraw, clearAllDrawings,
        toggleTheme, switchTradeStyle, showLoading, hideLoading, showToast,
        loadOptionsDate, setOptionsFilter,
        setOptionsStrikeRange, toggleOptionsVolFilter, sortOptionsBy,
        manualAnalysisRefresh, pwaInstall,
        handleSearchKeydown, openSearchDropdown, closeSearchDropdown, searchSuggest, levenshtein,
        renderRRAnalysis, _applyRRGate, _isFallingKnife,
        detectBullishDivergence, _detectOBVPanic,
        renderSplitCalc, _calcSplit
    });
    </script>
</body>
</html>
